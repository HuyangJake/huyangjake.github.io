[{"title":"Npm Pod brew... 免镜像提速","date":"2018-10-27T07:55:04.000Z","path":"2018/10/27/proxy-for-terminal/","text":"标题的答案就是： 代理 像题中CocoaPods Homebrew这般的依赖包管理工具，在终端中下载资源总是常会让人抓狂。我来阐述下痛点，看下有没有共鸣 使用墙内网络，需要等到天昏地暗 使用Shadowsocks等代理工具，只能对网页以及App起作用，终端无感 使用电脑全局VPN，全部网络都走VPN影响了其他工作… 我日常使用到的是Shadowsocks服务进行科学上网，Mac客户端会对网络走向进行分流，区分国内网站还是国外网站，开了代理也不会一股脑的都是走代理。 我们要做的就是把终端的网络也走这一套代理方案，解决终端让人揪心的更新。 具体步骤1.首先在自己的ss客户端设置中查看本地监听端口，如下图： 我的端口是1086， 地址是本机地址127.0.0.1 2.在终端中输入以下代码就可以让此终端走代理（注意替换自己的ip和端口号） export ALL_PROXY=socks5://127.0.0.1:1086 要想所有的终端都走代理，将配置写入环境变量当中，这取决于你的终端，如果是默认的 bash，则写入 ~/.bash_profile，如果是 zsh，则写在 ~/.zshrc 里。 或者直接用如下语句来将命令直接导入到配置文件里 12345echo export ALL_PROXY=socks5://127.0.0.1:1086 &gt;&gt; ~/.bash_profile //如果是zsh就下边这个echo export ALL_PROXY=socks5://127.0.0.1:1086 &gt;&gt; ~/.zsh_profile 一般添加完成代理后，执行 source ~/.bash_profile 或者zsh的 source ~/.zsh_profile 让配置立即生效。 另外只有在配置完成之后打开的终端才会生效 Reference让 Homebrew 走代理更新","tags":[{"name":"随笔","slug":"随笔","permalink":"http://huyangjie.com//tags/随笔/"}]},{"title":"一键替换博客所有图片域名","date":"2018-10-27T07:53:01.000Z","path":"2018/10/27/replace-img-host-name-by-python/","text":"首先介绍下我的博客冷读空间，是一个使用hexo生成的静态博客。 博客中的图床一直使用的是七牛云的对象存储服务，我的使用方式很简单只是图片上传好之后获得一个七牛对象存储空间的默认外链地址，就放到博客中使用。完全没有什么技术含量😂 问题的诞生前段时间被告知七牛要回收默认的测试域名，这就意味着所有历史文章中的图片都要挂了。必须要绑定自己的域名到对象存储空间，并替换所有历史文章中对图片的引用地址。 问题就这么产生了，博客文章数量那么多（其实我并不多，就是懒），手动地去搜索替换多麻烦。首先想到的救星是mweb，这个强大的博客编辑工具，它的外部文档功能如果能进行全局搜索替换这个事情就简单了。 有时候人就是该磨砺一下才不会那么懒惰——搜索和替换只能单文件进行操作。我也没有再去找其他工具去实现这工作。打算自己写个简单脚本 解决方案使用苹果自带的Python2.7 环境成功跑通完成任务。 脚本中做的主要任务有三个： 获取指定目录下的所有文件名 读取博客文章文件内容 替换文章内容中指定字符串 脚本写得很粗糙，还是不要脸得贴上来了。 123456789101112131415161718192021222324252627282930313233# -*- coding: utf-8 -*-import osold_str = '*******'new_str = '*******'dir_path = 'resource-path'def read_file(file_path, name): count = 0 file_data = '' with open(file_path, 'r') as f: for line in f: if old_str in line: line = line.replace(old_str,new_str) count += 1 file_data += line print('--------文章：' + name + '------修改域名数量：' + str(count).encode('utf-8')) replace_content(file_path, file_data)def replace_content(file_path, file_data): with open(file_path, 'w') as f: f.write(file_data) def get_all_files(path): files = os.listdir(path) for file_name in files: if file_name[-2:] == 'md': read_file(os.path.join(path, file_name), file_name)if __name__ == '__main__': get_all_files(dir_path) 成果： 1234567891011121314151617➜ blog python replace_hostname.py--------文章：Apple-Debugging-开始使用LLDB.md------修改域名数量：0--------文章：Hi！CALayer我们聊聊.md------修改域名数量：2--------文章：JSPatch遇上Swift.md------修改域名数量：0--------文章：一次版本发布的启示.md------修改域名数量：3--------文章：1024.md------修改域名数量：0--------文章：小程序逻辑层.md------修改域名数量：1--------文章：机器学习-统计基础-t检验（2）.md------修改域名数量：0--------文章：机器学习-统计基础-假设检验.md------修改域名数量：0--------文章：Apple-debugging-使用LLDB替换方法为自定义的block.md------修改域名数量：0--------文章：Objective-C-isa指针.md------修改域名数量：0--------文章：自定义NSURLProtocol实现UIWebView缓存机制.md------修改域名数量：0--------文章：Objective-C中的装饰模式.md------修改域名数量：6--------文章：机器学习-统计基础-归一化-正态分布-抽样分布.md------修改域名数量：1... 替换完成后，再发布文章线上的图就都乖乖回来了。 此文章权当为简单的脚本尝试做个记录吧😂","tags":[{"name":"随笔","slug":"随笔","permalink":"http://huyangjie.com//tags/随笔/"}]},{"title":"在iOS中运行Python","date":"2018-09-03T04:27:12.000Z","path":"2018/09/03/Run-Python-in-iOS/","text":"在iOS设备中运行python脚本？那不就意味着可以在手机上跑爬虫，可以使用各种牛逼哄哄的python库了吗。 这个标题对我很有吸引力，曾经就有见到过在iOS平台上的python编译器(很多iOS上python的IDE，如Python3IDE)，可以执行输入的python语和本地的python文件。 当然我想要的不是像这篇文章说的用python编写一整个iOS程序，而只是在iOS应用中嵌入python文件执行非UI的逻辑，也就是说只需要在项目中嵌入一个python的编译环境。 面对市场上这么多的iOS版python编译器，首先可以确定的是，针对iOS端的python编译库是存在的。我关心的问题是，能否支持python项目化的编译，能否导入丰富的三方库。那就动手一试咯 小目标七牛的iOS平台SDK有这样一个特点，上传文件的时候需要生成token，但是生成token的逻辑在客户端的SDK中不存在，只能通过调用服务端的SDK才能获得。于是我们的小目标就诞生了：在iOS端上调用七牛python服务端SDK来生成token给客户端的七牛SDK使用。 iOS的Python解释器针对iOS、MacOS平台，pybee开源了python支持库Python-Apple-support，这个是老版本的库Python-iOS-support. 准备编译环境我这次使用的是老库中的Python3.4.2-b5版本，下载下来有两个framework，分别是OpenSSL和Python。将这个两个framework拖入项目中，添加必要的lib库如图： 在项目中创建PythonEnvironment.bundle将Python.framework中的Resources文件夹内容复制进去，在初始化Python环境之前将bundle中的文件复制到指定目录作为Home路径 设置Home路径、初始化设置上面准备home路径，并初始化编译环境。 123456789const char * frameworkPath = [[NSString stringWithFormat:@\"%@/Resources\",[self p_pythonFrameworkPath]] UTF8String];wchar_t *pythonHome = _Py_char2wchar(frameworkPath, NULL);Py_SetPythonHome(pythonHome);Py_Initialize();PyEval_InitThreads();//在释放的时候调用Py_Finalize(); 执行Python代码、文件编译环境设置好之后，使用PyRun_SimpleString(python_code)便可以简单执行Python代码 1PyRun_SimpleString(\"print('hello world')\"); 便可以输出hello world 执行Python文件12345NSString *scriptPath = [[NSBundle mainBundle] pathForResource:@\"test\" ofType:@\"py\"]; FILE *mainFile = fopen([scriptPath UTF8String], \"r\"); PyRun_SimpleFile(mainFile, (char *)[[scriptPath lastPathComponent] UTF8String]); 上面是执行main bundle中的Python文件方式，这种方式暂时没有找到如何调用文件中的某各类具体方法和传参。 另外一种方式可以做到上面描述的需求，将在下一节中说明 准备七牛Python库下载好的七牛SDK文件源码解压，在Xcode中创建一个bundle加入项目中，bundle中放七牛SDK的核心文件，如图： 在需要使用七牛SDK之前，将此bundle中的文件拷贝到Python运行环境的home目录下 编写token生成Python文件查看七牛的文档了解到生成token需要用到auth.py这个文件中的Auth类， 我们需要想办法创建一个Auth实例并传入需要的参数，再将生成的token导出来。 首先自己创建一个iostoken.py文件，Python的文件名和方法名需要小写，类名需要大写。在iostoken.py中创建TokenForiOS类 12345678910111213141516171819import jsonfrom qiniu import Authclass TokenForiOS(object): def create_token(jsonParams): print(str(jsonParams)) values = json.loads(jsonParams) access_key = values.get('access_key') secret_key = values.get('secret_key') #要上传的空间 bucket_name = values.get('bucket_name') #上传到七牛后保存的文件名 file_name = values.get('file_name') #构建鉴权对象 q = Auth(access_key, secret_key) #生成上传 Token，可以指定过期时间等 token = q.upload_token(bucket_name, file_name, 3600) return token 上面是我使用七牛SDK中的Auth生成token的代码，类名为TokenForiOS方法名为create_token，现在需要找到合适的地方调用。 不过在想要使用TokenForiOS类之前，需要将其加入qiniu模块的初始化__init__.py中： 1from .iostoken import TokenForiOS 接下来就可以愉快地调用了 Python.framework中有一套宏可以导入Python模块，生成实例，传参调用方法，具体使用例子见下代码块 123456789101112131415161718192021222324PyObject *pModule = PyImport_ImportModule([@\"qiniu.iostoken\" UTF8String]);//导入模块 PyObject *pyClass = PyObject_GetAttrString(pModule, [@\"TokenForiOS\" UTF8String]);//获取类 PyObject *pyInstance = PyInstanceMethod_New(pyClass); //创建实例 NSMutableDictionary *params = [NSMutableDictionary new];[params setObject:@\"123\" forKey:@\"access_key\"];[params setObject:@\"456\" forKey:@\"secret_key\"];[params setObject:@\"jake\" forKey:@\"bucket_name\"];[params setObject:@\"pic\" forKey:@\"file_name\"]; NSError *error = nil;NSData *jsonData = [NSJSONSerialization dataWithJSONObject:params options:NSJSONWritingPrettyPrinted error:&amp;error];NSString *paramterJsonString = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding]; PyObject *result = NULL;result = PyObject_CallMethod(pyInstance, [@\"create_token\" UTF8String], \"(s)\", [paramterJsonString UTF8String] );char * resultCString = NULL;PyArg_Parse(result, \"s\", &amp;resultCString); //将python类型的返回值转换为c NSLog(@\"%s\", resultCString); 至此，我的小目标就完成啦。后面还有很多事情可以做，比如跑个爬虫试试，毕竟还没有尝试过网络请求。当然也还有很多坑要踩。 总结使用过程中有下面几点体会 Python-Apple-support库的缺少文档 查看Python的c-api库：https://docs.python.org/3.5/c-api/ ，在设置Home目录导入模块的过程中踩了很多坑 编译器对Python语法提示并不支持，难以排查写错的地方 framework的体积是在过大，对项目总体积影响大 PS:在查询过程中发现了PyObjc这个项目，能够使用python通过bridge调用OC的方法从而使用Cocoa框架，实现使用python编写Cocoa GUI应用。 PyObjC is a bridge between Python and Objective-C. It allows Python scripts to use and extend existing Objective-C class libraries; most importantly the Cocoa libraries by Apple. This document describes how to use Objective-C class libraries from Python scripts and how to interpret the documentation of those libraries from the point of view of a Python programmer. Reference在iOS app中运行Python文件（Swift+Objective C+Python) 带Demo iOS 工程中调用Python方法（带Demo） Embedding Python in an iPhone app PyObjc","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"iOS多线程安全---属性篇","date":"2018-08-25T01:33:02.000Z","path":"2018/08/25/multithreading-property/","text":"APP内涉及到多线程的设计难免会增加Debug的难度。但其实多线程共同访问同一个对象或是一段代码，在编程过程中经常用到，这就需要考虑到多线程安全。 Property1@property (nonatomic, strong) NSString *userName; 上面定义属性是我们工作中常用的方式，印象里只是nonatomic是非原子性，可以提高性能。而atomic是Property的原子性修饰，开发中一般不使用，原因是atomic原子性修饰在大多数情况下没有这样的需求，并且频繁调用会影响性能，另外atomic更严格地说并不能绝对保证线程的安全。 Why？ 先了解atomic的具体实现： atomic的本质其实是对getter和getter方法加锁，使用的是spinlock_t自旋锁。 具体的实现在runtime源码中的objc-accessors.mm文件 getter方法实现 123456789101112131415161718id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) &#123; if (offset == 0) &#123; return object_getClass(self); &#125; // Retain release world id *slot = (id*) ((char*)self + offset); if (!atomic) return *slot; // Atomic retain release world spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); id value = objc_retain(*slot); slotlock.unlock(); // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock. return objc_autoreleaseReturnValue(value);&#125; setter方法实现 1234567891011121314151617181920212223242526272829303132static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)&#123; if (offset == 0) &#123; object_setClass(self, newValue); return; &#125; id oldValue; id *slot = (id*) ((char*)self + offset); if (copy) &#123; newValue = [newValue copyWithZone:nil]; &#125; else if (mutableCopy) &#123; newValue = [newValue mutableCopyWithZone:nil]; &#125; else &#123; if (*slot == newValue) return; newValue = objc_retain(newValue); &#125; if (!atomic) &#123; oldValue = *slot; *slot = newValue; &#125; else &#123; spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); oldValue = *slot; *slot = newValue; slotlock.unlock(); &#125; objc_release(oldValue);&#125; 值类型Property先以BOOL值类型为例，当我们有两个线程访问如下property的时候： 1234567@property (nonatomic, assgin) BOOL isDeleted;//thread 1bool isDeleted = self.isDeleted;//thread 2self.isDeleted = false; 线程1和线程2，一个读(load)，一个写(store)，对于BOOL isDeleted的访问可能有先后之分，但一定是串行排队的。而且由于BOOL大小只有1个字节，64位系统的地址总线对于读写指令可以支持8个字节的长度，所以对于BOOL的读和写操作我们可以认为是原子的，所以当我们声明BOOL类型的property的时候，从原子性的角度看，使用atomic和nonatomic并没有实际上的区别（当然如果重载了getter方法就另当别论了）。 如果是int类型呢？ 1234567@property (nonatomic, assgin) int count;//thread 1int curCount = self.count;//thread 2self.count = 1; 同理int类型长度为4字节，读和写都可以通过一个指令完成，所以理论上读和写操作都是原子的。从访问内存的角度看nonatomic和atomic也并没有什么区别。多线程访问内存 那么设置atomic的用处？ 设置atomic之后，默认生成的getter和setter方法执行是原子的。也就是说，当我们在线程1执行getter方法的时候（创建调用栈，返回地址，出栈），线程B如果想执行setter方法，必须先等getter方法完成才能执行。举个例子，在32位系统里，如果通过getter返回64位的double，地址总线宽度为32位，从内存当中读取double的时候无法通过原子操作完成，如果不通过atomic加锁，有可能会在读取的中途在其他线程发生setter操作，从而出现异常值。如果出现这种异常值，就发生了多线程不安全。 然而设置了atomic也不一定安全 12345678910111213@property (atomic, assign) int intA;//thread Afor (int i = 0; i &lt; 10000; i ++) &#123; self.intA = self.intA + 1; NSLog(@\"Thread A: %d\\n\", self.intA);&#125;//thread Bfor (int i = 0; i &lt; 10000; i ++) &#123; self.intA = self.intA + 1; NSLog(@\"Thread B: %d\\n\", self.intA);&#125; 即使将intA声明为atomic，最后的结果也不一定会是20000。原因就是因为self.intA = self.intA + 1;不是原子操作，虽然intA的getter和setter是原子操作，但当我们使用intA的时候，整个语句并不是原子的，这行赋值的代码至少包含读取(load)，+1(add)，赋值(store)三步操作，当前线程store的时候可能其他线程已经执行了若干次store了，导致最后的值小于预期值。这种场景我们也可以称之为 多线程不安全。 指针Property指向的内存区域这一类多线程的访问场景是我们很容易出错的地方，即使我们声明property为atomic，依然会出错。因为我们访问的不是property的指针区域，而是property所指向的内存区域。可以看如下代码： 1234567891011121314151617181920@property (atomic, strong) NSString *stringA;//thread Afor (int i = 0; i &lt; 100000; i ++) &#123; if (i % 2 == 0) &#123; self.stringA = @\"a very long string\"; &#125; else &#123; self.stringA = @\"string\"; &#125; NSLog(@\"Thread A: %@\\n\", self.stringA);&#125;//thread Bfor (int i = 0; i &lt; 100000; i ++) &#123; if (self.stringA.length &gt;= 10) &#123; NSString* subStr = [self.stringA substringWithRange:NSMakeRange(0, 10)]; &#125; NSLog(@\"Thread B: %@\\n\", self.stringA);&#125; 虽然stringA是atomic的property，而且在取substring的时候做了length判断，线程B还是很容易crash，因为在前一刻读length的时候self.stringA = @&quot;a very long string&quot;;，下一刻取substring的时候线程A已经将self.stringA = @&quot;string&quot;;，立即出现out of bounds的Exception，crash，— 多线程不安全。 为什么值类型不太需要考虑线程问题 值类型的赋值都是深拷贝，是两个独立的对象。 值类型和引用类型并不是绝对独立的 值类型嵌套值类型 值类型嵌套引用类型 引用类型嵌套引用类型 引用类型嵌套值类型 多线程内存访问先来看下多线程是如何同时访问内存的。不考虑CPU cache对变量的缓存，内存访问可以用下图表示： 从上图中可以看出，我们只有一个地址总线，一个内存。即使是在多线程的环境下，也不可能存在两个线程同时访问同一块内存区域的场景，内存的访问一定是通过一个地址总线串行排队访问的，所以在继续后续之前，我们先要明确几个结论： 结论一：内存的访问时串行的，并不会导致内存数据的错乱或者应用的crash。 结论二：如果读写（load or store）的内存长度小于等于地址总线的长度，那么读写的操作是原子的，一次完成。比如bool，int，long在64位系统下的单次读写都是原子操作。 对于平时编写应用层多线程安全代码，建议还是多使用@synchronized，NSLock，或者dispatch_semaphore_t，多线程安全比多线程性能更重要，应该在前者得到充分保证，犹有余力的时候再去追求后者。 参考文章： iOS多线程到底不安全在哪里？ 关于synchronized 理解iOS中的锁 OC中atomic属性如何保证线程安全 runtime库","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"程序员的异次元世界---个人博客","date":"2018-06-29T15:16:37.000Z","path":"2018/06/29/how-to-choose-blog/","text":"都说程序员比较闷，但若看了程序员的博客，那可能看法就不一样了。这也是为什么本文的标题叫异次元世界。 同一个世界的我们心中飘荡着不同的宇宙 个人博客，是多样化的存在。每个人对它赋予的使命会不一样，它对于个人的意义也会有差别。对程序员这个群体而言，博客有着一种别样的亲和力。互联网是因分享而生，而程序员作为互联网中的土著民，更是贡献榜的中流砥柱。新的知识将不断地涌入，极客精神是一大动力来源，博客(文字描述)往往是其传播的载体。在自己的领土上讲述属于自己的语言，还能有比这更有亲和力的事吗？ 写一篇博文是在讲一个故事，一个好的故事不仅能讲出真相，并且能让别人都原意且听得懂。讲故事的是作者，文章也就是作者心中宇宙的缩影。 因此想要了解一个人的内心宇宙，那就去看他的博客。说不定雄赳赳的外表下是一颗少女心。 正篇选择什么博客系统？ 现在简单实用的博客系统很多，也有人完全自己写了一个系统，这个其实见仁见智。我比较喜欢的是简约风格，但是一定要支持MarkDown语法来编辑文章。因为作为大部分为技术输出的地方，需要用户能清晰地看清文章表达的思想和逻辑，这就不适合有太多其他的干扰，而MarkDown对程序员很友好，简单，不用太在意样式，写代码片段和公式都很方便。 平台博客系统简书简单，注重内容。支持MarkDown，对程序员比较友好。有比较多的技术圈，存在一些技术大牛。 博客园 &amp; CSDN国内比较老牌的一些技术社区 知乎SegmentFault风格类似国外的Stack Overflow，最像技术的社区，但是人气不高。 Medium 独立博客系统WordPress大而全的博客系统，很多网站都是基于这个系统进行开发的。它拥有数据量庞大的插件来支持其强大的功能。类似于正统建站博客系统的风格。 OctoPressHexo我的博客使用的就是 Hexo GhostJekyll 编辑工具工欲善其事，必先利其器。虽然我只是写写文字，贴贴图片，但如果能把写作之外的事情尽可能地简化，精力都放在写作上，那也不失为一大快事。 我写文章使用的都是MarkDown所以这里推荐的都是带MarkDown编辑功能的工具。 每个工具都带有用来创造它的那种精神。——海森堡《物理学与哲学》 Mou这个是我第一个使用的MarkDown编辑器，就喜欢它的轻便，和清新的风格，又能导出PDF，HTML之类。当时我用它写博客，写周报导出HTML贴到邮件上，让邮件变得贼有范。 但是随着OSX升级，Mou不再支持OS X10.11以上的系统了。一度非常地伤心，但是系统是爸爸，只好说再见。 软件官网：http://25.io/mou/现在好像在预发1.0版本，应该会支持到最新的MacOS了。半价预售中，15刀。-_- 贵还是挺贵的 (后来知道Mou是个跳票王，Twitter上是15年说要发布1.0版本了) StackEdit这是一个开源的在线markdown编辑器，在我升级了系统没得用Mou后，我也用过一段时间。总体感觉就是，在线的总是没有本地的应用体验好。预发支持倒是挺全的，甚至可以写 UML 图表。支持从本地打开，在线同步存储支持DropBox， GoogleDrive 要自己的服务器上搭建一个免费的编辑器倒是个不错的选择 编辑器地址：https://stackedit.io/editor GitHub仓库：https://github.com/benweet/stackedit MacDownMacDown很长的一段时间都扮演着我的救世主，到现在我也还有时候会用到它。MacDown长得可以说跟Mou非常像了，只不过长得是黑白脸 从作者的描述来看，他是Mou的重度用户，因为Mou没有再更新所以决定自己来写一个并同时致敬Mou。同时因为开源也发展得很快。 MacDown is an open source Markdown editor for OS X, released under the MIT License. The author stole the idea from Chen Luo’s Mou so that people can make crappy clones. 软件官网：http://macdown.uranusjr.com/GitHub仓库：https://github.com/MacDownApp/macdown 碰撞慢慢地，我开始想，我平时记录笔记是否能够跟我的博客MarkDown写作习惯结合起来，但又不想让文件散散落落。我开始往结构化管理文档的方面去探索（后来我才发现我是在寻找 笔记软件 和 写作软件 的碰撞）。在写博客之前，我也有记录笔记的习惯，用的一直是印象笔记，里面记录了我刚学习iOS时的风风雨雨。但后来慢慢演变为看到好的文章，浏览器的印象笔记插件Clip一下，微博上看到好文，@印象笔记，慢慢我的印象笔记本成了“好物”垃圾场。印象笔记还有国内的有道云笔记之类有一个共同特征：它们不希望用户离开它们的体系，所以不允许内容从内部脱离框架传播。以至于我们笔记的传播分享，只能是在笔记本软件内部，并且是注册用户之间。而且…还不支持MarkDown。因此我打算跳出来，尝试了一段时间微软的OneNote，文档管理的方式别具一格，但还是传统的笔记软件的模式。直到有一天… 一支为技术而生的弓箭射入我的眼帘 Quiverslog就是： The Programmer’s NoteBook看来是主打程序员群体了，我还是挺认同的。 Quiver上手还是非常容易，简单易懂。除了MacDown上的功能之外它拥有的最大的几个特点： 文章以Cell为单位组装，每个Cell可以设置自己的编辑模式如下图:还特地贴心地拎出了Code Cell， 这个中Cell模式是这个应用的核心。 文章使用本地的数据库，对文章进行归档分类，可以将数据库文件备份。我使用云网盘同步本地的数据库文件，也相当于将文章实时备份云端吧。 有演示模式全屏展示 这个是我现在自己配置的主题： 除了了Mac版本，Quiver还有iOS版的（免费），但是只是支持从DropBox和支持WebDAV的网盘中读取备份的Quiver数据库进行浏览文章。 软件官网：http://happenapps.com/ MWeb刚开始接触这个是因为它上了少数派的首页推荐，同时也在AppStore的推荐榜上看到了它。于是就来体验下它的过人之处，一上手发现MWeb的功能设计得..太多了，无从下手。迷茫了一段时间之后，我开始疯狂地爱上了它。现在MWeb是我最喜欢使用的写作软件。 MWeb最大的优势是对静态博客的写作支持得非常到位。随手列几个我最喜欢的功能： 支持文档库(自建数据库) 和 外部文档模式（博客系统文档库） 文档库可以生成静态页面 我使用这个功能将静态页面放在本地的tomcat服务上，相当于有了一个本地的笔记小博客。放到自己服务器上就可以当做自己的博客啦。具体使用可以参考把生成的静态网站发布到github或FTP 支持图床一键上传 支持一键发布静态博客（支持脚本发布） 这篇文章就是使用MWeb进行编辑发布的 MWeb也有iOS版本，专业版￥60。可以在iOS版上进行写作，甚至发布文章。 软件官网：https://zh.mweb.im/ 现在MWeb 3刚发布，还处于半价￥60销售中 最后附上一个表格对比下 产品名 优势 劣势 价格 Mou 轻便清新 很久没跟新，暂不支持MacOS 10.11以上 $15（半价预售） StackEdit 在线编辑随时随地 响应略慢，存储不方便 免费 MacDown 轻便 黑白脸不好看(当然也有主题) 免费 Quiver 文件归档 中文检索功能略不足 ￥68 MWeb 静态博客发布神器 在我眼中不存在 ￥60（半价促销中） 其他的写作软件还有接触过Ulysses Bear 也是用户量非常多的两款应用，由于我使用体验不够多就不进行分析。但是可以确定的是此两款应用体验上也是属于非常优秀的，只是我已经心有所属。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://huyangjie.com//tags/随笔/"}]},{"title":"Realm 质感记录","date":"2018-05-27T03:49:56.000Z","path":"2018/05/27/Realm-petting-feeling/","text":"先来段代码欣赏下 1234567891011121314let myDog = Dog()myDog.name = \"Fido\"myDog.age = 1try! realm.write &#123; realm.add(myDog)&#125;let myPuppy = realm.objects(Dog.self).filter(\"age == 1\").firsttry! realm.write &#123; myPuppy!.age = 2&#125;print(\"age of my dog: \\(myDog.age)\") // =&gt; 2 Models（数据库中的表）属性 Realm supports the following property types: Bool, Int, Int8, Int16, Int32, Int64, Double, Float, String, Date, and Data. CGFloat properties are discouraged, as the type is not platform independent. String, Date and Data properties can be optional. Object properties must be optional. Storing optional numbers is done using RealmOptional. 在Swift中存储对象必须使用optional，存储optional numbers使用RealmOptional String, Data, Date 这三种类型的属性可是可选类型可也以不是 12345678910111213141516class Person: Object &#123; // Optional string property, defaulting to nil @objc dynamic var name: String? = nil // Optional int property, defaulting to nil // RealmOptional properties should always be declared with `let`, // as assigning to them directly will not work as desired let age = RealmOptional&lt;Int&gt;()&#125;let realm = try! Realm()try! realm.write() &#123; var person = realm.create(Person.self, value: [\"Jane\", 27]) // Reading from or modifying a `RealmOptional` is done via the `value` property person.age.value = 28&#125; 主键主键一旦被添加了就不能被修改 12345678class Person: Object &#123; @objc dynamic var id = 0 @objc dynamic var name = \"\" override static func primaryKey() -&gt; String? &#123; return \"id\" &#125;&#125; 索引非必要的时候不建议添加索引，这会增加数据库的大小。 12345678class Book: Object &#123; @objc dynamic var price = 0 @objc dynamic var title = \"\" override static func indexedProperties() -&gt; [String] &#123; return [\"title\"] &#125;&#125; 索引支持 string, integer, boolean, Date类型的属性 Ignoring properties不想要存储到Realm中的属性可以添加标记为ignoredProperties 123456789101112class Person: Object &#123; @objc dynamic var tmpID = 0 var name: String &#123; // read-only properties are automatically ignored return \"\\(firstName) \\(lastName)\" &#125; @objc dynamic var firstName = \"\" @objc dynamic var lastName = \"\" override static func ignoredProperties() -&gt; [String] &#123; return [\"tmpID\"] &#125;&#125; 属性修饰词 Type Non-optional Optional Bool @objc dynamic var value = false let value = RealmOptional() Int @objc dynamic var value = 0 let value = RealmOptional() Float @objc dynamic var value: Float = 0.0 let value = RealmOptional() Double @objc dynamic var value: Double = 0.0 let value = RealmOptional() String @objc dynamic var value = “” @objc dynamic var value: String? = nil Data @objc dynamic var value = Data() @objc dynamic var value: Data? = nil Date @objc dynamic var value = Date() @objc dynamic var value: Date? = nil Object n/a: must be optional @objc dynamic var value: Class?=nil List let value = List() n/a: must be non-optional LinkingObjects let value = LinkingObjects(fromType: Class.self, property: “property”) n/a: must be non-optional Relationships关系连接数据库的两个对象（表），只需要通过Object和List这个两个属性就可以了。 List非常像Array，List中只能存在单种类型的对象。 Many-to-One 多对一创建一对一或者多对一的关系时，只需要在模型中创建一个将要关联对象类型的对象。 12345678class Dog: Object &#123; @objc dynamic var name = \"\"&#125;class Dog: Object &#123; // ... other property declarations @objc dynamic var owner: Person? // to-one relationships must be optional&#125; Usage 123let jim = Person()let rex = Dog()rex.owner = jim Many-to-Many 多对多使用List属性创建关系 12345678class Person: Object &#123; // ... other property declarations let dogs = List&lt;Dog&gt;()&#125;let someDogs = realm.objects(Dog.self).filter(\"name contains 'Fido'\")jim.dogs.append(objectsIn: someDogs)jim.dogs.append(rex) Inverse relationships 逆关系从Person可以找到Dog对象，但是不能够从Dog找到它的主人对象。除非是使用一对一的关系，但是这个关系是独立的，给Person对象添加一个新的Dog，并不会讲这个Dog对象中的owner属性设置到正确的Person。因此引入了逆关系 12345class Dog: Object &#123; @objc dynamic var name = \"\" @objc dynamic var age = 0 let owners = LinkingObjects(fromType: Person.self, property: \"dogs\")&#125; 上面的Dog对象中的owners属性中将包含所有拥有这个Dog对象的Person对象。 NotificationsRealm Notification通知返回的是这个通知的token，一旦token被释放了，就意味着这个通知也被注销了。 一旦有相关的写操作被提交，无论在什么线程上的写操作，通知将会异步地被触发，此时可以进行UI的刷新。 1234567// Observe Realm Notificationslet token = realm.observe &#123; notification, realm in viewController.updateUI()&#125;// latertoken.invalidate() 在通知的block中进行数据库的写操作将会抛出异常，可以使用Realm.isInWriteTransaction来区分当前是否处于写的事务中。 注意通知所在的线程将于注册通知时所处的线程相同。如果不是在主线程注册的通知，则需要给该线程启动一个run loop。因为通知的传递需要依靠run loop，当一个run loop中有其他的任务在执行，那么realm的通知可能会被延迟，因此会有多个写操作事务合并到同一个通知中。 Collection NotificationCollection的通知在objects添加、删除、修改的时候都会触发，但不会接收整个realm，只会接收改变的部分数据。通过Block的参数RealmCollectionChange可以获取到改变的值，包括删除、插入、修改影响到的索引位置。 一个对象的属性发生变化、属性List中的对象发生变化，不管是对多还是对一的关系，都会触发通知。 123456789class Dog: Object &#123; @objc dynamic var name = \"\" @objc dynamic var age = 0&#125;class Person: Object &#123; @objc dynamic var name = \"\" let dogs = List&lt;Dog&gt;()&#125; 123456789101112131415161718192021222324252627282930313233343536class ViewController: UITableViewController &#123; var notificationToken: NotificationToken? = nil override func viewDidLoad() &#123; super.viewDidLoad() let realm = try! Realm() let results = realm.objects(Person.self).filter(\"age &gt; 5\") // Observe Results Notifications notificationToken = results.observe &#123; [weak self] (changes: RealmCollectionChange) in guard let tableView = self?.tableView else &#123; return &#125; switch changes &#123; case .initial: // Results are now populated and can be accessed without blocking the UI tableView.reloadData() case .update(_, let deletions, let insertions, let modifications): // Query results have changed, so apply them to the UITableView tableView.beginUpdates() tableView.insertRows(at: insertions.map(&#123; IndexPath(row: $0, section: 0) &#125;), with: .automatic) tableView.deleteRows(at: deletions.map(&#123; IndexPath(row: $0, section: 0)&#125;), with: .automatic) tableView.reloadRows(at: modifications.map(&#123; IndexPath(row: $0, section: 0) &#125;), with: .automatic) tableView.endUpdates() case .error(let error): // An error occurred while opening the Realm file on the background worker thread fatalError(\"\\(error)\") &#125; &#125; &#125; deinit &#123; notificationToken?.invalidate() &#125;&#125; 如此就可以根据具体需要刷新的位置来局部刷新列表，不需要整个重新地刷新。 Object Notifications可以监听对象，当对象被删除或者对象的内容改变的时候会触发通知。修改对象属性的时候触发通知的参数会返回对象的属性数组，包含每个属性的旧值和新值 12345678910111213141516171819202122232425class StepCounter: Object &#123; @objc dynamic var steps = 0&#125;let stepCounter = StepCounter()let realm = try! Realm()try! realm.write &#123; realm.add(stepCounter)&#125;var token : NotificationToken?token = stepCounter.observe &#123; change in switch change &#123; case .change(let properties): for property in properties &#123; if property.name == \"steps\" &amp;&amp; property.newValue as! Int &gt; 1000 &#123; print(\"Congratulations, you've exceeded 1000 steps.\") token = nil &#125; &#125; case .error(let error): print(\"An error occurred: \\(error)\") case .deleted: print(\"The object was deleted.\") &#125;&#125; Interface-driven writes在添加数据之后需要同步刷新UI的操作，就不需要再出发一个异步的通知去刷新TableView了，以免引起crash。 在提交写操作的时候只需要调用Realm.commitWrite(withoutNotifying:) 123456789101112131415161718192021222324252627282930// Add fine-grained notification blocktoken = collection.observe &#123; changes in switch changes &#123; case .initial: tableView.reloadData() case .update(_, let deletions, let insertions, let modifications): // Query results have changed, so apply them to the UITableView tableView.beginUpdates() tableView.insertRows(at: insertions.map(&#123; IndexPath(row: $0, section: 0) &#125;), with: .automatic) tableView.deleteRows(at: deletions.map(&#123; IndexPath(row: $0, section: 0)&#125;), with: .automatic) tableView.reloadRows(at: modifications.map(&#123; IndexPath(row: $0, section: 0) &#125;), with: .automatic) tableView.endUpdates() case .error(let error): // handle error () &#125;&#125;func insertItem() throws &#123; // Perform an interface-driven write on the main thread: collection.realm!.beginWrite() collection.insert(Item(), at: 0) // And mirror it instantly in the UI tableView.insertRows(at: [IndexPath(row: 0, section: 0)], with: .automatic) // Making sure the change notification doesn't apply the change a second time try collection.realm!.commitWrite(withoutNotifying: [token])&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"Realm 触感记录","date":"2018-05-26T15:36:24.000Z","path":"2018/05/26/Realm-touch-feeling/","text":"简单地看了Realm的demo，感觉这个数据库在移动端给人的感觉是写着原生的代码，编写一个个对象就可以毫无感知地创建一个个数据库表。这里记录Realm数据库的创建和删除。 Realm文档地址 查看本地的数据库打印地址： 1print(Realm.Configuration.defaultConfiguration.fileURL!) 或者在断点的时候： 1234567891011Objective-C:(lldb) po [RLMRealmConfiguration defaultConfiguration].fileURLSwift using Realm Objective-C:(lldb) po RLMRealmConfiguration.defaultConfiguration().fileURLSwift using Realm Swift:(lldb) po Realm.Configuration.defaultConfiguration.fileURLOr if you have an RLMRealm instance at hand, you can use:(lldb) po myRealm.configuration.fileURL stackoverflow: How to find my realm file? 创建多个数据库App登录不同的用户可以创建一个每个用户独立的数据库文件。 123456789101112131415//create default Realm.let realm = try! Realm()//create configured Realmlet config = Realm.Configuration( // Get the URL to the bundled file fileURL: Bundle.main.url(forResource: \"MyBundledData\", withExtension: \"realm\"), // Open the file in read-only mode as application bundles are not writeable readOnly: true)// Open the Realm with the configurationlet realm = try! Realm(configuration: config) 创建的地址默认都是在Documents文件夹下，初始化的时候指定了fileUrl需要保证能有写的权限，像上面例子中在Bundle中的数据库，它将是只读的，需要在打开的时候带上readOnly，如果需要写的话就复制到沙盒中使用。 创建存储在内存中的数据库1let realm = try! Realm(configuration: Realm.Configuration(inMemoryIdentifier: \"MyInMemoryRealm\")) 创建远程同步的数据库1234567// Create the configurationlet syncServerURL = URL(string: \"realm://localhost:9080/~/userRealm\")!let config = Realm.Configuration(syncConfiguration: SyncConfiguration(user: user, realmURL: syncServerURL))// Open the remote Realmlet realm = try! Realm(configuration: config)// Any changes made to this Realm will be synced across all devices! 如果打开一个数据库需要伴随着耗时的操作，或者打开远程数据库是只读属性的，那么需要使用asyncOpenAPI 12345678910let config = Realm.Configuration(schemaVersion: 1, migrationBlock: &#123; migration, oldSchemaVersion in // potentially lengthy data migration&#125;)Realm.asyncOpen(configuration: config) &#123; realm, error in if let realm = realm &#123; // Realm successfully opened, with migration applied on background thread &#125; else if let error = error &#123; // Handle error that occurred while opening the Realm &#125;&#125; 12345678let config = Realm.Configuration(syncConfiguration: SyncConfiguration(user: user, realmURL: realmURL))Realm.asyncOpen(configuration: config) &#123; realm, error in if let realm = realm &#123; // Realm successfully opened, with all remote data available &#125; else if let error = error &#123; // Handle error that occurred while opening or downloading the contents of the Realm &#125;&#125; 创建只能存贮指定类型数据的数据库下面这个数据库中就能存储MyClass和MyOtherClass 12let config = Realm.Configuration(objectTypes: [MyClass.self, MyOtherClass.self])let realm = try! Realm(configuration: config) 彻底删除一个本地数据库再删除数据库之前，需要保证所有被Realm持有的对象都被释放了，包括所有从Realm数据库中读取的和添加到数据库中的对象。在删除realm文件的时候也需要删除其他的附属文件。 1234567891011121314151617autoreleasepool &#123; // all Realm usage here&#125;let realmURL = Realm.Configuration.defaultConfiguration.fileURL!let realmURLs = [ realmURL, realmURL.appendingPathExtension(\"lock\"), realmURL.appendingPathExtension(\"note\"), realmURL.appendingPathExtension(\"management\")]for URL in realmURLs &#123; do &#123; try FileManager.default.removeItem(at: URL) &#125; catch &#123; // handle error &#125;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"AFNetworking 实现断点续传","date":"2018-05-15T15:14:19.000Z","path":"2018/05/15/breakpoint-resume-in-iOS/","text":"思路 从协议层面来说，断点续传的实现都是通过http头里面的Range来实现的。对于以前asi的实现和基于NSURLConnection的实现来说，我们都是通过手动保存当前大小然后填充到Range的策略来实现断点续传功能的。 NSURLSession内置了对于断点续传的api支持，主要是通过resumeData和tmp中间文件。在NSURLSession暂停时，其中间文件的相关信息被保存到resumeData，我们只要通过这个resumeData，即可从之前的下载进度中恢复。也就是说1中的细节被封装在api内部了。 目前来看，基于NSURLSession的断点续传主要有两个问题需要考虑： a. 程序退出（手动kill等）时需要自动保存resumeData，后续应用起来时再恢复之。 b. iOS10里面的resumeData的保存有点问题，需要特别处理，可以参考此demo:https://github.com/HustHank/BackgroundDownloadDemo. 上述引用中的 第2点就是我们方案中的App生命周期内的断点续传，只是我们调用的是AFNetworking的API 第1点是我们方案中离线点断续传的思路，不同的是我们使用的是基于NSURLSession的AFNetworking来实现这个逻辑（AFNetworking原生也不支持离线断点续传）。实现的方案跟引用中提到自动保存resumeData也不一致，我们使用文件流保存数据，没有取系统提供的resumeData使用。 设计流程 查看大图 文件保存逻辑断点续传有一个必要的逻辑： 在开始发起请求任务之前，在本地查找匹配的文件计算下载数据开始的位置。 这里面有一个隐藏的问题： 当某个文件在上一次下载任务中已经下载完成，这次发起请求的时候会读取这个文件的大小设置到请求头的Range，从而发起一个不需要下载任何数据的请求。 解决这个问题途径有两个： 在触发下载任务之前进行文件分析判断是否需要下载 区分下载中和下载完成的路径 前者在实现过程中遇到问题，在请求发起之前没办法切确判断本地读取到的文件数据是否完整。或许可以使用某些类型文件的特性来进行判断。 后者的方式就比较通用简单，简单描述就是将下载未完成的文件放在特定的临时目录，下载完成之后再统一迁移到目标目录，临时目录中的文件也会随之被删除。 我们选择第二种方案，针对iOS的沙盒，temp最适合作为方案中的临时目录。（使用过程中注意NSFileManager的线程安全问题）如此能保证断点续传过程中值操作临时文件，不会影响外部流程中对是否需要发起请求的判断。 最后我们的逻辑是： 待优化点 后台下载 下载文件的校验 Referencehttps://my.oschina.net/snOS/blog/795412 https://blog.csdn.net/u012198553/article/details/53613253 https://github.com/AFNetworking/AFNetworking https://www.jianshu.com/p/01390c7a4957","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"个人所得税知识扫盲","date":"2018-05-05T08:39:58.000Z","path":"2018/05/05/personal-tax/","text":"","tags":[{"name":"社会","slug":"社会","permalink":"http://huyangjie.com//tags/社会/"}]},{"title":"赋予H5以Native的生命 ——《WebView优化》","date":"2018-05-02T10:07:40.000Z","path":"2018/05/02/赋予H5以Native的生命-——《WebView优化》/","text":"本文是从客户端为起点发散到WebView使用过程中的优化点。当前市场上的Native App中WebView使用的情况还是比较多的，像手机QQ，淘宝业务更替快速的产品，使用WebView动态渲染页面是必然的选择(或者说曾经)，然而遵从这个选择就必须承担着它带来的弊病，更确切地说应该是尽可能解决它的弊病。 前言众所周知在移动端使用WebView给人最直观的感觉是慢。造成这个现象的原因是多层次的，不过主要可以归纳为两个方面[2] ： 页面启动时间：打开一个 H5 页面需要做一系列处理，会有一段白屏时间，体验糟糕。 响应流畅度：由于 webkit 的渲染机制，单线程，历史包袱等原因，页面刷新/交互的性能体验不如原生。 在WebView的先天缺陷角度–响应流畅度 大厂给出解决方案： FB 的 React-Native（多称RN） 和 阿里的 Weex。RN和Weex的核心实现跟WebView并没有关系，它们实现的并不是Hybrid App，里面是使用JavaScript引擎执行JS调用原生的组件。 不过它们的理念有一定的差异性 weex react-native Vue.js React write once, run anywhere learn once, write anywhere 这都不是我们今天的主角，今日主场属于WebView，那么我们所面临的问题是： H5页面启动时间 流程分析下图是一个H5页面展示过程中要经历的流程： 简单的页面可能会没有JS请求数据这一个步骤，一般页面在 dom 渲染后能显示雏形，在这之前用户看到的都是白屏，等到下载渲染图片后整个页面才完整显示，打开页面优化就是要减少这个过程的耗时。 优化前端B/S结构模式上对web的优化已经有做得比较极致方法，本文就不再介绍了（作为客户端同学也没有什么经验）这里给一个参考传送门[5]：唯快不破：Web 应用的 13 个优化步骤 比较重要也是优化效果比较显著的是能够熟悉HTTP缓存协议使用，这个需要服务端配合一起优化。 客户端客户端上的H5展示跟传统的web页面有所不同，有优势也更有劣势。相对于PC端的处理器，移动客户端上的CPU性能会有所差距。不过由于客户端的H5是通过WebView内嵌在App中，情况不会像传统web一样，所有的优化都受限在浏览器之下，在客户端我们可以拿到更多的权限，做更深的优化。 缓存（主要针对iOS端，慎读！大片OC代码风格可能引起您的不适）客户端可以拦截所有的网络请求，并自己实现缓存机制。iOS端的Cocoa框架UIWebView提供了客户端层面的缓存策略： 1234567NSURLRequestUseProtocolCachePolicy //缓存策略定义在 web 协议实现中，用于请求特定的URL。是默认的URL缓存策略。NSURLRequestReloadIgnoringLocalCacheData //从服务端获取数据，忽略本地缓存NSURLRequestReloadIgnoringLocalAndRemoteCacheData //源文件注释中写到没有实现NSURLRequestReloadIgnoringCacheData //被NSURLRequestReloadIgnoringLocalCacheData替换了NSURLRequestReturnCacheDataElseLoad //已经存在的缓存数据用于请求返回，不管它的过期日期和已经存在了多久。如果没有请求对应的缓存数据，从数据源读取NSURLRequestReturnCacheDataDontLoad //已经存在的缓存数据用于请求返回，不管它的过期日期和已经存在了多久。如果没有请求对应的缓存数据，不要去数据源读取，该请求被设置为失败，这种情况多用于离线模式NSURLRequestReloadRevalidatingCacheData //源文件中写到没有实现 其中默认缓存策略（最通用）NSURLRequestUseProtocolCachePolicy的流程如下： 其实我们自定义缓存策略，加上更多优化的点，比如自定义缓存的存储方式能够实现离线缓存，又能够实时更新，定义本地缓存失效时间等。 自定义流程的实现在iOS中是通过继承NSURLProtocol拦截处理所有的网络请求来实现的，这是我的一种实现方案：YJURLProtocol 当然GitHub上有很多实现方案，最好是根据自己的需求去自定义。 WKWebView是否支持NSURLProtocol？在使用WKWebView加载网页的时候，NSURLProtocol子类会不能拦截到请求，原因是WKWebView的请求是在单独的进程里，所以不会走NSURLProtocol。当然解决办法是有的，因为其实WKWebView是支持NSURLProtocol协议的，只是还不够完善，当前可以通过调用私有的API去完成这项任务（详细分析过程见参考[6]）,以下是实现的关键代码： 1234567891011121314151617181920212223242526272829303132333435363738394041FOUNDATION_STATIC_INLINE Class ContextControllerClass() &#123; static Class cls; if (!cls) &#123; cls = [[[WKWebView new] valueForKey:@\"browsingContextController\"] class]; &#125; return cls;&#125;FOUNDATION_STATIC_INLINE SEL RegisterSchemeSelector() &#123; return NSSelectorFromString(@\"registerSchemeForCustomProtocol:\");&#125;FOUNDATION_STATIC_INLINE SEL UnregisterSchemeSelector() &#123; return NSSelectorFromString(@\"unregisterSchemeForCustomProtocol:\");&#125;@implementation NSURLProtocol (WebKitSupport)+ (void)wk_registerScheme:(NSString *)scheme &#123; Class cls = ContextControllerClass(); SEL sel = RegisterSchemeSelector(); if ([(id)cls respondsToSelector:sel]) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\" [(id)cls performSelector:sel withObject:scheme];#pragma clang diagnostic pop &#125;&#125;+ (void)wk_unregisterScheme:(NSString *)scheme &#123; Class cls = ContextControllerClass(); SEL sel = UnregisterSchemeSelector(); if ([(id)cls respondsToSelector:sel]) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\" [(id)cls performSelector:sel withObject:scheme];#pragma clang diagnostic pop &#125;&#125;@end 附上解决方案源码：https://github.com/Yeatse/NSURLProtocol-WebKitSupport其中会使用到私有的API，关于使用私有API肯定担心的是能不能通过Apple的审核。摘录一段前百度工程师sunnyxx的描述： 关于私有API大家会质疑说，这用到了 UIKit 的私有属性和私有 API，要是系统升级变了咋办？要是审核被拒了咋办？首先，iOS 系统的 SDK 为了向下兼容，一般只会增加方法或者修改方法实现，不太可能直接删除一个共有方法，而私有方法的行为确实可能有变化，但系统 release 频率毕竟很低，每当新版本发布时 check 下原来的功能是否能 work 就好了，大可不必担心这么远，SDK 是死的人是活的。不论是 kvc 还是 selector 反射，都是利用 objc runtime 完成的，而到了这一层，真的就没啥公有私有可言了。设想你就是开发 Apple 私有 API 检查工具的工程师，给你一个 ipa 的包，你会如何检查出其中有没有私有 API 呢？ 首先，这个检查一定是个静态检查，不可能是运行时检查，因为代码逻辑那么复杂，把程序跑起来看所有 objc_msgSend 中包不包括私有调用这件事太不现实了。对 ipa 文件做静态检查的话肯定是去分析 Mach-O 可执行文件，因为这时很多源代码级别的信息已经丢失，经分析可以采取下面几种手段： 是否 link 了私有 framework 或者公开 framework 中的私有符号，这可以防止开发者把私有 header 都 dump 出来供程序直接调用。同上，使用@selector(_private_sel)加上-performSelector:的方式直接调用私有 API。扫描所有符号，查看是否有继承自私有类，重载私有方法，方法名是否有重合。扫描所有string，看字符串常量段是否出现和私有 API 对应的。我觉得前三条被 catch 住的可能性最高，也最容易被检查出来。再来看我们用到用字符串的方法 kvc 和 反射 selector，应该属于最后一条，这时候就很难抉择了，拿 handleNavigationTransition: 来说，看上去人畜无害啊，我自己类里面的方法也完全可能命名出这个来，所以单单凭借字符串命中私有 API 判定，苹果很容易误伤一大票开发者。综上，我觉得使用字符串的方式使用私有 API 是相对安全的 PS: iOS11之后可以通过WKURLSchemeHandler去完成对WKWebView的请求拦截,不需要再调用私有API解决上述问题了。 上述方案似乎已经完美解决缓存问题，但实际上还有很多问题： 没有预加载：第一次打开的体验很差，所有数据都要从网络请求。 缓存不可控：缓存的存取由系统 webview 控制，无法控制它的缓存逻辑，带来的问题包括： i. 清理逻辑不可控，缓存空间有限，可能缓存几张大图片后，重要的 HTML/JS/CSS 缓存就被清除了。 ii.磁盘 IO 无法控制，无法从磁盘预加载数据到内存。 更新体验差：后台 HTML/JS/CSS 更新时全量下载，数据量大，弱网下载耗时长。 无法防劫持：若 HTML 页面被运营商或其他第三方劫持，将长时间缓存劫持的页面。 还有一个方案就是使用zip包存放HTML文件和资源文件，进行统一管理。 离线H5 zip 包以下是现任职蚂蚁金服的bang提供的一个比较完善的客户端离线包方案： 后端使用构建工具把同一个业务模块相关的页面和资源打包成一个文件，同时对文件加密/签名。 客户端根据配置表，在自定义时机去把离线包拉下来，做解压/解密/校验等工作。 根据配置表，打开某个业务时转接到打开离线包的入口页面。 拦截网络请求，对于离线包已经有的文件，直接读取离线包数据返回，否则走 HTTP 协议缓存逻辑。 离线包更新时，根据版本号后台下发两个版本间的 diff 数据，客户端合并，增量更新。 我在项目中准备实践这个方案，当前只使用了一步，配置业务转接入口+本地zip包解密解压进行加载。 项目使用SSZipArchive对zip包进行解压，放到temporary目录加载资源。解压zip包和迁移文件的工作放在App启动之后的异步线程执行，不会影响App的启动速度。 12345- (void)unZipFile &#123; NSString *zipFile = [[NSBundle mainBundle] pathForResource:@\"dist\" ofType:@\"zip\"]; NSString *destinationPath = [NSURL fileURLWithPath:NSTemporaryDirectory()].path; [SSZipArchive unzipFileAtPath:zipFile toDestination:destinationPath overwrite:YES password:@\"******\" error:nil];&#125; 关于离线包的增量更新方案的参考:实现前端资源增量式更新的一种思路两种增量更新方案 这一块还有很多需要实践的点.. 预加载 webview无论是 iOS 还是 Android，本地 webview 初始化都要不少时间，可以预先初始化好 webview。这里分两种预加载： 首次预加载：在一个进程内首次初始化 webview 与第二次初始化不同，首次会比第二次慢很多。原因预计是 webview 首次初始化后，即使 webview 已经释放，但一些多 webview 共用的全局服务或资源对象仍没有释放，第二次初始化时不需要再生成这些对象从而变快。我们可以在 APP 启动时预先初始化一个 webview 然后释放，这样等用户真正走到 H5 模块去加载 webview时就变快了。 webview 池：可以用两个或多个 webview 重复使用，而不是每次打开 H5 都新建 webview。不过这种方式要解决页面跳转时清空上一个页面，另外若一个 H5 页面上 JS 出现内存泄漏，就影响到其他页面，在 APP 运行期间都无法释放了。 总结WebView层面加载提高性能最大的优化方向还是缓存，预加载，在有限的资源和时间内更合理地调度资源。 Reference [1]. Http缓存 [2]. 移动 H5 首屏秒开优化方案探讨 [3]. WebView性能、体验分析与优化 [4]. 70%以上业务由H5开发，手机QQ Hybrid 的架构如何优化演进？ [5]. 唯快不破：Web 应用的 13 个优化步骤 [6]. 一个完美的半成品-WKWebView","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"CheckBox in React Native","date":"2018-04-05T03:54:23.000Z","path":"2018/04/05/CheckBox-in-RN/","text":"关于RN CheckBox组件在写hello world过程中iOS同学发现CheckBox组件展示不了，但是文档上确确实实是存在这个组件的介绍的，只不过没有demo。 我查了源码的CheckBox实现和发布说明发现以下信息，分享下： CheckBox 这个组件是在 RN v0.49.0版本引入，这是CheckBox的首现版本的说明： https://github.com/facebook/react-native/releases/tag/v0.49.0 可以看到当时只是发布在了Android的新功能列表中 以下是0.49.0版本中关于CheckBox的源码：https://github.com/facebook/react-native/commit/84b11dd5185c017a316510de6ace608dc82321e8 commit 记录中也说明是Android的功能 1234Add Android React Native CheckboxReviewed By: achen1Differential Revision: D5281736fbshipit-source-id: 9a3c93eeace2d80be4ddbd4ffc3258c1d3637480 后来估计很多iOS的同学去使用了CheckBox，毕竟文档中没有特别说明只有Android可以使用(iOS同学使用会报错)。于是在v0.50.0版本的更新说明中，特地对CheckBox添加了注释，并修改文件名，加了Android字样🙃 1../Libraries/Components/CheckBox/CheckBox.js 修改为： 1&apos;../Libraries/Components/CheckBox/CheckBox.android.js&apos;, 并且添加了一个新的文件iOS版本的CheckBox！喜出望外！ 结果iOS的实现如下： 🤔🤔🤔思考人生…🤔🤔🤔 以下是这次（0.50.0）关于CheckBox的commit信息 12345678910111213141516171819202122Use UnimplementedView for CheckBox on iOSSummary:`CheckBox` component was introduced in v0.49.0 and not implemented on iOS.Users who are trying to use `CheckBox` on iOS will get a warning that&gt; Native component for &quot;AndroidCheckBox&quot; does not existWe should declare in the document that this component is Android only and use `UnimplementedView` for iOS.- Use `react-native init` new project- Apply pull request changes- Add `&lt;Checkbox /&gt;` after welcome text in `App.js`- Run the app in iOS simulatorCloses #16211Differential Revision: D6005393Pulled By: hramosfbshipit-source-id: 1c9b68b5e1c933496c4d7c2f487f0500264b603a 提取一下关键字眼： use UnimplementedView for iOS. UnimplementedView是啥？一脸懵X 查源码呗，以下是UnimplementedView.js中的实现 源码地址 12345678910111213141516171819202122232425262728class UnimplementedView extends React.Component&lt;$FlowFixMeProps&gt; &#123; setNativeProps() &#123; // Do nothing. // This method is required in order to use this view as a Touchable* child. // See ensureComponentIsNative.js for more info &#125; render() &#123; // Workaround require cycle from requireNativeComponent const View = require('View'); return ( &lt;View style=&#123;[styles.unimplementedView, this.props.style]&#125;&gt; &#123;this.props.children&#125; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; unimplementedView: __DEV__ ? &#123; alignSelf: 'flex-start', borderColor: 'red', borderWidth: 1, &#125; : &#123;&#125;,&#125;); 可以看到，这个UnimplementedView在DEV模式下会提供1个单位的红框（如果我们使用的时候没有指定style）。 除此之外就是个空的View… 所以iOS的同学要使用类似CheckBox的组件，就自己实现或者找三方法的实现吧。其实，CheckBox的单选功能，对应在iOS上的组件应该是Switch控件喽，多选的话我一般是使用Button实现。 见仁见智，网上也有别人实现的CheckBox，例如今天被我误解为RN自带库的这家伙（谁让他名字这么官方范）：https://www.npmjs.com/package/react-native-checkbox, 不过这Star数也不多哈哈。 之后使用的时候多多尝试吧~","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://huyangjie.com//tags/React-Native/"}]},{"title":"机器学习-统计基础-T检验（2）","date":"2018-02-08T03:09:59.000Z","path":"2018/02/08/机器学习-统计基础-t检验（2）/","text":"t检验的好处是我们不需要知道总体的参数 但是 我们需要知道 样本均值 和 每个样本量以及它们的 标准偏差 stdev是excle中计算标准偏差的函数 计算t统计量 标准误差 计算t统计量 决策使用t临界值来进行跟t统计量进行比较 合并方差（Pooled variance） 校正的标准误差 使用合并方差的时候的前提条件 X和Y应该是来自两个独立总体的随机样本 X和Y来自的总体应该大概是正态的 样本数据可以用来估计总体方差 总体方差应该大概相等，使我能能够将这个合并方差作二者的估计值","tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://huyangjie.com//tags/Machine-Learning/"}]},{"title":"机器学习-统计基础-T检验","date":"2018-02-08T03:09:26.000Z","path":"2018/02/08/机器学习-统计基础-t检验/","text":"概念记录t分布是用自由度来定义自由度（Degrees of freedom） 自由度-选择n个数字: 自由度是n 自由度-添加至10: 有n个数字相加等于10，那自由度就为n-1 自由度-边际总数: （n*n）的表格自由度就有(n-1)*(n-1) 随着自由度的增大，t分布会越来越接近于正态分布 t表格t表显示的是临界值，左边显示的是自由度，右边（顶部）显示的是右尾的面积， 底部的是置信区间t表格 大图点击这里 影响t统计量 将t分布的中心放在 μ0 处，然后看看x拔位于这个分布的那个位置，x拔越靠近两端，更有可能所来自的总体的均值和 μ0 显著不同。 P值P值等于t统计量在红色的区域内的概率 当P值小于α水平时，我们会拒绝零假设 使用GraphPad来找到P值 【疑问】 统计显著性 (statistically significant)根据一般规则，通常α水平等于0.05， 这一差别不具有统计显著性 拒绝零假设，代表具有统计显著性 Cohen’s d以统计学家Jacob Cohen命名 Cohen’s d 是一种效应量度量用来衡量两个均值之间的标准化均值差（以标准偏差为单位）， 除以的是样本标准差 置信区间(x̅-t*S/√n， x̅+t*S/√n） 误差范围t*S/√n 相依样本如果同意受试者参加两次测试，则这两次结果是相依样本。为了衡量这些值之间的差别 Di = xi - yi μQ - μA = μD 相依样本t检验 设计类型10a 31 重复衡量设计(Two conditions) 检验并衡量不同条件下的样本 零假设是指这两个条件下的均值将相同 纵向设计（Growth over time [longitudinal study] ） 在一个时间段衡量某个变量，在晚些时候的某个时间点再衡量同一变量 零假设也是两个总体均值相同，跟重复衡量设计不同的是在衡量变量时中间间隔了很长时间 预期检验和后期检验(pre-test, post-test) 先衡量某个变量，然后进行某种处理，然后在处理之后再对同一样本衡量同一变量，看看处理措施是否导致了显著的效应 零假设是保持不变，即在处理前和处理后改变量没有出现显著的变化 相依样本的优缺点Advantages 控制个体差异性 使用更少的受试者 成本更低 花费时间更少 开支更少 Disadvantages 残留效应（因为控制个体差异性，使个体参与了两次试验，第一次试验可能会影响到第二次的结果） 试验的处理顺序可能会影响到结果 独立样本独立样本的优势就是相依样本的劣势，劣势是相依样本的优势 开展实验性检验对受试者实施处理措施，或开展观察性检验，我们只是观察两组不同总体的特性 效应量在实验性研究中，或存在处理变量的研究中，效应量是指处理效应的大小在非实验性研究中，效应量是指变量之间的关系强度，在z检验或者t检验中，最简单的效应量衡量指标是均值差异 统计显著性（statistically significant）统计显著性知识表示结果可能不是偶然发生的，在解释结果时排除了随机因素或抽样错误 如何判断某个调查研究的结果是否有意义 度量的是什么？ 效应有多大？ 在解释结果时能排除随机因素吗？ 解释结果时能排除潜在变量吗？ r^2r^2表示的是两个变量之间的关系程度也称为确定系数。r^2是一个比例，范围从0到1. 0代表两个变量根本没有关系，1代表两个变量完全相关 这里的t不是临界值，是从t检验中获得的值 报告结果APA Style t检验t(df) = X.XX, p=.XX, directiont值，p值，单尾检验还是双尾检验 置信区间95% CI = （4,6） 效应量d = X.XX, r^2 = .XX t检验公式","tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://huyangjie.com//tags/Machine-Learning/"}]},{"title":"机器学习-统计基础-假设检验","date":"2018-02-08T03:09:08.000Z","path":"2018/02/08/机器学习-统计基础-假设检验/","text":"概念记录α 水平不太可能发生的概率叫做 α 水平 Z临界值 (Z critical value)将临界区和其他区域分开的Z值为 Z的临界值 Z临界值0.001， 这时候在Z表中有跟多个0.9990，需要选择第一个。Z值为正负3.08 临界区如果样本均值处于临界区中，表明我们的样本统计数据与总体参数非常不同，很可能采取了任何形式的认为处理措施 单尾检验单尾检验即方向性假设检验，只关心一个方向上的效应 α = 0.05时，（单尾检验）的Z临界值是多少？ 【1.64】 末端的概率也还是0.025 双尾检验双尾检验通常使用在非方向性检验。 计算双尾临界值0.01， 即每个末端的概率为0.005 假设零假设 &amp; 对立假设 零假设是指干预后的总体和当前总体参数之间没有显著差别 对立假设可以使一下三种情况： 当前总体比干预后的小 当前总体比干预后的大 当前总体和干预后只是不同 拒绝零假设（Reject the null）拒绝零假设，则表明接受对立假设。即存在显著的差距。概率很小，比 α 水平还小就可以拒绝零假设 决策失误H0: 零假设成立 HA： 对立假设成立 I型错误： 我拒绝零假设，其实零假设成立 II型错误： 我认为零假设成立，其实对立假设成立 例子（理解Type I error和 Type II error）： 习题记录临界区域代表当零假设为真时，可能性很低的值。 当样本量较大时，处理效果(若有)更容易被检测到 当标准差较大时，处理效果（若有）更不容易被检测到","tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://huyangjie.com//tags/Machine-Learning/"}]},{"title":"完成一个仪表盘动画的风雨历程","date":"2018-02-08T03:02:33.000Z","path":"2018/02/08/完成一个仪表盘动画的风雨历程/","text":"占位…等待填充","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"},{"name":"动画","slug":"动画","permalink":"http://huyangjie.com//tags/动画/"}]},{"title":"迟到的2017年终总结","date":"2018-02-08T03:01:49.000Z","path":"2018/02/08/迟到的2017年终总结/","text":"占位…等待填充","tags":[{"name":"随笔","slug":"随笔","permalink":"http://huyangjie.com//tags/随笔/"}]},{"title":"机器学习-统计基础-估计","date":"2017-12-13T15:50:02.000Z","path":"2017/12/13/机器学习-统计基础-估计/","text":"概念记录置信区间（Confidence Interval, CI）(x̅-Z*σ/√n， x̅+Z*σ/√n) 称为均值的95%置信区间 样本越大，置信区间越小计算置信区间使用的平均值， 是均值分布中的平均值。并非总体中的均值 人工干预之后的成果一般看置信区间的范围来断定 精确的Z值 使用精确的Z值来计算置信区间 Z的临界值例子：正负数2.33(Z表上的值) 称为98%置信区间的Z的临界值 大概的误差范围（margin of error）Z*sigma / sqrt(n)","tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://huyangjie.com//tags/Machine-Learning/"}]},{"title":"机器学习-统计基础-归一化&正态分布&抽样分布","date":"2017-12-10T03:00:54.000Z","path":"2017/12/10/机器学习-统计基础-归一化-正态分布-抽样分布/","text":"归一化概念记录Z值原始值跟均值之间相差几个标准差 公式 z = (x - μ) / σ可以将数据归一化 标准正态分布平均值为0， 标准差为1 正态分布概念记录概率密度函数（PDF）概率密度函数曲线下的面积是1，因为它是用分布数据的相对频率（比例）来绘制数据模型的 概率密度函数的百分位选中一个X值如果小于等于该值的概率是80%，那么就称X是第80个百分位 概率 Z 表格点击查看大图 在计算的时候需要善于使用技巧，使用正态分布左右对称， 和几个特定的点的概率可以加快计算的速度。 抽样分布概念记录样本均值分布从总体中取出多个样本分别计算出均值的分布 所有样本均值的标准差（SE）（Standard deviation of distribution of Sample means）样本量 n 总体的标准差 sigma σ σ / √n = SE 均值的标准偏差等于总体标准偏差除以样本量的平方根 中心极限定理(The Central Limit Theorern)对于均值分布，其中每个均值都是样本量为n的均值，该分布的标准差就等于总体标准差除以平方根n 抽样分布总是趋近于正态分布抽样分布的均值跟总体的均值相同","tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://huyangjie.com//tags/Machine-Learning/"}]},{"title":"一个48小时的周末","date":"2017-12-03T05:13:33.000Z","path":"2017/12/03/一个48小时的周末/","text":"周末这真是一个让人心情愉悦的词，因为在这段时间内我们可以没有约束地做自己的事（大部分是这样吧🙃）,可以想什么时候睡就什么时候睡，约想约的人逛想逛的地儿，追想追的剧，敲想敲的代码🤥 有人问我你一般周末都做什么的？我可能会回答：睡觉 根据我以往的时间来算，如果周末没有什么户外的安排，那最多的时间肯定是在床上睡觉，而且可以睡到上午十一二点那种😣（罪恶感） 真是浪费！周末这么宝贵的时间怎么可以拿来睡觉呢？！ 这48个小时怎么就变得让人觉得宝贵呢？ 自由周末赋予了我们自由，在这48小时内我们享有完全的时间和精力。这是极大的吸引力！被工作或是学习限制着地域和时间五天之后，一种被释放的快感能让人不由生悦。周末就像在空中即将散开的烟花，有人可以把它过得绚丽多彩、轰轰烈烈，也有人会把烟花渲染成静默、透明。没有普世的美，只有大众认可的形态。 存在意识中有种感觉，周末这48小时其实也是很恐怖的一种存在。它的累加能让同一个阶段的人慢慢产生差别，最后被分离到不同阶段。 我有这种感觉是因为在我看几位技术大牛的博客的时候，发现他们并不是腾空而出（当然这是废话😒），但是成长曲线是非常陡峭的。我翻他们五年前，六年前甚至更早之前的文章，他们也就刚毕业或者还在学校。我尝试把他们当时的文章中的状态的他们立体出来，发现他们大方地对学习花时间，不吝啬贡献给代码的时间和精力。 所以我在翻看他们博客的时候都带着敬仰的心情，是自然而然产生的。看到某一篇文章下面的评论中有朋友问道：“我年纪比你大些，技术道行却跟你差多了，想知道需要怎样的学习规划才能达到你这样的水准？”想必很多人都这样想，我也是，虽然我年纪还没到。技术水平或许有一定的量化标准，但是别人在自己心中的水准却是无法量化，是一直认为遥不可及的等级，还是能被自己的体系触及的等级。博主没有回答那个问题，即使他回答了也不会有多少人能做到他那样。这不是方法的问题，是自我约束力的问题（暂时忽略智商因素，毕竟做这世界上90%的事情还触及不了考验一个人智商的程度） 其实真正恐怖的也不是这48个小时，而是自我的约束力，时间只是一个载体和催化剂。 我会在周末来临之前给自己安排一定量的学习任务，有些时候是定量的，也有更多的时候只是一个念头想法而已。所以我在周末对这些任务的执行力也就不确定。 发掘很大的时间和精力是在这48个小时内没有被合理利用的，当然这里的“合理”因人而定。两天安稳的觉缓解疲劳的精神力，这也是非常值得的。而如果疲劳的精神力状态下反而用周末来做高强度工作或是娱乐，那就与“合理”相差甚远了。 发现，并去挖掘可以被更加合理利用的时间，push自己一波，在时间的容器里累积，相信会得到好的结果的！ 自律给我自由套用下Keep 上的slogan “自律给我自由”，不只是健身，个人成长上能约束自己才能获得正真的自由。 准备试用下同事推荐给我的34枚金币时间管理法把自己的时间量化出来，之后练习机器学习的时候或许也可以用来当做一份素材。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://huyangjie.com//tags/随笔/"}]},{"title":"机器学习-统计基础-差异性","date":"2017-12-02T09:38:08.000Z","path":"2017/12/02/机器学习-统计基础-差异性/","text":"概念记录值域 (Range)最大值和最小值之间的差 统计的时候一般会去除 top 25% 和 bottom 25% 四分位差（IQR）将数据等分为4个部分 Q1: part1 和part2 的分界点 Q2： part2 和 part3的分界点 Q3: part3 和 part4的分界点 IQR = Q3 - Q1 异常值 （Outlier）Outlier &lt; Q1 - 1.5(IQR)Outlier &gt; Q3 + 1.5 (IQR) 箱线图 （Boxplots)Min线和Max线外的点代表异常值 均值不一定在IQR中，众数一定在IQR中 平均偏差 (average deviation)样本中每个值与均值的差 的平均数 平均绝对偏差样本中每个值与均值的差的绝对值 的平均数 平均平方偏差样本中每个值和均值的差的平方 的平均数 标准偏差 （standard deviation）平方差开方之后的值 正态分布中的标准差的作用 贝塞尔校正介于在正态分布的总体抽样统计中，样本多数都处于中心位置，为了数据更加平衡准确，做了贝塞尔校正，获得样本标准差(Sample standard deviation） 两者的使用区别： 如果有样本，并且需要估算总体标准差，那么可以使用“样本标准差”公式（分母为n-1）, 让总体标准差的估算更加准确 如果有一个数据集，并且需要计算该数据集的标准差，那就使用标准差公式","tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://huyangjie.com//tags/Machine-Learning/"}]},{"title":"机器学习-统计基础-数据可视化","date":"2017-11-30T06:38:56.000Z","path":"2017/11/30/机器学习-统计基础-数据可视化/","text":"概念记录直方图的分布下图是正偏斜分布 一共有四种分布方式 正态分布(normal distribution) 偏斜分布(skewed) 双峰分布(bimodal) 均匀分布 (uniform) 正态分布的 均值、中位数、众数都相等 直方图的组距(bin size)直方图每一条的宽度 直方图的横坐标有： Numerical 数值型 Categorical 类别型 众数 （mode）在样本中出现次数最多的数不易收到组距的影响众数是最常见的得分 均值 （mean） □ 分布中的所有分值都影响平均值□ 平均值可用公式来描述□ 同一个总体中的多个样本会有相似的平均值□ 一个样本的平均值可以用来推论其所在的总体□ 如果向数据集中添加一个极值，它的平均值会发生改变 不容易收到组距的影响 中位数 (median)中位数需要去除异常值，然后排序计算公式 不容易受异常值的影响不容易收到组距的影响 excle表格计算平均值","tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://huyangjie.com//tags/Machine-Learning/"}]},{"title":"机器学习-统计基础-研究方法入门","date":"2017-11-27T01:43:20.000Z","path":"2017/11/27/机器学习-统计基础-研究方法入门/","text":"概念记录参数 （parameters）表示总体人数的数字被称为参数 总体参数 μ （population parameters）抽样总体的平均得分叫做总体参数 样本统计量 x̅ （sample statistics）样本的平均值叫做样本统计量 抽样误差 （sampling error）两者之间的差别叫做 抽样误差 样本大小使用 n 来表示 自变量 Independent variable额外变量（潜在变量）Extraneous(lurking) variable因变量 Dependent variable定量变量 Quantitative variable预测变量 Predictor variable 单盲实验实验对象不知道自己是否服用有效药片，但是研究人员知道 双盲实验实验结果出来之前，研究人员和实验对象都不知道服用有效药片的人员 操作定义什么是操作定义： 一种将构造（constructs）转变为我们可衡量的变量的方式 一种用我们衡量它的方式描述变量的方式 当选取了一种度量方法，就有了一种可操作的定义。我们通过这种可操作定义就可以在现实世界中度量构建 潜在变量（Extraneous variables）□ 可为变量之间观察到的关系提供可能的另一种解释□ 是会影响我们衡量的两个或多个变量之间关系的因素□ 在我们做出确定的因果声明之前，必须在试验中加以控制□ 使从观察性研究的数据中确定因果关系变得困难 随机样本□ 以选中概率相同的方式选择个体。□ 以选中一个个体不会影响另一个个体被选中几率的方式选择个体。 在试验中，研究人员操纵 (自) 变量，测量 (因) 变量的变化，然后尝试控制(潜伏)变量。 错题记录 “你每天所走的距离” 这是一个抽象概念！ A construct is a variable that is not directly observable or measurable, and units are at the heart of measurement. What units do you think should be used to measure distance? Some possibilities are miles, kilometers, calories expended, state lines crossed, road signs passed, etc. 单位是度量的核心，没有带单位的概念都可以认为是一个抽象概念，比如“你的年龄” ，年龄可以用年来度量，也可以是表示一个人的心智成熟程度，或者用天来衡量。","tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://huyangjie.com//tags/Machine-Learning/"}]},{"title":"iOS应用性能优化小记","date":"2017-11-25T14:49:44.000Z","path":"2017/11/25/iOS应用性能优化小记/","text":"性能，移动应用最直观的体验就是界面是否流畅。在编程过程中大家或多或少总有遇到过关于提高应用性能的操作，比如简单的“异步线程加载图片”，“圆角绘制优化”，“懒加载视图”，“缓存图片”，“避免日期格式转换”等等，都是在把耗时耗资源的操作分散到其他时机执行，或者避免执行。也就是让UI主线程只执行轻量的任务以保证界面的流畅。而本文要讲的是只能在主线程中执行的动画性能的优化。 动画过程是流畅对最直观的体现，而动画效果对设备的硬件资源有一定的要求。针对现代iOS设备来说，造成应用性能的下降在于资源的过度消耗。这里的“资源”指的是什么呢？ CPU &amp; GPU关于绘图和动画有两种处理的方式：CPU（中央处理器）和GPU（图形处理器）。在现代iOS设备中，都有可以运行不同软件的可编程芯片，但是由于历史原 因，我们可以说CPU所做的工作都在软件层面，而GPU在硬件层面。总的来说，我们可以用软件（使用CPU）做任何事情，但是对于图像处理，通常 用硬件会更快，因为GPU使用图像对高度并行浮点运算做了优化。由于某些原因， 我们想尽可能把屏幕渲染的工作交给硬件去处理。问题在于GPU并没有无限制处理 性能，而且一旦资源用完的话，性能就会开始下降了（即使CPU并没有完全占用） 大多数动画性能优化都是关于智能利用GPU和CPU，使得它们都不会超出负荷。 于是我们首先需要知道Core Animation是如何在这两个处理器之间分配工作的。 一段动画的六个阶段（延伸阅读）其实iOS系统中到处充满着动画，双击Home键出来了应用切换界面、下拉出现通知中心，打开任何App时过程，都是动画在装饰着这些操作。还有在编程的时候，任意的UIView动画都默认包含着Core Animation实现的0.25秒的隐式动画。Core Animation 处在iOS的核心地位。当运行一段动画的时，这个过程会被分离为四个阶段： 布局 - 这是准备你的视图/图层的层级关系，以及设置图层属性（位置，背景 色，边框等等）的阶段 显示 - 这是图层的寄宿图片被绘制的阶段。绘制有可能涉及你的-drawReact: 和 drawLayer:inContext:方法的调用路径。 准备 - 这是Core Animation准备发送动画数据到渲染服务的阶段。这同时也是 Core Animation将要执行一些别的事务例如解码动画过程中将要显示的图片的 时间点。 提交 - 这是最后的阶段，Core Animation打包所有图层和动画属性，然后通过 IPC（内部处理通信）发送到渲染服务进行显示。 上面的阶段只是发生在我们的应用程序内，在动画展示早屏幕上之前还有更多的操作。一旦打包的图层和动画到达渲染服务进程，他们会被反序列化来形 成另一个叫做渲染树的图层树。使用这个树状结 构，渲染服务对动画的每一帧做出如下工作： 对所有的图层属性计算中间值，设置OpenGL几何形状（纹理化的三角形）来执行渲染 在屏幕上渲染可见的三角形 所以一共有6个阶段，最后两个阶段在动画过程中不停地重复。前五个阶段都在软件层面处理（通过CPU），只有最后一个被GPU执行。而且，我们真正能控制的只是前两个阶段，布局和显示。剩下的都由Core Animation框架在内部处理，我们控制不了。不过这并没有什么影响，在布局和显示阶段，我们就可以决定哪些由CPU执行，哪些交给GPU执行。 GPUGPU为一个具体的任务做了优化：它用来采集图片和形状（三角形），运行变 换，应用纹理和混合然后把它们输送到屏幕上。大多数的CALayer的属性都是GPU来绘制的。下面几项操作会降低基于GPU的图层绘制： 太多的几何结构 - 这发生在需要太多的三角板来做变换，以应对处理器的栅格 化的时候。现代iOS设备的图形芯片可以处理几百万个三角板，所以在Core Animation中几何结构并不是GPU的瓶颈所在。但由于图层在显示之前通过IPC发送到渲染服务器的时候（图层实际上是由很多小物体组成的特别重量级的对 象），太多的图层就会引起CPU的瓶颈。这就限制了一次展示的图层个数 重绘 - 主要由重叠的半透明图层引起。GPU的填充比率（用颜色填充像素的比 率）是有限的，所以需要避免重绘（每一帧用相同的像素填充多次）的发生。 在现代iOS设备上，GPU都会应对重绘；即使是iPhone 3GS都可以处理高达 2.5的重绘比率，并任然保持60帧率的渲染（这意味着你可以绘制一个半的整 屏的冗余信息，而不影响性能），并且新设备可以处理更多。 离屏绘制 - 这发生在当不能直接在屏幕上绘制，并且必须绘制到离屏图片的上 下文中的时候。离屏绘制发生在基于CPU或者是GPU的渲染，或者是为离屏图 片分配额外内存，以及切换绘制上下文，这些都会降低GPU性能。对于特定图 层效果的使用，比如圆角，图层遮罩，阴影或者是图层光栅化都会强制Core Animation提前渲染图层的离屏绘制。但这不意味着你需要避免使用这些效 果，只是要明白这会带来性能的负面影响。 过大的图片 - 如果视图绘制超出GPU支持的2048x2048或者4096x4096尺寸的 纹理，就必须要用CPU在图层每次显示之前对图片预处理，同样也会降低性 能。 CPU大多数工作在Core Animation的CPU都发生在动画开始之前。但是他会延迟动画开始的时间，让你的界面看起来会比较迟钝。 以下的CPU操作都会延迟动画的开始时间： 布局计算 - 如果你的视图层级过于复杂，当视图呈现或者修改的时候，计算图 层帧率就会消耗一部分时间。特别是使用iOS6的自动布局机制尤为明显，它应 该是比老版的自动调整逻辑加强了CPU的工作。 视图懒加载 - iOS只会当视图控制器的视图显示到屏幕上时才会加载它。这对 内存使用和程序启动时间很有好处，但是当呈现到屏幕上之前，按下按钮导致 的许多工作都会不能被及时响应。比如控制器从数据库中获取数据，或者视图 从一个nib文件中加载，或者涉及IO的图片显示（见后续“IO相关操作”），都会 比CPU正常操作慢得多。 Core Graphics绘制 - 如果对视图实现了-drawReact:方法，或者 -drawLayer:inContext:方法，那么在绘制任何东西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后， 必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就 会变得十分缓慢，所以在一个对性能十分挑剔的场景下这样做十分不好。 解压图片 - PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸（通常等同 于图片宽 x 长 x 4个字节）。为了节省内存，iOS通常直到真正绘制的时候才去 解码图片（14章“图片IO”会更详细讨论）。根据你加载图片的方式，第一次对 图层内容赋值的时候（直接或者间接使用UIImageView）或者把它绘制到 Core Graphics中，都需要对它解压，这样的话，对于一个较大的图片，都会 占用一定的时间。 当图层被成功打包，发送到渲染服务器之后，CPU仍然要做如下工作：为了显示 屏幕上的图层，Core Animation必须对渲染树种的每个可见图层通过OpenGL循环 转换成纹理三角板。由于GPU并不知晓Core Animation图层的任何结构，所以必须 要由CPU做这些事情。这里CPU涉及的工作和图层个数成正比，所以如果在你的层 级关系中有太多的图层，就会导致CPU没一帧的渲染，即使这些事情不是你的应用程序可控的。 Reference《iOS核心动画》性能调优","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"},{"name":"动画","slug":"动画","permalink":"http://huyangjie.com//tags/动画/"}]},{"title":"一个简易遮罩进度动画","date":"2017-10-29T15:38:51.000Z","path":"2017/10/29/一个简易遮罩进度动画/","text":"需求近期工作需求一个展示任务进度的动画，通过填充现有进度图的方式展示，并且有里程碑的节点需要配合数据进行暂停。好吧，文字讲得我自己都很难理解，来看一下效果吧。 红色的填充为当前的进度，验证登录阶段到导入账单阶段（导入阶段到完成）是有一个里程碑的节点的，所以需要通过数据来控制进度，让红色的进度条暂停在某一个位置等待数据。 方案思考1.动画部分展示一下层次结构，一切一目了然 简单的来讲：其实是有两个进度控制View，分别是灰色和红色，这里称红色的为maskView，灰色为bottomView。 在结构层次图中可以意识到只要让maskView有个位移动画就可以满足我们的需求。注意：这个位移动画并不是UIView层面的动画，单纯移动整个maskView其实是会造成bottomView和maskView图标错位的现象，这并不是想要的效果。正确的是对maskViewlayer的maskLayer层进行动画操作。 实现思路：让maskView的maskLayer初始位置在maskView的frame之外的左侧。动画开始之后让maskLayer慢慢向右移动，达到红色慢慢向右填充的效果。对maskLayer使用的动画可以是CABasicAnimation 或者CAKeyframeAnimation。此demo中使用关键帧动画 CAKeyframeAnimation 关键代码示例：123456//初始化maksView的maskLayer位置 CALayer *maskLayer; = [CALayer layer]; maskLayer.backgroundColor = [[UIColor whiteColor] CGColor]; //任何颜色，用到的只是alpha maskLayer.anchorPoint = CGPointZero; maskLayer.frame = CGRectOffset(self.frame,-CGRectGetWidth(self.frame), 0); self.layer.mask = maskLayer; 123456789101112//开始动画 NSArray *values = @[[NSValue valueWithCGPoint:CGPointMake(-CGRectGetWidth(self.frame), 0)], [NSValue valueWithCGPoint:CGPointMake(0, 0)]]; CGFloat duration = 4.0; CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@\"position\"]; animation.values = values; animation.duration = duration; animation.delegate = self; animation.fillMode = kCAFillModeForwards; animation.removedOnCompletion = NO; [maskLayer addAnimation:animation forKey:@\"MaskAnimation\"]; 2.进度控制部分如果只需要本文刚开始的贴图那样的效果，第一部分已经足够了。 第一部分只是解决了生成动画的问题，使用CAKeyframeAnimation对maskLayer进行关键帧动画是比较常见的做法，如果对CAKeyframeAnimation或者CABasicAnimation使用不熟悉可以参阅《iOS核心动画》缓冲 接下来要完成的是根据数据状态来控制动画，简单梳理了下我们要完成的目标： 状态 动画描述 登录中 红色maskLayer开始向右移动 登录超时 红色maskLayer移动暂停在1，2两个图标之间的进度条间 登录成功 红色maskLayer继续向右移动 导入中 红色maskLayer继续向右移动到2至3部分 导入超时 红色maskLayer移动暂停在2，3两个图标之间的进度条间 导入完成 红色maskLayer继续完成剩下的动画 提前完成 直接从当前的百分比位置快速完成剩下的动画 恢复进度 从任意进度恢复动画 抛开是数据，我们要完成的是以下五点： 设定超时机制 暂停动画 恢复动画 从任意进度值初始化动画 从当前进度值快速完成动画 2.1 设定超时机制这一步其实比较简单 先设定默认的登录超时时间和导入超时时间 12static const CGFloat kGeneralLoginTime = 20.0;static const CGFloat kGeneralImportTime = 30.0; 在视图中创建一个定时器，从动画开始计算经过的时间，与默认的时间判断是否在该状态已经超时。 1234567891011- (void)displayLinkEvent &#123; _currentTime ++; if (_currentTime == kGeneralLoginTime * 60 &amp;&amp; self.status == Logining) &#123; [self waitForVerify]; NSLog(@\"登录超时 %ld\", _currentTime / 60); &#125; else if (_currentTime - _loginSuccessTime == kGeneralImportTime * 60 &amp;&amp; self.status == Importing) &#123; [self waitForImport]; NSLog(@\"导入超时 %ld\", (_currentTime - _loginSuccessTime)/60); &#125; _lastPresentPosition = _maskLayer.presentationLayer.position;&#125; 2.2 暂停动画123456//暂停动画- (void)pauseLayer &#123; CFTimeInterval pausedTime = [_maskLayer convertTime:CACurrentMediaTime() fromLayer:nil]; self.layer.speed = 0.0; self.layer.timeOffset = pausedTime;&#125; 2.3 恢复动画123456789//恢复动画- (void)resumeLayer &#123; CFTimeInterval pausedTime = [self.layer timeOffset]; self.layer.speed = 1.0; self.layer.timeOffset = 0.0; self.layer.beginTime = 0.0; CFTimeInterval timeSincePause = [_maskLayer convertTime:CACurrentMediaTime() fromLayer:nil] - pausedTime; self.layer.beginTime = timeSincePause;&#125; 2.4 从任意进度值初始化123456789//设置一个startVlaue的初始化值- (void)setStartValue:(CGFloat)startValue &#123; [self stopAnimation]; _startValue = startValue; //_lastPresentPosition为maskLayer上一次展示position属性 _lastPresentPosition = CGPointMake(startValue * CGRectGetWidth(self.frame) - CGRectGetWidth(self.frame), 0); [self resumeLayer]; [self startAnimation];&#125; 12345678910111213141516//从上一次动画- (void)startAnimation &#123; NSArray *values = @[[NSValue valueWithCGPoint:_lastPresentPosition], [NSValue valueWithCGPoint:CGPointMake(0, 0)]]; CGFloat duration = kGeneralLoginTime + kGeneralImportTime + 1; CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@\"position\"]; animation.values = values; animation.duration = duration; animation.delegate = self; //自然导入完成之后不保留mask层的位置信息，回归到初始位置 animation.fillMode = kCAFillModeRemoved; animation.removedOnCompletion = YES; [_maskLayer addAnimation:animation forKey:@\"MaskAnimation\"]; _displayLink.paused = NO;&#125; 2.5 从当前进度值快速完成动画1234567891011121314151617// 提前结束动画- (void)animationAdvancedFinished&#123; [self resumeLayer]; CGFloat duration = _advancedFinishDuring; NSArray *values = @[[NSValue valueWithCGPoint:_lastPresentPosition], [NSValue valueWithCGPoint:CGPointMake(0, 0)]]; CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@\"position\"]; animation.values = values; animation.duration = duration; animation.delegate = self; //提前结束动画完成之后保留mask层的位置信息，保持动画完成时的样式 animation.fillMode = kCAFillModeForwards; animation.removedOnCompletion = NO; [_maskLayer addAnimation:animation forKey:@\"AdvancedMaskAnimation\"];&#125; 上面代码片段中的_advancedFinishDuring动画时间，是根据触发快速完成动画时的进度值百分比 乘以 快速完成动画所需要的总时间计算出来的。下面是计算的一个例子： 123456789- (void)verifySuccess &#123; [self resumeLayer]; self.status = Importing; self.displayLink.paused = NO; if (!self.loginSuccessTime) &#123; self.loginSuccessTime = self.currentTime; &#125; self.advancedFinishDuring = ((-_lastPresentPosition.x) / CGRectGetWidth(self.frame)) * kGeneralCacheCompleteTime;&#125; 至此进度控制就可以的需求就可以使用以上的关键方法完成了, 查看完成的逻辑可以下载demo查看 Demo地址 不足 进度控制部分的超时跟maskLayer位置的对应关系比较生硬 个人对动画理解还不深，代码笨拙。还请朋友多批评指教！","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"1024","date":"2017-10-24T16:31:43.000Z","path":"2017/10/25/1024/","text":"1024“程序员节日”刚过，在10.24这个节日中，在公司加班终于打包提审了几经周折的App，现在就企盼能够顺利地通过审核吧。接手项目两个多月，到现在正式地提审，也是时候对自己这个阶段的状态做一个总结和分析。 初谙世事这两个月，我才开始真切地认识到程序员这个行业，也开始体会到同事之间的战友情。 初心不管环境怎么改变，保持自己的状态。成长，不忘自己的初心。 自律的自由自由的世界充满的不自由的个体，自我的束缚是无形的。对一个习惯的坚持，对目标的执着是前往自由的🔑。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://huyangjie.com//tags/随笔/"}]},{"title":"iOS动画缓冲","date":"2017-10-09T15:28:26.000Z","path":"2017/10/09/iOS动画缓冲/","text":"Core Animation内嵌了一系列标准函数来模拟物体在运动中的加速和减速。CAMediaTimingFunction设置缓冲方程式首先需要设置CAAnimation的timingFunction属性，是CAMediaTimingFunction类的一个对象。CAMediaTimingFunction的工厂方法：+timingFunctionWithName: 的参数常量如下： 123456789kCAMediaTimingFunctionLinear kCAMediaTimingFunctionEaseIn kCAMediaTimingFunctionEaseOut kCAMediaTimingFunctionEaseInEaseOutkCAMediaTimingFunctionDefault kCAMediaTimingFunctionLinear（线性计时函数） 是 CAAnimation 的 timingFunction 属性的默认函数。 kCAMediaTimingFunctionEaseIn 常量创建了一个慢慢加速然后突然停止的方法。 kCAMediaTimingFunctionEaseOut 则恰恰相反，它以一个全速开始，然后慢慢减速停止。 kCAMediaTimingFunctionEaseInEaseOut 创建了一个慢慢加速然后再慢慢减速的过程。 最后还有一个 kCAMediaTimingFunctionDefault ，它和 kCAMediaTimingFunctionEaseInEaseOut 很类似，但是加速和减速的过程都稍微有些慢。 当创建显式的CAAnimation，kCAMediaTimingFunctionDefault并不是默认选项 在UIView的动画中，kCAMediaTimingFunctionEaseInEaseOut 相对应的常量是默认效果 缓冲和关键帧动画CAKeyframeAnimation有一个NSArray类型的timingFunctions属性，我们可以用它来对每次动画的步骤指定不同的计时函数。但是指定函数的个数一定要等于keyframes数组的元素个数减一，因为它是描述每一帧之间动画速度的函数。 1234567891011121314151617- (IBAction)changeColor&#123; //create a keyframe animation CAKeyframeAnimation *animation = [CAKeyframeAnimation animation]; animation.keyPath = @\"backgroundColor\"; animation.duration = 2.0; animation.values = @[ (__bridge id)[UIColor blueColor].CGColor, (__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor greenColor].CGColor, (__bridge id)[UIColor blueColor].CGColor ]; //add timing function CAMediaTimingFunction *fn = [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn]; animation.timingFunctions = @[fn, fn, fn]; //apply animation to layer [self.colorLayer addAnimation:animation forKey:nil];&#125; Reference《iOS核心动画》章节 缓冲","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"被思绪戳穿的国庆","date":"2017-10-06T06:03:31.000Z","path":"2017/10/06/被思绪戳穿的国庆/","text":"我一直觉得自己是一个对过去记忆很不敏感的人，写这段文字的时候在回想着往年的国庆在哪。粗粗一想有印象地只有大二的时候跟两个同学一起骑车去穷游的经历。 我现在不太喜欢旅游，没有向往哪里特别想去某个地方旅游的想法。今年的国庆长假，有几个老友相约出游，却也提不起兴趣，之后相互也没有再响应出游计划也就不了了之，最后相互一句 “下次” 一溜而过。 曾曾经也是向往过一群朋友出游，还有跟女朋友一起旅游。现在没有了向往，遇到一次出游的机会我甚至会评估好久这样的一段旅行有什么意义。多数都激不起我心中的波澜，因为几次曾经的经历让我的心境不再为它们所颤动。曾经听一个人说理性的自己和感性的自己这样的概念，这两个自己做出来的决定是截然不同的，没有波澜的自己当然都是理性的。冷淡的日子安静的自己，宁愿回家待7天。 十年十年 这个词，对我来说曾一直是很庞大的量级，这次竟被我爸轻易地用在了我身上。以往听到这个词后面跟的话，都不在我的记忆范围内，但是这回…十年前的那些我都历历在目。只记得几年前，却不曾想已经是十年前。 变听说我回家之前几个表妹已经回来过又走了，而且还是抱着自己刚出生的孩子来的。堂弟也带着的他女朋友跟他妈妈正打麻将。我姐姐的双胞胎这个月底也要出生了。我？ 我现在一头黄发，满嘴胡渣。一直默默地耕耘着自己的未来，一回头发现周围的未来已来。当然也有不变得，经过10多年，乡下的样貌倒改变不是很大，还是有儿时的感觉。 寂在家我选择了电脑，历年长此以往。我不知道在成长过程中，电脑是不是对性格的养成有助攻。它给了逃避的港湾？我只是觉得它更有意义。我给人的印象就跟电脑关联在了一起。出去玩，我也可以玩得很好。但往往不想，或许用一个字概括 “宅” ？ 结看了两天的《权利的游戏》，准备开始代码一波。然后整理思绪，继续耕耘我的世界。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://huyangjie.com//tags/随笔/"}]},{"title":"iOS隐式动画","date":"2017-07-19T01:08:59.000Z","path":"2017/07/19/iOS隐式动画/","text":"先来一段引用改变下对动画的世界观： Core Animation基于一个假设，说屏幕上的任何东西都可以（或者可能）做动画。 动画并不需要你在Core Animation中手动打开，相反需要明确地关闭，否则他会一直存在。 123456CGFloat red = arc4random() / (CGFloat)INT_MAX; CGFloat green = arc4random() / (CGFloat)INT_MAX; CGFloat blue = arc4random() / (CGFloat)INT_MAX; self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor; 上面这样的一段代码，没有设置任何动画，但是在运行的时候会发现颜色的变化并不是突变的，有一定的动画效果。这个动画怎么实现的，时间又是多少呢？ 这得先从事务说起。 事务是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，而是当事务一旦提交的时候开始用一个动画过渡到新值。 事务通过 CATransaction 类来做管理，使用+begin和+commit来入栈和出栈。 Core Animation在每个run loop周期中自动开始一次新的事务，即使不显式的调用[CATransaction begin] 开始一次事务，任何在一次run loop循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。 关闭隐式动画Core Animation通常对CALayer的所有属性（可动画的属性）做动画，但是UIView把它关联的图层的这个特性关闭了。 我们把改变属性时CALayer自动应用的动画称作行为，当CALayer的属性被修改时候，它会调用-actionForKey:方法，传递属性的名称。具体看看是隐式动画的实现步骤： 这是CALayer头文件里对actionForKey:方法调用的描述 1234567891011121314/* Returns the action object associated with the event named by the * string &apos;event&apos;. The default implementation searches for an action * object in the following places: * * 1. if defined, call the delegate method -actionForLayer:forKey: * 2. look in the layer&apos;s `actions&apos; dictionary * 3. look in any `actions&apos; dictionaries in the `style&apos; hierarchy * 4. call +defaultActionForKey: on the layer&apos;s class * * If any of these steps results in a non-nil action object, the * following steps are ignored. If the final result is an instance of * NSNull, it is converted to `nil&apos;. */- (nullable id&lt;CAAction&gt;)actionForKey:(NSString *)event; 图层首先检测它是否有委托，并且是否实现CALayerDelegate协议指定的-actionForLayer:forKey方法。如果有，直接调用并返回结果。 如果没有委托，或者委托没有实现-actionForLayer:forKey方法，图层接着检查包含属性名称对应行为映射的actions字典。 如果actions字典没有包含对应的属性，那么图层接着在它的style字典接着搜索属性名。 最后，如果在style里面也找不到对应的行为，那么图层将会直接调用定义了每个属性的标准行为的-defaultActionForKey:方法。 所以一轮完整的搜索结束之后，-actionForKey:要么返回空（这种情况下将不会有动画发生），要么是CAAction协议对应的对象，最后CALayer拿这个结果去对先前和当前的值做动画。 这就解释了UIKit是如何禁用隐式动画的：每个UIView对它关联的图层都扮演了一个委托，并且提供了-actionForLayer:forKey的实现方法。当不在一个动画块的实现中，UIView对所有图层行为返回nil，但是在动画block范围之内，它就返回了一个非空值。 ps : [CATransaction begin]之后添加下面的代码，同样也会阻止动画的发生： [CATransaction setDisableActions:YES]; 关联图层设置动画 UIView关联的图层禁用了隐式动画，对这种图层做动画的唯一办法就是使用UIView的动画函数（而不是依赖CATransaction），或者继承UIView，并覆盖-actionForLayer:forKey:方法，或者直接创建一个显式动画（等待下一篇笔记）。 对于单独存在的图层，我们可以通过实现图层的-actionForLayer:forKey:委托方法，或者提供一个actions字典来控制隐式动画。 自定义行为行为通常是一个被Core Animation隐式调用的显式动画。 我们来对颜色渐变的代码（文章顶部）使用一个不同的行为，通过给colorLayer设置一个自定义的actions字典。我们也可以使用委托来实现，但是actions字典可以写更少的代码。 PS: CATransition响应CAAction协议，并且可以当做一个图层行为 12345//add a custom action CATransition *transition = [CATransition animation]; transition.type = kCATransitionPush; transition.subtype = kCATransitionFromLeft; self.colorLayer.actions = @&#123;@\"backgroundColor\": transition&#125;; 在初始化的时候给layer添加了这样的行为之后，就可以对隐式动画添加了一个 推进过度 的效果 ReferenceiOS Core Animation 十分感谢译者","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"Hi！CALayer我们聊聊","date":"2017-07-17T07:39:59.000Z","path":"2017/07/17/Hi！CALayer我们聊聊/","text":"CALayer和UIView最大的不同就是，CALayer不处理用户交互。因为它并不清楚具体的响应链。 1. iOS 和 MacOS 的坐标系统 点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称 作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一 个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备 和普通设备上能有一致的视觉效果。 像素 —— 物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。 UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层 的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备 上，他们表现出来了不同的大小。 单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的 度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种 纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。 2. CALayer层的简单使用：2.1 给UIView设置寄宿图片12345//设置图片layer.contents = (__bridge id)image.CGImage;//设置图片的展示模式layer.contentsGravity = kCAGravityResizeAspect; contentsGravity的可选常量： 123456789101112kCAGravityCenter kCAGravityTop kCAGravityBottom kCAGravityLeft kCAGravityRight kCAGravityTopLeft kCAGravityTopRight kCAGravityBottomLeft kCAGravityBottomRight kCAGravityResize kCAGravityResizeAspect kCAGravityResizeAspectFill 将contentsScale设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕。(前提是contentsGravity没有被设置)，视图层UIView有一个类似的属性contentScaleFactor 当用代码的方式来处理寄宿图的时候，一定要记住要手动的设置图层 的 contentsScale 属性，否则，你的图片在Retina设备上就显示得不正确啦。 1layer.contentsScale = [UIScreen mainScreen].scale; 2.2 使用contentsRect实现image sprites（图片拼合）主要思想：载入一张包含很多小图的大图，然后通过contentsRect将大图中的小图分别展示到不同的视图层中。 优点：图片的载入会更加快，提高了载入性能 contentsRect的{0, 0, 0.5, 0.5}效果 1234567891011121314- (void)viewDidLoad &#123; [super viewDidLoad]; //load sprite sheet UIImage *image = [UIImage imageNamed:@&quot;Sprites.png&quot;]; //set igloo sprite [self addSpriteImage:image withContentRect:CGRectMake(0, 0, 0.5, 0.5) toLayer:self.iglooView.layer]; //set cone sprite [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0, 0.5, 0.5) toLayer:self.coneView.layer]; //set anchor sprite [self addSpriteImage:image withContentRect:CGRectMake(0, 0.5, 0.5, 0.5) toLayer:self.anchorView.layer]; //set spaceship sprite [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0.5, 0.5, 0.5) toLayer:self.shipView.layer];&#125; 2.3 使用contentsCenter调整可拉伸区域的大小contentsCenter 其实是一个CGRect，它定义了一个固定的边框和一个在图 层上可拉伸的区域。 除此之外还可以用IB来控制contentsCenter属性。 在视图的第四个检查器中，有一个stretching属性，简直不要太赞👍 Reference《iOS 核心动画》 感谢译者的付出！👍","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"自定义NSURLProtocol实现UIWebView缓存机制","date":"2017-07-14T02:08:43.000Z","path":"2017/07/14/自定义NSURLProtocol实现UIWebView缓存机制/","text":"近期正在研究UIWebView加载网页的缓存的实现，比较常见的是使用自定义的NSURLProtocol进行拦截处理。根据网上的资料，结合试验和自己的理解做个记录。 介绍介绍下我产出的YJURLProtocol完成的功能 功能 支持 说明 缓存数据 是 将整个request缓存下来，以及其response 设置过期时间 是 默认为两天过期，过期后请求会删除原有缓存 自动更新缓存 是 间隔时间超过1min的请求，加载页面后异步更新缓存 UIWebView缓存使用机制： 两个相同的请求时间相隔在60s之内，直接使用缓存，不进行异步更新缓存 两个相同的请求相隔60s+但是没有过期，使用缓存加载页面后，1min后进行异步更新缓存并刷新页面 缓存命中但是时间已经是两天前，则删除缓存走网络数据 NSURLProtocol什么是NSURLPrototol （NSURLProtocol什么的我都懂，我要直接看🌰）Apple的URL Loading System的核心是NSURL类，NSURL提供给app要访问资源的地址，NSURLRequest对象再额外添加HTTP headers， body之类的信息，然后URL Loading System提供NSURLSession和NSURLConnection的各种子类方法去执行这个请求。 请求返回的数据会有两分部分，metadata 和 data。metadata被包括在NSURLResponse对象中，它会提供MIME type，和 text encoding。 data的数据是NSData类型。 在以上过程之后，URL Loading System通过NSURLRequest下载了信息之后，它将会创建一个NSURLProtocol子类的对象。 Note: Remember that Objective-C doesn’t actually have abstract classes as a first class citizen. It’s only by definition and documentation that a class is marked as abstract. 千万不能直接实例化NSURLProtocol, 必须要继承NSURLProtocol,在子类中创建NSURLResponse处理response。 使用NSURLProtocol能做什么 为网络请求提供自定义的Response 可以在网络调试的时候，发起网络请求后进行自定义返回数据调试自己的APP 调过网络请求，加载本地数据 某些情况下，发起的请求并没有去请求网络的必要，可以修改使用本地的数据。（自定义webView的缓存就是如此实现） 重定向网络请求 可以将请求重定向到某个代理服务器，不需要通过iOS给用户弹出授权窗口 修改Request的User-agent 如果你的一个页面是分不同的设备返回数据的，那么可以在这里设置自定的user-agent，来达到你的需求。 使用自己的网络协议 可以替换使用自己实现的网络协议，比如有些建立在UDP之上的协议。 NSURLProtocol的使用1[NSURLProtocol registerClass:[JakeyURLProtocol class]]; 以上代码表示，你已经向URL Loading System注册了自己的NSURLProtocol子类，这个子类将有机会处理每一个发送到URL Loading System的请求。 在NSURLProtocol的子类实现文件中：123+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123; return YES;&#125; 重载以上代码，返回YES。表示此子类注册之后将使用此子类处理所有的请求，返回NO则仍然使用URL Loading System的默认protocol处理请求。 1234567891011121314151617181920//这是个抽象方法，子类必须提供实现方法。此方法可用于修改request，添加一个header等+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request &#123; return request;&#125;//用于判断你的自定义reqeust是否相同，这里返回默认实现即可。它的主要应用场景是某些直接使用缓存而非再次请求网络的地方。+ (BOOL)requestIsCacheEquivalent:(NSURLRequest *)a toRequest:(NSURLRequest *)b &#123; return [super requestIsCacheEquivalent:a toRequest:b];&#125;//开始请求- (void)startLoading &#123; self.connection = [NSURLConnection connectionWithRequest:self.request delegate:self];&#125;//请求结束- (void)stopLoading &#123; [self.connection cancel]; self.connection = nil;&#125; 自定义NSURLProtocol实现UIWebView缓存机制开始请求之后，将此请求标记为已处理 12345- (void)startLoading &#123; NSMutableURLRequest *newRequest = [self.request mutableCopy]; [NSURLProtocol setProperty:@YES forKey:kHandledKey inRequest:newRequest]; self.connection = [NSURLConnection connectionWithRequest:newRequest delegate:self];&#125; 判断请求是否已经被处理过，避免循环被处理 12345678910+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123; NSString *scheme = request.URL.scheme; if ([scheme caseInsensitiveCompare:@\"http\"]==NSOrderedSame||[scheme caseInsensitiveCompare:@\"https\"]==NSOrderedSame) &#123; if ([NSURLProtocol propertyForKey:kHandledKey inRequest:request]) &#123; return NO; &#125; return YES; &#125; return NO;&#125; 自定义YJCacheResponse对象，内容包含内容如下代码 123456789101112131415161718192021@interface YJCachedResponse : NSObject@property (nonatomic, strong) NSData *data;@property (nonatomic, strong) NSString *url;@property (nonatomic, strong) NSString *mimeType;@property (nonatomic, strong) NSString *encoding;@property (nonatomic, strong, readonly) NSURLResponse *response;/** 初始化封装的YJResponse对象 @param data 请求结果数据 @param response @param timeInterval 缓存过期时间 @return 封装的YJResponse对象 */- (instancetype)initWithData:(NSData *)data response:(NSURLResponse *)response limiteTime:(NSTimeInterval)timeInterval;//检查缓存是否过期 0 ：已过期 , 1 ： 需更新缓存, 2 ：无需更新缓存- (CacheStatus)isCacheEffective;@end 在开始请求- (void)startLoading方法中，判断是走缓存还是使用网络请求数据 12345678910111213141516171819202122232425262728- (void)startLoading &#123; NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; self.cachedFilePath = [docPath stringByAppendingPathComponent:md5(self.request.URL.absoluteString)]; //在缓存表中获取当前request是否有缓存 YJCachedResponse *cachedResponse = [self cachedResponseForCurrentRequest]; if (cachedResponse) &#123; switch ([cachedResponse isCacheEffective]) &#123; case OutOfDate: [self useNetData]; break; case UpdateNeedLess: [self useCacheData:cachedResponse]; break; case UpdateNeeded: [self useCacheData:cachedResponse]; //1秒钟之后重新请求，更新缓存 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [self useNetData]; &#125;); break; default: break; &#125; &#125; else &#123; [self useNetData]; &#125;&#125; 在NSURLConnectionDelegate方法中进行Response保存和赋值 1234567891011121314151617- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &#123; [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed]; self.response = response; self.mutableData = [[NSMutableData alloc] init];&#125;- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123; [self.client URLProtocol:self didLoadData:data]; [self.mutableData appendData:data];&#125;- (void)connectionDidFinishLoading:(NSURLConnection *)connection &#123; [self.client URLProtocolDidFinishLoading:self]; [self saveCachedResponse];&#125; 以上只列出部分关键逻辑代码，详细实现请下载demo查看源码问题缺陷 一个网站会有些网络请求地址跟时间戳或者其他随机字符相关，缓存机制会缓存下来，并且之后一直没有机会命中它们，没有办法自动删除这些缓存，会造成内存浪费。 因本人水平有限，文中有什么不正确之处，还请指出，不胜感谢！ Referencehttps://www.raywenderlich.com/59982/nsurlprotocol-tutorial","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"小程序视图层","date":"2017-06-03T09:56:31.000Z","path":"2017/06/03/小程序视图层/","text":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://huyangjie.com//tags/JavaScript/"}]},{"title":"小程序逻辑层","date":"2017-06-03T08:51:50.000Z","path":"2017/06/03/小程序逻辑层/","text":"注册小程序前台、后台定义： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。 关闭小程序(公共库版本1.1.0开始支持)： 当用户从扫一扫、转发等入口(场景值为1007, 1008, 1011, 1025)进入小程序，且没有置顶小程序的情况下退出，小程序会被销毁。 在onLaunch和onShow方法中可以获得的参数： 注意： App() 必须在 app.js 中注册，且不能注册多个。 不要在定义于 App() 内的函数中调用 getApp() ，使用 this 就可以拿到 app 实例。 不要在 onLaunch 的时候调用 getCurrentPages()，此时 page 还没有生成。 通过 getApp() 获取实例之后，不要私自调用生命周期函数。 注册页面生命周期函数 onLoad: 页面加载 一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。 onShow: 页面显示 每次打开页面都会调用一次。 onReady: 页面初次渲染完成 一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。 对界面的设置如wx.setNavigationBarTitle请在onReady之后设置。详见生命周期 onHide: 页面隐藏 当navigateTo或底部tab切换时调用。 onUnload: 页面卸载 当redirectTo或navigateBack的时候调用。 onShareAppMessage转发小程序时需要添加的自定义转字段： 12345678Page(&#123; onShareAppMessage: function () &#123; return &#123; title: '自定义转发标题', path: '/page/user?id=123' &#125; &#125;&#125;) 事件处理函数123&lt;!--index.wxml--&gt;&lt;view&gt;&#123;&#123;text&#125;&#125;&lt;/view&gt;&lt;button bindtap=&quot;changeText&quot;&gt; Change normal data &lt;/button&gt; 12345678910Page(&#123; data: &#123; text: 'init data', &#125;, changeText: function() &#123; // this.data.text = 'changed data' // bad, it can not work this.setData(&#123; text: 'changed data' &#125;) &#125; Tips 直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致 单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。 下图为page实例的生命周期： 路由小程序的页面用栈的形式进行维护管理，大致与iOS相似。 路由方式 API 页面栈表现 初始化 新页面入栈 打开新页面 wx.navigateTo 新页面入栈 页面重定向 wx.redirectTo 当前页面出栈，新页面入栈 页面返回 wx.navigateBack 页面不断出栈，直到目标返回页，新页面入栈 Tab 切换 wx.switchTab 页面全部出栈，只留下新的 Tab 页面 重加载 wx.reLaunch 页面全部出栈，只留下新的页面 页面重定向在iOS的UINavigation中没有对应。 tab切换在小程序里竟然是页面全部出栈，留下最新的tab页。我在iOS中的处理一般是，每个tab页拥有自己的Navigation，切换tab就切换当先使用的Navigation。系统底层的实现应该也是不是小程序这样，等待去研究下回来跟新这里吧 重加载，这一项有点疑惑。当我在比较深层的页面刷新重加载一下，整个栈里就只剩下当前页面了？！那程序的层次结构怎么办，还是说回到了首页，这体验很糟糕啊。 Tips: navigateTo, redirectTo 只能打开非 tabBar 页面。 switchTab 只能打开 tabBar 页面。 reLaunch 可以打开任意页面。 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。 调用页面路由带的参数可以在目标页面的onLoad中获取。 模块化将公共的代码抽离出来，放到一个单独的js文件中作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。 12345// common.jsfunction sayHello(name) &#123; console.log(`Hello $&#123;name&#125; !`)&#125;module.exports.sayHello = sayHello 在调用的时候使用require(path)把需要的代码引入 123456var common = require('common.js')Page(&#123; helloMINA: function() &#123; common.sayHello('MINA') &#125;,&#125;) 参考微信小程序文档","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://huyangjie.com//tags/JavaScript/"}]},{"title":"微信小程序初识","date":"2017-06-03T06:20:19.000Z","path":"2017/06/03/微信小程序初识/","text":"开始了解小程序啦，近期要准备修改一个小程序，添加两个自定义的功能，记录下学习过程中的体会。 目录初始小程序最关键也是必不可少的是 app.js、app.json、app.wxss 这三个。其中，.js后缀的是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件。 app.jsapp.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API。 app.jsonapp.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口\b背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。 下面是一个包含所有配置项的app.json文件 1234567891011121314151617181920212223&#123; \"pages\": [ \"pages/index/index\", \"pages/logs/index\" ], \"window\": &#123; \"navigationBarTitleText\": \"Demo\" &#125;, \"tabBar\": &#123; \"list\": [&#123; \"pagePath\": \"pages/index/index\", \"text\": \"首页\" &#125;, &#123; \"pagePath\": \"pages/logs/logs\", \"text\": \"日志\" &#125;] &#125;, \"networkTimeout\": &#123; \"request\": 10000, \"downloadFile\": 10000 &#125;, \"debug\": true&#125; pagespages中为所有的页面，第一项为小程序的初始页面 window12345678910&#123; \"window\":&#123; \"navigationBarBackgroundColor\": \"#ffffff\", //导航栏背景色 \"navigationBarTextStyle\": \"black\", //导航栏标题颜色，仅支持 black/white \"navigationBarTitleText\": \"微信接口功能演示\", //导航栏标题文字内容 \"backgroundColor\": \"#eeeeee\", //窗口背景色 \"backgroundTextStyle\": \"light\", //下拉背景字体、loading 图的样式，仅支持 dark/light \"enablePullDownRefresh\": \"true\" //是否开启下拉刷新 &#125;&#125; tabbarTip： 当设置 position 为 top 时，将不会显示 icon tabBar 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。 12345678910111213141516\"tabBar\": &#123; \"color\": \"#F8F8F8\", //tab上文字默认颜色 \"selectedColor\": \"#ffffff\", //tab上文字选择后的颜色 \"backgroundColor\": \"#ffffff\", //tab的背景色 \"borderStyle\": \"black\", //（非必填）tabbar上边框的颜色， 仅支持 black/white \"position\": \"top\", //（非必填） bottom、top(默认为top) \"list\": [&#123; \"pagePath\": \"pages/index/index\", \"text\": \"首页\", \"iconPath\": \"\", //（非必填）图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效 \"selectedIconPath\": \"\" //（非必填）选择后的图片路径 ，同上 &#125;, &#123; \"pagePath\": \"pages/logs/logs\", \"text\": \"日志\" &#125;] &#125;, networkTimeout 属性 类型 必填 说明 request Number 否 wx.request的超时时间，单位毫秒，默认为：60000 connectSocket Number 否 wx.connectSocket的超时时间，单位毫秒，默认为：60000 uploadFile Number 否 wx.uploadFile的超时时间，单位毫秒，默认为：60000 downloadFile Number 否 wx.downloadFile的超时时间，单位毫秒，默认为：60000 app.wxssapp.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。 页面小程序的每个页面都有自己所属的 .js .json .wxss文件还有 .wxml文件，前面三者同全局的文件作用相同，只是在这个页面它们的优先级会更高，比如page自己的样式会覆盖全局的样式。.wxml文件是这个页面的布局文件。 每个页面的这四个后缀的文件，小程序要求要有相同的路径的文件名。 某个页面的page.json文件中会覆盖跟app.json相同的配置，只能设置window相关的配置。 属性 类型 默认值 描述 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如”#000000” navigationBarTextStyle String white 导航栏标题颜色，仅支持 black/white navigationBarTitleText String 导航栏标题文字内容 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle String dark 下拉背景字体、loading 图的样式，仅支持 dark/light enablePullDownRefresh Boolean false 是否开启下拉刷新，详见页面相关事件处理函数。 disableScroll Boolean false 设置为 true 则页面整体不能上下滚动；只在 page.json 中有效，无法在 app.json 中设置该项 1234567&#123; \"navigationBarBackgroundColor\": \"#ffffff\", \"navigationBarTextStyle\": \"black\", \"navigationBarTitleText\": \"微信接口功能演示\", \"backgroundColor\": \"#eeeeee\", \"backgroundTextStyle\": \"light\"&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://huyangjie.com//tags/JavaScript/"}]},{"title":"Apple Debugging---使用LLDB替换方法为自定义的block","date":"2017-05-25T14:26:02.000Z","path":"2017/05/25/Apple-debugging-使用LLDB替换方法为自定义的block/","text":"Swizzling with block injection要在lldb中使用Objective-C的runtime，可以通过导入头文件来获得运行时的各种黑色科技。 po @import Foundation 在控制台输入po （lldb) po Enter expressions, then terminate with an empty line to evaluate: 1: 然后可输入多行代码，就像在Xcode中写代码一样。在编写完毕后，回车空一行，再回车代码就会被执行了。下面是一个例子： 1: @import Cocoa; 2: id $class = [NSObject class]; 3: SEL $sel = @selector(init); 4: void *$method = (void *)class_getInstanceMethod($class , $sel); 5: IMP $oldImp = (IMP)method_getImplementation($method); id (^$block)(id) = ^id(id object) { if ((BOOL)[object isKindOfClass:[NSView class]]) { fprintf(stderr, &quot;%s\\n&quot;, (char *)[[[object class] description] UTF8String]); } return object; } IMP $newImp = (IMP)imp_implementationWithBlock($block); method_setImplementation($method, $newImp); 至此，NSObject的init方法就被替换为了上述代码中的block，LLDB中有一个bug，在block中执行IMPS就会崩溃。 内容来自：《Advanced Apple Debugging &amp; Reverse Engineering》","tags":[]},{"title":"Apple Debugging---开始使用LLDB","date":"2017-05-23T15:43:58.000Z","path":"2017/05/23/Apple-Debugging-开始使用LLDB/","text":"Getting around RootlessOS X 10.11 中引入的 Rootless，即使是root用户，也无法对以下路径有写和执行的权限： /System /bin /sbin /usr (except /usr/local) 只有Apple自身签名的软件（含命令行工具）可以。 Apple的Rootless机制虽然保护了系统的安全，防止了大部分恶意软件想通过单纯的引导用户，输入自己的密码点击确定来直接切换到root做一些违法的事情。也可以防止黑客黑了一个用户然后就有root权限可以肆意妄为的情况，不过对于真正的黑客来说 Disabling Rootless在电脑的Recovery Mode，打开终端输入 csrutil disable; reboot 电脑会重启，此时电脑就禁用了Rootless，可以调试系统级别的应用。 可以使用命令： lldb -n Finder 看到类似以下信息就表示成功 Process XXX stoped . . . Attaching LLDB to Xcode 使用lldb attach 到最常用的工具Xcode！ 方式一： lldb file /Applications/Xcode.app/Contents/MacOS/Xcode 方式二： lldb -n Xcode //需要Xcode在运行状态 方式三： pgrep -x Xcode //需要Xcode在运行状态 lldb -p 89921 //89921为Xcode的PID 方式四：(attaching 一个将会运行的程序) lldb -n Finder -w pkill Finder 运行程序： process lanuch -e /dev/ttys004 -- 这里的ttys004是shell中的某个tab的唯一id 运行程序时可以携带的参数： 通过-w参数改变运行程序的目录： 1(lldb) process launch -w /Applications 也可以直接将参数加到程序后面： 1(lldb) process launch -- /Applications -X参数让 shell 接受任何格式参数，比如下面这种 ~ 字符 1(lldb) process launch -X true -- ~/Desktop ps： run 命令是上面 process launch -X true -- 的简写 可以直接 run ~/Desktop -o 命令让LLDB输出到指定的文件 1(lldb) process launch -o /tmp/ls_output.txt -- /Applications -i 命令可以从外部文件读取数据，这在不想stdin的状况下很有用（还没有体会到😌 ） 1234(lldb) process launch -i /tmp/wc_input.txt等同于wc &lt; /tmp/wc_input.txt //wc为当前lldb的target -n 命令告诉LLDB不要创建stdin 1(lldb) process launch -n 按Ctrl + C可以暂停debugger， 添加一个断点： breakpoint set -n &quot;-[NSView hitTest:]&quot; continue //断点后继续执行 po $rdi // 查看RDI CPU register //修改一个断点，添加一个触发条件 breakpoint modify 1 -c &quot;(BOOL)[$rdi isKindOfClass:[NSTextView class]]&quot; 内容出处：《Advanced Apple Debugging &amp; Reverse Engineering》","tags":[]},{"title":"方向","date":"2017-05-11T03:26:32.000Z","path":"2017/05/11/方向/","text":"","tags":[]},{"title":"一次版本发布的启示","date":"2017-05-03T01:17:42.000Z","path":"2017/05/03/一次版本发布的启示/","text":"今天早上怀着惴惴不安的心情，点开了iTunes Connect，等待漫长的loading… 审核通过了！ 是不是我对Apple审核太敏感了？😂，只因为这个版本的发布因为审核被拖延好久了😕 刚好这段时间有在看《程序员的职业素养》这本书，结合这次的版本发布事故让我收获了新的体会。 事故现场直接来看事故现场吧： 25号提交版本，27号正常通过审核。当要发布的前一刻，测试姐姐告知我们有个功能这个版本不需要上，于是我们打算启用线上预埋的开关替换这版不需要上的功能的界面，从而正常上线当前等待发布区的版本。然而一切没有那么顺利，料想不到的是这个界面在预埋的处理中参数没有正确处理，导致了上述方案没法正常运行。 只好撤下已经过审的版本，修改问题重新提交。也就是图中圈起来的这一步，也正是这一步开启了万恶的轮回。。。 日子慢慢靠近五一假期，项目的上线时间倒没有要去凑节日这样的要求，只是如果在假期中出现线上什么问题，解决起来就没有那么高效，万一涉及到跟其他部门之间的配合修改，可就更加麻烦。毕竟小长假都在happy。 没想到，戏剧性的出现了下图中的这出戏 重新提交后的第二天，被Apple拒绝了。懵逼了，没有修改过其他代码，竟然前一天通过，这天就被拒绝，苹果爸爸果然强势。拒绝原因还让人无法拒绝，“APP的描述图片不符合规范”。这，，我们都已经用了两个版本了。好吧，让视觉大哥重新设计，运营重新提交了审核。现在也就希望五一期间正常上线就行了。 假期第一天29号，仍然被拒。而且被拒原因升级了。Apple审核人员告知我们APP在启动的时候crash了😱，定位了他们提供的奔溃日志后发现，它貌似是平常我们crash收集列表中的一个小概率出现的bug，但是之前一直没有找到根源在哪。 这次拿到的日志信息让我找到了奔溃处的代码，这是同事负责的模块。我找到可疑的地方，问了同事会不会出现我想象的错误导致崩溃，同事说不会，没有遇到过。我想着毕竟是他的模块，就不多说了，同事建议不修改再提交一次审核，我想着这个问题本也是概率出现时，说不定是审核人员运气太好遇到了。于是我们再次提交审核。。。 两天后 5.2小长假结束，回来上班了，打开iTunes Connect发现还是被拒绝了😖，我当时心里的第一感觉是后悔，后悔没有去修改那个问题，指不定就过了。现在要向领导汇报这次失误，还要继续确认问题。写了份上线被拒说明的pdf文档给老大并解释，老大让我赶紧定位问题，修改再提交上线，并语重心长地跟我重申了我们定好的每半个月更新线上版本的计划，告诉我这次的时间太久了。倍感压力和自责。。。 按照之前怀疑过的思路继续往下查，我找到了确凿的证据，导致crash的地方果然是那里。 我立马修改了代码重新提交审核，并发了testFlight让测试同学在针对性地点一点，自己也在紧张地review着，心里不断默念着：可不能再被拒绝了啊 然而，折磨我的路口总是一个个不断出现。上午提交后，我在下午的review中发现了一个不大不小的问题，同事测试在iPad版本（因为Apple审核人员使用iPad进行测试）中发现了另外一个问题，让我不得不重新撤回审核，修改了问题代码重新提交。这样断断续续折腾了一天。 终于在5.3，今天早上得到了一个好消息，磨人的审核。 感悟红色字体的地方都是我感悟的触发点。 “参数没有正确处理” 《程序员的职业素养》中提到一个高效工作的状态称作流态区。当人处在流态区中，其实是处在了一种浅层的冥想之中，会追求工作的速度，理性思考的能力会下降。当然我觉得，这当然排除需要高强度脑力思考的工作。但是这种强度在平常工作中基本遇不到。 为了尽快完成任务，我常会陷入流态区，预埋开关这种平常用不到的参数设置就没有注意去设置，并且没有去验证保证正确。为了完成某个任务而省略了验证的步骤往往会给自己往后增加更多的麻烦。 有个功能这个版本不需要上 测试同学在我们要上线的时候告诉我们那个功能不用上线，这个也是挺冤枉的，但是也该怪我们自己。这个功能前个版本就做好了，没有明说上不上，上版本上了让撤下来，这次上了又让撤下来。怪在我们一直拖着没有去确认清楚准确的时间，就算拿不到准确的时间也该在提交这次版本之前去确认这版要不要上。更好的解决办法是，在这里的配置一个这个功能的开关，可以在线上控制就免去这个麻烦。得过且过的惰性抑制了生产力 如果希望自己的软件灵活可变，那就应该时常修改它！ 让软件保持固定不变是危险的！如果一直不重构代码，等到最后不得不重构时，就会发现代码已经僵化了。 时常修改，并且大刀阔斧地修改的前提保证最好要有一套覆盖了代码的自动化测试。 不害怕修改代码那就是一直在改。 像《程序员的职业素养》中提到，代码就的时常优化，我有一个版本的时间，却没有去优化这个功能，造成了后面一系列的问题😫 我想着毕竟是他的模块，就不多说了 不得不承认，当时想着是这是同事的模块，我也询问过是否出现有我考虑到的问题，最后要是还有问题那就没有我什么责任了。 太傻！典型的缺失责任感，我知道我对那段代码存在怀疑，同事告知不会有问题也并没有说服我。不知道可选值是否可能为空的情况下对一个可选值强制解包，我第一反应是添加一个判空。没有坚持，觉得问题跟自己没多大关系，是个大错误。 发现了潜在的问题，并且是在审核的关键阶段，提出并去验证检查是该有责任。 后悔没有去修改那个问题，指不定就过了 在问题发生后再去想这样的事，也是个错误。这种思维回想过来无非是对之前同事判断的否定，并带着责怪。仔细想想，我自己不也是是同意了这样子去做了吗？！没有坚持去追究发现的问题，也想投机取巧想着轻松过关，没有认真对待这个问题。 不得不重新撤回审核 在再次提交这个版本的时候，老大有问过两次还有没有发现其他问题。满口地回答了没有，没想到还是中招了。自我审查的责任感，还需要提高，不能把测试组当成是抓虫机器。当初真的在这样的思想上栽了大跟头，还需要不断地改善。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://huyangjie.com//tags/随笔/"}]},{"title":"多睡觉多读书","date":"2017-04-28T05:29:31.000Z","path":"2017/04/28/多睡觉多读书/","text":"有那么一段时间一天写12个小时的代码，而且都是业务的代码，脑子填充满满地，没有思考生活、学习和娱乐的余地。 那时我感觉自己像是最喜欢的美剧：The Walking Dead 中的行尸走肉，没有自己的思维，吸着雾霾踏着自行车上班，踩着朦胧夜色归来点份外卖。几乎没有代码以外的交流，没有目的地也不知道往哪走。我厌恶这样的生活状态，但是不知道该如何逃脱，我也不知道怎么陷入了这样的心态。 直到有一次抽空看了《软件开发者路线图-从学徒到高手》这本书，我对自己多了写思考。 回忆写这篇文章的时候，距离看完这本书已经有些时间了，我感觉到自己现在的状态已经调整好了不少，不过也不是理想。 到现在我印象最深，也就是这本书给我最大的启迪是：善于暴露自己的不足 人有二知二不知 I know that I know I know that I don’t know I don’t know that I know I don’t know that I don’t know 资质平庸而又刚毕业一年的小鸟，在一个领域会有什么样的建树？ 可笑的是我曾觉得自己的技术水平已经属于挺不错😅基本iOS上开发有深有浅的都了解了。于是想着要装装X，写写博客展示下自己的水平。可当搭好了博客框架想要动笔时，才发现自己脑子的“干货”仓库中的东西是多么平庸。于是开始踮起脚尖写博客，边学习边总结到博客上，这成了之前的模式。 这时候不敢把自己直接暴露在问题之下，喜欢套用经验模式，I don’t know that I don’t know 提升技术的提升和成长是由内而外，没有墨水就写不出字，成为不了一个输出者。 慢慢看了一些拔高的书之后，我意识到自己有那么多的不知道。博客对于我的意义开始改变，它成了我暴露不足弥补不足的地方。强者的强大在于它最脆弱的地方，展现自己的不足。 保证精力，多睡觉，多读书！","tags":[{"name":"随笔","slug":"随笔","permalink":"http://huyangjie.com//tags/随笔/"}]},{"title":"解读Objective-C的NSDictionary","date":"2017-04-20T03:27:20.000Z","path":"2017/04/20/解读Objective-C的NSDictionary/","text":"NSDistionary是非常熟悉常用的一个Foundation中的类，最显著的几个特点是： 以键值对存储数据 存储的数据具有唯一性 数据无序 我们这次不是讲NSDictionary或NSMutableDictionary的方法，这些在Apple API Reference中查询即可了解啦~我们来探索下NSDictionary的内部 Apple文档的启示苹果貌似并不推荐我们去继承NSDictionary来使用其子类（苹果已经实现的子类：NSMutableDictionary除外） Before making a custom class of NSDictionary, investigate NSMapTable and the corresponding Core Foundation type, CFDictionary. Because NSDictionary and CFDictionary are “toll-free bridged,” you can substitute a CFDictionary object for a NSDictionary object in your code (with appropriate casting). Although they are corresponding types, CFDictionary and NSDictionary do not have identical interfaces or implementations, and you can sometimes do things with CFDictionary that you cannot easily do with NSDictionary. If the behavior you want to add supplements that of the existing class, you could write a category on NSDictionary. Keep in mind, however, that this category will be in effect for all instances of NSDictionary that you use, and this might have unintended consequences. Alternatively, you could use composition to achieve the desired behavior. 大致意思是让我们想要给NSDictionary添加新功能就使用分类，不要继承子类。如果打算要继承NSDictionary，则需要好好研究下NSMapTable和相对应的Core Foundation类型：CFDictionary CFDictionary是Core Foundation中的字典，和NSDictionary可以无代价转换，两者可以互相调用对方的方法创建和释放。可以使用CFDictionary来实现NSDictionary不容易实现的功能。· 另外苹果推荐让我们研究的NSMapTable具体是什么呢? The NSMapTable class is a mutable collection modeled after NSDictionary 看到这句话刚开始我有点不解，NSMapTable竟是模仿NSDictionary的一个可变得集合，那跟NSMutableDictionary有什么不同啊？ NSMapTable与NSDictionary的几个不同点是： 可以weak的方式持有对象，当持有的对象的引用计数为0的时候，该对象会自动从集合中移除 key 和 value在输入的时候都可以copy，使用指针对做isEqual或者hashing对比 可以包含任何指针，不再仅仅局限于Objective-C的对象 NSMapTable的初始化就可以指定 key 和 value 的持有方式 苹果提供了几个便捷的工厂方法12345678//key strong， value strong+ (NSMapTable&lt;KeyType, ObjectType&gt; *)strongToStrongObjectsMapTable NS_AVAILABLE(10_8, 6_0);//key weak， value strong+ (NSMapTable&lt;KeyType, ObjectType&gt; *)weakToStrongObjectsMapTable NS_AVAILABLE(10_8, 6_0); // entries are not necessarily purged right away when the weak key is reclaimed//key strong， value weak+ (NSMapTable&lt;KeyType, ObjectType&gt; *)strongToWeakObjectsMapTable NS_AVAILABLE(10_8, 6_0);//key weak， value weak+ (NSMapTable&lt;KeyType, ObjectType&gt; *)weakToWeakObjectsMapTable NS_AVAILABLE(10_8, 6_0); // entries are not necessarily purged right away when the weak key or object is reclaimed 或者像这样指定： 123456//还可以指定NSMapTableCopyIn(添加前进行copy) ， 或者NSMapTableObjectPointerPersonality（使用指针去hashing） NSMapTable *mapTable = [NSMapTable mapTableWithKeyOptions:NSMapTableStrongMemory valueOptions:NSMapTableWeakMemory]; //需要一个对象到对象的映射集合，可以使用如下的mapTable NSMapTable *objectToObjectMapping = [NSMapTable mapTableWithStrongToStrongObjects]; 同样类推，NSHashTable是对NSSet的模仿和衍生，扩展的功能与NSMapTable相同 抛两个问题🙈Q：上千的对象存储到NSDictionary时，出现效率低下的问题是什么原因？直接先回答问题：因为存储的数量很多后hash表会出现比较多的冲突，解决大量冲突会占用大量CPU资源，造成效率低下。 hash表是什么？跟NSDictionary又有什么关系？ NSDictionary是使用hash表来实现key和value之间的映射和存储的。 hash表的基本思想是：将key作为关键字，放到hash函数ƒ(k)中计算得到结果为hash地址，然后将value值的地址存储到hash表中的ƒ(key)的hash地址中。 当关键字集合很大的时候，不同的关键字可能会通过hash函数映射到hash表的同一地址上。key1 ≠ key2, ƒ(key1) = ƒ(key2),这种情况称为冲突。冲突是不可避免的，只能通过改善哈希函数来减少冲突。（构造哈希函数方法请参考这里或查找其他资料） 然而有冲突必定是要解决的，不然新的值怎么存储到哈希表中呢。处理冲突主要有（查看原文请移步底部参考链接：哈希表）： 开放定址法 线性探测 平方探测 伪随机探测 单独链表法 将散列到同一个存储位置的所有元素保存在一个链表中。实现时，一种策略是散列表同一位置的所有冲突结果都是用栈存放的，新元素被插入到表的前端还是后端完全取决于怎样方便。 再哈希 上一次哈希计算发生冲突后，使用另外的哈希函数进行哈希计算知道冲突不再发生 建立公共溢出区 为冲突的哈希地址单独建立一块区域，所有冲突的哈希地址都存放在此区域中 到这里也就可以推断出，如果在NSDictionary存取时出现效率低下的情况，那么很可能是： 1.频繁的扩容 2.冲突过多 Q：NSMapTable是怎样的结构呢？先来看看NSMapTable的结构(代码来自于cocotron)NSMapTable是一个key－value的容器，下面是NSMapTable的部分代码： 12345typedef struct &#123; NSMapTable *table; NSInteger i; struct _NSMapNode *j;&#125; NSMapEnumerator; 上述结构体描述了遍历一个NSMapTable时的一个指针对象，其中包含table对象自身的指针，计数值，和节点指针。 12345678typedef struct &#123; NSUInteger (*hash)(NSMapTable *table,const void *); BOOL (*isEqual)(NSMapTable *table,const void *,const void *); void (*retain)(NSMapTable *table,const void *); void (*release)(NSMapTable *table,void *); NSString *(*describe)(NSMapTable *table,const void *); const void *notAKeyMarker;&#125; NSMapTableKeyCallBacks; 上述结构体中存放的是几个函数指针，用于计算key的hash值，判断key是否相等，retain，release操作。 12345typedef struct &#123; void (*retain)(NSMapTable *table,const void *); void (*release)(NSMapTable *table,void *); NSString *(*describe)(NSMapTable *table, const void *);&#125; NSMapTableValueCallBacks; 上述存放的三个函数指针，定义在对nsmaptable插入一对key－value时，对value对象的操作。 1234567@interface NSMapTable : NSObject &#123; NSMapTableKeyCallBacks *keyCallBacks; NSMapTableValueCallBacks *valueCallBacks; NSUInteger count; NSUInteger nBuckets; struct _NSMapNode **buckets;&#125; 上面是NSMtabtable真正的描述，可以看出来NSMapTable是一个哈希＋链表的数据结构(也就是使用Hash表中的单链表法解决冲突)，因此在NSMapTable中插入或者删除一对对象时 寻找的时间是O（1）＋O（m），m最坏时可能为n。 O（1）：为对key进行hash得到bucket的位置 O（m）：遍历该bucket后面冲突的value，通过链表连接起来。 因此：NSDictionary中的key Value遍历时是无序的，至如按照什么样的顺序，跟hash函数相关。NSMapTable使用NSObject的哈希函数。 123-(NSUInteger)hash &#123; return (NSUInteger)self&gt;&gt;4;&#125; 上述是NSObject的哈希值的计算方式，简单通过移位实现。右移4位，左边补0.因为对象大多存于堆中，地址相差4位应该很正常。 参考： NSMapTable: more than an NSDictionary for weak pointers Apple API Reference - NSMapTable Apple API Reference - NSHashTable 维基百科 - 哈希表(需要翻下墙，也可以问下度娘) 关于NSDictionary NSDictionary 的内部实现 《Objective-C高级编程：iOS与OS X多线程和内存管理》 ARC的实现","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"removeFromSuperView浅谈","date":"2017-03-29T09:26:16.000Z","path":"2017/03/29/removeFromSuperView浅谈/","text":"Unlinks the receiver from its superview and its window, and removes it from the responder chain. 译：把当前View从它的父View和窗口中移除，同时也把它从响应事件操作的响应者链中移除。 方法调用后的内存管理先来看一段代码： 1234567891011121314151617181920212223UIView *view = [UIView new];self.testView = view;[self.view addSubview:view];self.title = @\"jake\";[self.testView removeFromSuperview];@try &#123; for (int i = 0; i &lt; 10; i ++) &#123; NSLog(@\"前 %ld\", CFGetRetainCount((__bridge CFTypeRef)self.testView)); [self.testView removeFromSuperview]; NSLog(@\"后 %ld\", CFGetRetainCount((__bridge CFTypeRef)self.testView)); self.testView.backgroundColor = [UIColor redColor]; [self.testView setUserInteractionEnabled:YES]; [self.testView removeFromSuperview]; [self.testView setNeedsDisplay]; &#125; &#125; @catch (NSException *exception) &#123; NSLog(@\"name : %@, reason : %@\", exception.name, exception.reason); &#125; @finally &#123; &#125; 这段代码执行不会崩溃，self.testView执行了多次removeFromSuperView也没有问题。 苹果爸爸对这个方法这样说的： The view is also released; if you plan to reuse it, be sure to retain it before sending this message and to release it as appropriate when adding it as a subview of another NSView. 调了这个方法就release了这个view，叫我们想要再次使用就得把它retain下来。 结果我执行上段代码，打印出来testView的retainCount不但没有减少反而增加了1 (;￢＿￢) ，不过在调用完（这个runloop结束）之后还是会release的。好吧，其实reatainCount不能太当回事，之前在MRC时期经常发现retainCount不准确，这主要是因为iOS系统API的引用、或自动释放池导致的，所以retainCount并不能当做可靠的参考。 无论是ARC还是MRC中多次调用removeFromSuperview和addSubview:方法，都不会造成造成重复释放和添加。 永远不要在你的View的drawRect:方法中调用removeFromSuperview。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"H5跳转Native路由机制的探索","date":"2017-03-24T01:20:47.000Z","path":"2017/03/24/H5跳转Native路由机制的探索/","text":"公司的项目核心业务都在H5，为了提高APP的使用体验，这段时间在重构部分功能业务到Native。重构过程持续了4期（一期1~2周），天天工作量杠杠的（因为追求速度，线上质量打了折扣，现在放慢脚步正在稳固，我才得以写这篇文章，接下来还要继续下一期的重构,又期待又紧张）。在重构过程中，收获到了挺多Native与H5之间交互和一些动态配置的体会，就在这记录下这些风雨历程吧。 ps: 文中不涉及具体代码，主要记录实现的机制和逻辑，之后将代码方案抽离项目后会添加demo地址 功能需求扯一扯：公司现在版本的APP的主业务在H5端，那么我们Native重构的页面就避免不了跟H5之间的交互。这是最基本的需求，完成这个需求的方案已经比较稳定，我们使用自己定义的协议对需要交互的功能进行拦截实现H5到Native的交互。Native到H5的话就直接在控制器内加载指定地址的webView。 很显然，在Native到H5这一步有很大的优化空间。老大提出了这样的要求： 所有跳转的H5地址都需要能够在服务端动态配置，下文称：DymaticH5方案 所有的Native页面能够被H5调起，不管在应用内还APP外，下文称：NativeScheme方案 另外一位H5同事附加提出了一套线上容错方案(拯救了两次线上bug) 所有(有需求)的Native页面都能够通过服务端配置随时替换成H5， 下文称：SwitchPage方案 方案探索DymaticH5方案首先介绍下环境： 我们的在线环境配置文件都放在自己实现的静态接口平台下面称tms，由我们前端部门的同学自己管理，可以方便及时地配合客户端和H5的迭代和更新。 首先我们将所有需要动态化配置(由Native跳到H5)的H5地址页面地址整理放到tms的配置文件中，例如: 12345&#123; home : https://www.baidu.com, mine : https://www.mine.com, news : https://www.news.com&#125; 工程项目中添加与tms配置文件格式相同的plist文件,用于存储当tms上没有配置动态H5地址时的默认H5地址。 整个项目中的H5地址由URLCenter工具类集中管理，获得H5地址后存储在DynamicH5Model中。 DynamicH5Model职责： 获取plist中的H5地址给model赋值 读取tms返回的H5地址给model重新赋值 URLCenter职责： 读取DynamicH5Model中的H5地址 获取调用者传入H5地址所需要带的参数 拼接参数返回调用者需要的完整的H5地址 我们来看一张简单的流程图： APP启动程序先读取plist中的默认H5地址赋值到model，在请求tms配置文件之后，再获取tms中配置的H5地址赋值到model，这样可以保证每个H5地址都可以有值，并且都是我们所需要的最新的地址。如此，即使在线上，不用发版本我们的APP也可以自如地控制和更新每个功能模块跳转的H5页面内容。 当然，每个H5地址需要什么参数还是得调用者自己知道，然后将参数赋值到URLCenter中。 NativeScheme方案 取名叫NativeScheme，当然这个方案跟sheme有关，但也不仅仅是使用sheme。 先说明这个方案最终达到的效果吧： APP中的部分功能模块点击跳转指向本地的哪个页面由服务端控制，不再需要本地固定。可以随时切换功能模块跳转到对应的H5页面还是对应的Native页面，当然前提是这两者页面都有实现。 例如： 在这样的功能块中，每个功能模块点击后通过服务器返回的NativeScheme判断跳转到本地的对应页面。 实现原理： 服务器给每个功能块添加一个nativeScheme的字段, 如 myApp://jakeApp/home 其中 myApp为APP的info.plist配置文件中的URL Scheme 若部分页面初始化时有些必要的参数需要指定，NativeScheme可以附加必要的参数，如myApp://jakeApp/home?homeType=1 工程项目中创建一个nativeScheme.plist，其中存储的是每个nativeScheme对应的本地控制器的名字和控制器初始化的方式（storyboard或xib或frame） 如： 1234567891011&#123; myApp://jakeApp/home : &#123; class : HomeViewController, type : storyboard &#125;, myApp://jakeApp/mine : &#123; class : MineViewController, type : xib &#125;&#125; 整个项目的控制器跳转由URLRouter控制，可传入H5地址或者NativeScheme地址获得将要跳转到的控制器 URLRouter职责: 传入navtiveScheme格式的地址，则从本地navtiveScheme.plist中获取对应控制器并初始化传入从地址中获得的参数 传入H5地址则获得完整的H5地址(若有使用第一节中的DynamicH5方案可以将其传入URLCenter获得地址)，创建webView跳转 APP可通过 URL Scheme唤起，在AppDelegate对应的方法中使用URLRouter跳转到对应的Native页面 方案扩展使用： 我们还可以在nativeScheme判读环节添加一个动态的节点(根据需求)，以实现点击功能块后是跳转到H5页面还是跳转本地的页面(此逻辑不同于本章第三节 “SwitchPage方案”)。可以给每个功能块分别添加 本地scheme地址 和 H5地址 两个字段，用于分别是跳向哪种界面。判断规则可以根据自己的需求来定。 附上NativeScheme的简单流程图： 此方案部分参考：https://github.com/DarielChen/DCURLRouter 感谢作者 SwitchPage方案这套方案的存在，在某种意义上是一套线上的紧急备用方案—-当重构的Native页面出现问题，可以通过此方案将该Native页面替换为H5页面。此方案，可以说是对我们项目现状比较适用，在其他项目中或许存在的意义没有那么大。但是这套原理可以拿来做参考，毕竟SwitchPage可以将任意一个Native页面替换为任意一个H5的页面。 实现原理： 实现逻辑也比较简单， tms上配置需要替换的控制器名字和需要替换成的H5地址的绝对路径，如： 123&#123; HomeViewController : https://www.baidu.com&#125; 重写本地的Nativgation的push方法， 在此方法调用super之前，判断将要跳转的控制器名称在tms请求返回的数据中是否存在，如果存在则跳转webView控制器，不存在则按照原来方法跳转。（可结合NativeScheme方案使用，在URLRouter中实现此逻辑） 附上简单流程图： 总结不足：NativeScheme方案中的参数传递比较地生硬，若是需要跳转的Native控制器需要制定的参数需要额外处理，则无法通过shceme后带参数的方式在URLRouter中直接给要返回的控制器添加参数 上面三套方案可以在项目中一起使用，相互之间不会影响，也可以单独使用其中的某一套方案。 demo地址：即将出现","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"JSPatch遇上Swift","date":"2017-02-08T06:42:27.000Z","path":"2017/02/08/JSPatch遇上Swift/","text":"JSPatch的动态更新是依赖于Objective-C的runtime，那作为静态语言的Swift就没有办法使用JSPatch了吗？Swift类成员还是可以使用Objective-C的运行时动态派发，只要Swift类是继承自NSObject或者使用dynamic修饰的类的成员。 纯Swift类没有动态性 无法重写纯swift类的方法和属性JSPatch在进行到overrideMethod进行方法实现IMP替换时要求class实现NSCoping协议，而不继承自NSObject的swift类是不遵循该协议的，因此会崩溃。 Swift中使用Method Swizzling的原则摘自底部参考资料 继承自NSObject的Swift类，其继承自父类的方法具有动态性，其他自定义方法、属性需要加dynamic修饰才可以获得动态性。 若方法的参数、属性类型为Swift特有、无法映射到Objective-C的类型(如Character、Tuple)，则此方法、属性无法添加dynamic修饰（会编译错误）。 纯Swift类没有动态性，但在方法、属性前添加dynamic修饰可以获得动态性。 官方文档dynamic声明修饰符释义 该修饰符用于修饰任何兼容 Objective-C 的类的成员。访问被dynamic修饰符标记的类成员将总是由OC运行时系统进行动态派发，而不会由编译器进行内联或消虚拟化。 JSPatch上手使用 继承自NSObject的Swift类中 123456class ViewController: UIViewController &#123; override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) self.view.backgroundColor = UIColor.yellow; &#125;&#125; 重载自父类的方法不需要dynamic修饰符进行修饰，可以直接进行JSPatch动态替换。 自定义的Swift方法需要加上dynamic修饰符 12345678910class ViewController: UIViewController &#123; override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) self.view.backgroundColor = UIColor.yellow; &#125;&#125;dynamic func test() &#123; print(\"这是原生的打印\") &#125; Swift中Cocoa的API方法跟Objective-C不同时，JSPatch代码 1234567891011dynamic func paramTest(paramOne: String, paramTwo: String) -&gt; String &#123; return \"原生的字符串\"; &#125; dynamic func paramTest2(_ paramOne: String, withParam paramTwo: String) -&gt; String &#123; return \"原生字符串2\" &#125; dynamic func paramTest3(withParamOne paramOne: String, andParamTwo paramTwo: String) -&gt; String &#123; return \"原生字符串3\" &#125; 1234567891011paramTestWithParamOne_paramTwo: function(paramOne, paramTwo) &#123; return \"JS字符串\" &#125;, paramTest2_withParam: function(paramOne, paramTwo) &#123; return \"JS字符串2\" &#125;, paramTest3WithParamOne_andParamTwo: function(paramOne, paramTwo) &#123; return \"JS字符串3\" &#125;, defineClass中指定类名需要带上项目target的名字 12345678910111213141516171819202122232425require('UIColor')defineClass(\"Swift_JSPatch.ViewController\", &#123; viewWillAppear: function(animated) &#123; self.super().viewWillAppear(animated) self.view().setBackgroundColor(UIColor.redColor()) &#125;, test: function() &#123; console.log(\"JS输出的代码\") &#125;, paramTestWithParamOne_paramTwo: function(paramOne, paramTwo) &#123; return \"JS字符串\" &#125;, paramTest2_withParam: function(paramOne, paramTwo) &#123; return \"JS字符串2\" &#125;, paramTest3WithParamOne_andParamTwo: function(paramOne, paramTwo) &#123; return \"JS字符串3\" &#125;, &#125;, &#123;&#125;) 参考：JSPatch在Swift中的应用","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://huyangjie.com//tags/Swift/"}]},{"title":"Swift和Objective-C的数组转换","date":"2017-01-20T02:45:57.000Z","path":"2017/01/20/Swift和Objective-C的数组转换/","text":"当我们在 Objective-C 代码中使用 Swift 类或者协议时，接入的API会将全部所有类型的Swift数组代替为NSArray。 Swift 的编译器会在接入 Objective-C APIs 的时候将NSArray类替换成AnyObject[] 若我们将一个NSArray对象传递给Swift的API并要求数组元素为一个新的类型，运行时就会产生错误。 如果 Swift API 返回一个不能被转换为NSArray类型的 Swift 数组，错误也会随之产生。 如果某个对象是 Objective-C 或者 Swift 类的实例，或者这个对象可以转换成另一种类型，那么这个对象则属于AnyObject类型的对象 例如，一个Int[]类型的 Swift 数组包含Int结构的元素。Int类型并不是一个类的实例，但由于Int类型转换成了NSNumber类，Int类型属于AnyObject类型的。 Swift数组转换成NSArray: 当我们从 Swift 数组转换为NSArray对象时，Swift 数组里的元素必须是属于AnyObject的。 当我们从一个 Swift 数组转换成一个NSArray对象后，转换后的结果则是一个[ObjectType]类型的数组. NSArray对象转换成Swift数组: 我们可以将任意NSArray对象转换成一个Swift数组，因为所有Objective-C的对象都是AnyObject类型。 如果NSArray对象没有指明一个确切的参数类型，那么它将会转换成[AnyObject]类型的Swift数组。 1234//Objective@property NSArray&lt;NSDate *&gt;* dates;//Swiftvar dates: [NSDate] NSArray对象转换成一个 Swift 数组后，也可以将数组强制类型转换成一个特定的类型。，从AnyObject类型的对象转换成明确的类型并不会保证成功，从AnyObject[]转换为SomeType[]会返回一个 optional 的值。例子： 1234let swiftyArray = foundationArray as AnyObject[]if let downcastedSwiftArray = swiftArray as? UIView[] &#123; // downcastedSwiftArray contains only UIView objects&#125; 也可以在for循环中将NSArray对象定向地强制转换为特定类型的Swift数组: 123for aView: UIView! in foundationArray &#123; // aView is of type UIView&#125; 参考：Using Swift with Cocoa and Objective-C","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://huyangjie.com//tags/Swift/"}]},{"title":"Using Swift With Cocoa and Objective-C笔记_ONE","date":"2017-01-19T07:49:18.000Z","path":"2017/01/19/Using-Swift-with-Cocoa-and-Objective-C笔记-ONE/","text":"Objective-C和Swift的非空值、可选值转换Objective-C 能够使用空值标记来设定一个参数类型，属性类型或者返回值类型是否可以为 NULL 或者 为 nil 值。单独的类型声明可以使用nullable和nonnull标注，空值的范围性的声明可以使用NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END宏。如果一个类型没有任何的空值标注信息，Swift 就不能分辨出可选值和非可选值类型，并且将作为隐式的解包可选值导入。 以__nonnull或者范围宏标注声明的空值类型，被作为非空可选值non-optional导入到 Swift。 以__nullable标注声明的空值类型，被作为可选值导入到 Swift。 没有以空值标注声明的类型被作为隐式的解包可选值导入到 Swift。 Objective-C申明 1234567891011@property (nullable) id nullableProperty;@property (nonnull) id nonNullProperty;@property id unannotatedProperty;NS_ASSUME_NONNULL_BEGIN- (id)returnsNonNullValue;- (void)takesNonNullParameter:(id)value;NS_ASSUME_NONNULL_END- (nullable id)returnsNullableValue;- (void)takesNullableParameter:(nullable id)value;- (id)returnsUnannotatedValue;- (void)takesUnannotatedParameter:(id)value; 导入Swift中： 123456789var nullableProperty: AnyObject?var nonNullProperty: AnyObjectvar unannotatedProperty: AnyObject!func returnsNonNullValue() -&gt; AnyObjectfunc takesNonNullParameter(value: AnyObject)func returnsNullableValue() -&gt; AnyObject?func takesNullableParameter(value: AnyObject?)func returnsUnannotatedValue() -&gt; AnyObject!func takesUnannotatedParameter(value: AnyObject!) 闭包和Block的交互Objective-C 中的blocks会被自动导入为 Swift 中的闭包。例如，下面是一个 Objective-C 中的 block 变量： 1void (^completionBlock)(NSData *, NSError *) = ^(NSData *data, NSError *error) &#123;/* ... */&#125; 而它在 Swift 中的形式为: 1let completionBlock: (NSData, NSError) -&gt; Void = &#123;data, error in /* ... */&#125; Swift 的闭包与 Objective-C 中的 blocks 能够和睦相处，所以你可以把一个 Swift 闭包传递给一个把 block 作为参数的 Objective-C 函数。Swift 闭包与函数具有互通的类型，所以你甚至可以传递 Swift 函数的名字。 闭包与 blocks 语义上相通但是在一个地方不同：变量是可以直接改变的，而不是像 block 那样会拷贝变量。换句话说，Swift 中变量的默认行为与 Objective-C 中 __block 变量一致。 Swift类型兼容性 @objc 和 dynamic@objc可以让你的 Swift API 在 Objective-C 中使用。换句话说，你可以通过在任何 Swift 方法、类、属性前添加@objc，来使得他们可以在 Objective-C 代码中使用。如果你正在使用如键值观察的 API 来动态替换方法的实现，也可以通过使用dynamic修饰符来获得对 Objective-C 运行时被自动派发的成员的访问。 当你在 Objective-C 中使用 Swift API，编译器通常会对语句做直接的翻译。例如，Swift API func playSong(name: String)会被解释为- (void)playSong:(NSString *)name。然而，有一个例外：当在 Objective-C 中使用 Swift 的初始化函数，编译器会在方法前添加“initWith”并且将原初始化函数的第一个参数首字母大写。例如，这个 Swift 初始化函数init (songName: String, artist: String)将被翻译为- (instancetype)initWithSongName:(NSString *)songName artist:(NSString *)artist。 Swift 同时也提供了一个@objc关键字的变体，通过它你可以自定义在 Objective-C 中转换的函数名。 例子： 12345678//Swift@objc(Squirrel)class Белка &#123; @objc(initWithName:) init (имя: String) &#123; /*...*/ &#125; @objc(hideNuts:inTree:) func прячьОрехи(Int, вДереве: Дерево) &#123; /*...*/ &#125;&#125; 轻量级泛型123@property NSArray&lt;NSDate *&gt;* dates;@property NSSet&lt;NSString *&gt;* words;@property NSDictionary&lt;KeyType: NSURL *, NSData *&gt;* cachedData; 123var dates: [NSDate]var words: Set&lt;String&gt;var cachedData: [NSURL: NSData] 注意 除了 Foundation 中的集合类， Objective-C 的轻量级泛型会被 Swift 忽略掉。任何其他使用轻量级泛型的类型在导入到 Swift 中时会被视为无参数化。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://huyangjie.com//tags/Swift/"}]},{"title":"Swift的weak Unowned Unowned(unsafe)","date":"2017-01-19T03:56:19.000Z","path":"2017/01/19/Swift的weak-unowned-unowned-unsafe/","text":"Swift同样也是用ARC管理内存，为了解决引用循环。同OC一样使用weak修饰对象，在weak引用指向的对象被释放之后，其自身会被置为nil也会被释放。 而在Swift中nil是Optional的专属，对于非可选类型，则使用无主引用：unowned 使用无主引用，你必须确保引用始终指向一个未销毁的实例。如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。 安全无主引用unowned指向的对象被释放之后，其自身不会被置为nil，也不可访问。 不安全无主引用unowned（unsafe）指向的对象被释放之后，你试图去访问这个引用，程序会尝试访问该实例之前坐在的内存地址，这是一个不安全的操作 使用场景解析：前提描述： A类中有一个B类的属性， B类中有一个A类的属性 两个属性的值都允许为nil，并会潜在产生循环引用 这种情况适合使用weak来解决 其中一个属性的值允许为nil，而另一个不允许为nil 这种情况最适合通过无主引用来解决 两个属性都必须有值，并且初始化完成后永远不会为nil 这种情况，需要一个雷使用无主属性，为另外一个类使用隐式解析可选属性 场景3例子： 1234567891011121314151617class Country &#123; let name: String var capitalCity: City! init(name: String, capitalName: String) &#123; self.name = name self.capitalCity = City(name: capitalName, country: self) &#125; &#125;class City &#123; let name: String unowned let country: Country init(name: String, country: Country) &#123; self.name = name self.country = country &#125; &#125; 解决闭包引起的循环引用 Swift 有如下要求：只要在闭包内使用 self 的成员，就要用 self.someProperty 或者 self.someMethod() 不只是 someProperty 或 someMethod() ）。这提醒你可能会一不小心就捕获了 self 。 第一捕获列表解决循环引用，例子： 捕获列表中的每一项都由一对元素组成，一个元素是 weak 或 unowned 关键字，另一个元素是类实例的引用 1234lazy var someClosure: (Int, String) -&gt; String = &#123; [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in // 这里是闭包的函数体 &#125; 如果被捕获的引用绝对不会变为 nil ，应该用无主引用，而不是弱引用。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://huyangjie.com//tags/Swift/"}]},{"title":"Cookie in iOS","date":"2017-01-12T08:37:13.000Z","path":"2017/01/12/cookie-in-iOS/","text":"背景项目中用到了本地登录存储cookie，再进行webView请求时间带上cookie的功能。不是很清晰逻辑，于是学习了解了下iOS中cookie的使用，做个小结。跳过概念直接看使用🌰 Cookie介绍Cookie分类两类： 会话cookie 持久cookie 会话 cookie 和持久 cookie 之间唯一的区别就是它们的过期时间。 cookie如何工作 cookie 中包含了一个由 名字 = 值 （name=value） 这样的信息构成的任意列表，并通过 Set-Cookie 或 Set-Cookie2 HTTP 响应（扩 展）首部将其贴到用户身上去。 cookie组成现在使用的 cookie 规范有两个不同的版本：cookies 版本 0（有时被称为 Netscape cookies） 和 cookies 版 本 1（RFC 2965） 。 cookies 版 本 1 是 对 cookies 版 本 0 的 扩 展，应用不如后者广泛。 cookie版本0 Set-Cookie 首部Set-Cookie 首部有一个强制性的cookie名和cookie值。后面跟着可选的cookie 属性，中间由分号分隔。 cookie 0首部: 1Cookie: session-id=002-1145265-8016838; session-id-time=1007884800 cookie版本1 Set-Cookie2首部这个版本 1 标准引入了Set-Cookie2首部和Cookie2首部，但它也能于版本0进行交互操作。 cookie 1首部: 12345Cookie: $Version=&quot;1&quot;;ID=&quot;29046&quot;; $Domain=&quot;.joes-hardware.com&quot;;color=&quot;blue&quot;;Coupon=&quot;hammer027&quot;; $Path=&quot;/tools&quot;;Coupon=&quot;handvac103&quot;; $Path=&quot;/tools/cordless&quot; NSHTTPCookieStorage NSHTTPCookieStorage implements a singleton object (shared instance) that manages storage of cookies. Each cookie is represented by an instance of the NSHTTPCookie class. As a rule, cookies are shared among all applications and are kept in sync across process boundaries. Session cookies (where the cookie object’s sessionOnly method returns YES) are local to a single process and are not shared. NSHTTPCookieStorage的实现是一个单例对象，管理着NSHTTPCookie对象，会话cookie的 sessionOnly方法返回YES就不可在进程间共享。 然而苹果在这个类的API Reference中写了一个iOS Note： Cookies are not shared among applications in iOS. iOS中cookie不能跨应用共享 MacOS中sessionOnly不为YES是可以被共享的 NSHTTPCookieStorage可以管理cookie的接受策略，在一个app中改变cookie的接受策略将会影响其他正在运行的app的cookie接受策略。 当其他的app修改了cookie存储 或者 cookie接受策略，NSHTTPCookieStorage将会给app发送NSHTTPCookieManagerCookiesChangedNotification或者NSHTTPCookieStorageAcceptPolicyChangedNotification通知 Cookie接受策略：NSHTTPCookieAcceptPolicy 12345typedef NS_ENUM(NSUInteger, NSHTTPCookieAcceptPolicy) &#123; NSHTTPCookieAcceptPolicyAlways,//默认策略，接受所有的cookies NSHTTPCookieAcceptPolicyNever,//拒绝所有的cookies NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain//只从主文档域名接受cookies&#125;; NSHTTPCookie An NSHTTPCookie object represents an HTTP cookie. It is an immutable object, initialized from a dictionary containing the cookie attributes. NSHTTPCookie对象中包含了HTTP 的cookie对象，从包含cookie字段的字典初始化创建。 The NSHTTPCookie class encapsulates a cookie, providing accessors for many of the common cookie attributes. This class also provides methods to convert HTTP cookie headers to NSHTTPCookie instances and convert an NSHTTPCookie instance to headers suitable for use with an NSURLRequest object. The URL loading system automatically sends any stored cookies appropriate for an NSURLRequest object unless the request specifies not to send cookies. Likewise, cookies returned in an NSURLResponse object are accepted in accordance with the current cookie acceptance policy. NSHTTPCookie类封装了一个HTTP Cookie，并提供常见的Cookie属性访问接口。NSHTTPCookie可以转换HTTP Cookie成NSHTTPCookies对象，并可以将NSHTTPCookie对象转化为NSURLRequest对象的请求头部分。URL loading system 会自动地给NSURLRequest对象发送存储的cookie，除非NSURLRequest对象指定不需要传cookie，同样cookie在NSURLRequest中返回也按照当前的cookie接受策略接收。 Cookie使用💪个🌰Cookie生成的有两个途径，一个是访问一个网页，这个网页返回的HTTP Header中有Set-Cookie指令进行Cookie的设置，这里Cookie的本地处理其实是由WebKit进行的；还有一种途径就是客户端通过代码手动设置Cookie。 值得注意iOS Cookie使用提到：NSHTTPCookieStorage存在一个问题，setCookie或者deleteCookie后并不会立即进行持久化，而是有几秒的延迟。为了可靠性，我们会将cookie信息保存一份到User Defaults，需要用的时候load进来。 客户端手动设置Cookie 12345678910NSMutableDictionary *cookieProperties = [NSMutableDictionary dictionary];[cookieProperties setObject:@\"name\" forKey:NSHTTPCookieName];[cookieProperties setObject:@\"value\" forKey:NSHTTPCookieValue];[cookieProperties setObject:@\"www.taobao.com\" forKey:NSHTTPCookieDomain];[cookieProperties setObject:@\"/\" forKey:NSHTTPCookiePath];[cookieProperties setObject:@\"0\" forKey:NSHTTPCookieVersion];[cookieProperties setObject:@\"30000\" forKey:NSHTTPCookieMaximumAge];NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:cookieProperties];[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];//删除cookie的方法为deleteCookie: 在通过setCookie:进行设置cookie的时候，会覆盖name,domain,path都相同的cookie的。至于cookie会不会持久化到cookie文件中主要看这个cookie的生命周期，和Max-Age或者Expires有关。 通过HTTP Header的Set-Cookie后者Set-Cookie2设置Cookie 123456789101112131415161718192021222324252627282930313233343536373839404142 //请求一个网址，即可分配到cookie AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; manager.responseSerializer = [AFJSONResponseSerializer new]; [manager GET:urlString parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //获取cookie NSArray *cookies = [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookies]; /* * 把cookie进行归档并转换为NSData类型 * 注意：cookie不能直接转换为NSData类型，否则会引起崩溃。 * 所以先进行归档处理，再转换为Data */ NSData *cookiesData = [NSKeyedArchiver archivedDataWithRootObject: [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookies]]; //存储归档后的cookie NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; [userDefaults setObject: cookiesData forKey: @\"cookie\"]; [self setCookie]; &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; &#125;]; - (void)setCookie&#123; //取出保存的cookie NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; //对取出的cookie进行反归档处理 NSArray *cookies = [NSKeyedUnarchiver unarchiveObjectWithData:[userDefaults objectForKey:@\"cookie\"]]; if (cookies) &#123; //设置cookie NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage]; for (id cookie in cookies) &#123; [cookieStorage setCookie:(NSHTTPCookie *)cookie]; &#125; &#125;else&#123; NSLog(@\"无cookie\"); &#125; &#125; 参考NSHTTPCookieStorage Cookies and Custom Protocols http://geeklu.com/2013/04/ios-cookie/ http://blog.it985.com/11248.html 《HTTP 权威指南》第11章 客户端识别与cookie机制 相关导引解决UIWebView和WKWebView之间的cookie共享问题： iOS开发-打通UIWebView和WKWebView的Cookie","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"Objective-C中的装饰模式","date":"2017-01-10T06:34:56.000Z","path":"2017/01/10/Objective-C中的装饰模式/","text":"背景前段时间接触到了装饰模式，也做了基本的了解，但是还不是很清楚它在iOS开发中的实际运用，和合理的存在方式。这两天看了《Objective-C编程之道：iOS设计模式解析》 中的第16章，有了更加深的理解，结合自己的理解在这里做一下记录。 什么是装饰模式就描述概念而言，我觉得《Head First 设计模式》这本书通过各种例子阐述得要更加详细易懂。《Objective-C编程之道：iOS设计模式解析》讲得更多是iOS开发中的使用和不同实现方式的对比。标准的装饰模式有包括一个抽象的Component父类，它声明了一些操作，它具体的类讲进行重载以实现自己特定的操作。这个Component具体类是模式中的被装饰者，Component父类可以被细化为另一个叫做Decorator的抽象类，即装饰者抽象类。Decorator类中包含了一个Component的引用。Decorator的具体类为Component或者Decorator定义了几个扩展行为，并且会在自己的操作中内嵌Component操作。关系图见 装饰模式类图 Component定义了一些抽象操作，具体类将进行重载实现自己特定的操作。Decorator抽象类通过将一个Component（或Decorator）内嵌到Decorator对象，定义了扩展这个Component的实例的“装饰性”的行为。 默认的operation方法只是想内嵌的Component发送一个消息，Decorator的具体实现类重载父类的operation，通过super把自己增加的行为扩展给Component的operation。如果只需要向Component添加一种职责，那可以省掉抽象的Decorator类，让具体的Decorator直接把请求转发给Component。那么这种方式就好像形成一种操作链，把一种行为加到另一种行为之上，如对象图 装饰模式类图 何时使用装饰模式 想要在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。 想要扩展一个类的行为，却做不到。类定义可能被隐藏，无法进行子类化；或者对类的每个行为的扩展，为支持每种功能组合，将产生大量的子类 对类的职责的扩展是可选的。 装饰模式在iOS中的实现根据Objective-C的特性，有两种实现方式： 通过真正的子类实现装饰 通过分类实现装饰 第二种方式是使用了Objective-C的语言功能，通过分类向类添加行为，不必进行子类化，这并非标准的装饰模式结构，但是实现了装饰模式同样的需求。尽管使用分类来实现装饰模式跟原始风格有偏离，但是实现少量的装饰器的时候，它比真正子类方式更加轻量、更加容易。 例子是使用装饰实现UIImage的滤镜功能 终于要见代码了~ 真子类实现装饰先看目录结构： Component抽象类是一个Protocol文件， 123456789@protocol ImageComponent &lt;NSObject&gt;@optional- (void)drawAsPatternInRect:(CGRect)rect;- (void)drawAtPoint:(CGPoint)point;- (void)drawAtPoint:(CGPoint)ponit blendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha;- (void)drawInRect:(CGRect)rect;- (void)drawInRect:(CGRect)rect blendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha;@end UIImage_ImageComponent.h是UIImage的一个Extension，让UIImage遵循ImageComponent协议。如此在装饰模式中UIImage类是ImageComponent抽象类的具体类，即UIImage是模式中的被装饰者。 Decorator抽象类ImageFilter遵守ImageComponent协议，并定义了三个方法和一个ImageComponent协议的代理对象属性。 1234567@interface ImageFilter : NSObject &lt;ImageComponent&gt;- (void)apply;- (id)initWithImageComponent:(id &lt;ImageComponent&gt;) component;- (id)forwardingTargetForSelector:(SEL)aSelector;- @end 123456789101112131415161718192021222324@interface ImageFilter ()@property (nonatomic, strong) id &lt;ImageComponent&gt; component;@end@implementation ImageFilter- (instancetype)initWithImageComponent:(id&lt;ImageComponent&gt;)component &#123; if (self = [super init]) &#123; [self setComponent:component]; &#125; return self;&#125;- (void)apply &#123; //由子类重载&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123; NSString *selectorName = NSStringFromSelector(aSelector); if ([selectorName hasPrefix:@\"draw\"]) &#123; [self apply]; &#125; return self.component;&#125;@end 在Decorator抽象类的具体实现类中去重载apply方法，当发送以”draw”开头的消息时，先执行Decorator具体类中的apply方法，然后再执行Component具体类即UIImage类（被装饰者）中的”draw”开头的那个方法。如此实现了对UIImage对应的”draw”开头方法动态添加行为。 具体的使用代码如下： 123456789101112131415- (void)viewDidLoad &#123; [super viewDidLoad]; UIImage *image = [UIImage imageNamed:@\"avatar.jpg\"]; CGAffineTransform rorateTransform = CGAffineTransformMakeRotation(-M_PI / 4); CGAffineTransform translateTransform = CGAffineTransformMakeTranslation(-image.size.width / 2.0, image.size.height / 8.0); CGAffineTransform finalTransform = CGAffineTransformConcat(rorateTransform, translateTransform); id&lt;ImageComponent&gt;transformdImage = [[ImageTransformFilter alloc] initWithImageComponent:image transform:finalTransform]; id&lt;ImageComponent&gt;finalImage = [[ImageShadowFliter alloc] initWithImageComponent:transformdImage]; DecoratorView *decoratorView = [[DecoratorView alloc] initWithFrame:self.view.frame]; [decoratorView setImage:finalImage]; [self.view addSubview:decoratorView];&#125; 由DecoratorView中的drawRect：调起UIImage的装饰 123456@implementation DecoratorViewduring animation.- (void)drawRect:(CGRect)rect &#123; [self.image drawInRect:rect];&#125;@end 类图如下: 各种ImageComponent对象可在运行时进行连接，如下图： 分类实现装饰分类方式实现就是平常开发中常见的使用，代码就不再一一列出 类图如下： BaseFilter分类中定义了绘图的方法，Transform和shadow分类中可以调用BaseFilter分类中定义的方法来进行自己的绘制。他们也可以像真正子类化方式那样链接起来，来看对象图: 总结装饰模式在Objective-C中有两种不同的实现方式，真正子类方式的实现使用一种较为结构化的方式链接各种装饰器，分类的方式更加简单和轻量，使用于现有类只需要少量装饰器的应用。 参考：《Objective-C编程之道：iOS设计模式解析》第16章，（190-206）demo地址：GitHub","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"继承与代理--Decorate Pattern","date":"2017-01-04T09:51:11.000Z","path":"2017/01/04/继承与代理-Decorate-Pattern/","text":"场景写这篇文章的背景是在看casatwy的网络层架构代码时对子类继承和协议代理方的实现产生了疑惑，进行了探索。 问题问题情景：父类的方法列表中和协议中有同样的方法（代码如下），子类继承方法同时代理方也实现协议方法，那么当父类调用decoratePatternTest这个方法时具体的执行方是谁？子类同时是代理方和不是代理方分别有什么样的情况呢？ 12345678910#import &lt;Foundation/Foundation.h&gt;@protocol BaseDecorateDelegate &lt;NSObject&gt;- (NSString *)decoratePatternTest;@end@interface BaseProtocolTest : NSObject@property (nonatomic, weak) id&lt;BaseDecorateDelegate&gt; decorate;- (NSString *)decoratePatternTest;- (void)startTest;@end casatwy注释在casatwy的代码中遇到上述问题的有BaseAPIManager拦截器代码部分，作者的注释如下： 1234567891011/* 拦截器的功能可以由子类通过继承实现，也可以由其它对象实现,两种做法可以共存 当两种情况共存的时候，子类重载的方法一定要调用一下super 然后它们的调用顺序是BaseManager会先调用子类重载的实现，再调用外部interceptor的实现 notes: 正常情况下，拦截器是通过代理的方式实现的，因此可以不需要以下这些代码 但是为了将来拓展方便，如果在调用拦截器之前manager又希望自己能够先做一些事情，所以这些方法还是需要能够被继承重载的 所有重载的方法，都要调用一下super,这样才能保证外部interceptor能够被调到 这就是decorate pattern */ 注释中提到： 子类继承和代理方实现协议可以共存 两种共存时子类重载的方法必须要调用父类方法 两者调用顺序是先实现子类重载的方法再调用代理方实现的方法 最后提到的是 Decorate Pattern 装饰者模式 分情况实现验证 子类继承父类方法 &amp; 子类没有遵守父类协议 &amp; 其他类遵守协议实现代理方法 子类继承父类方法 &amp; 遵守父类协议 父类方法： 123456789- (NSString *)decoratePatternTest &#123; NSLog(@\"执行父类decoratePatternTest\"); NSString *string = @\"基类中实现decoratePatternTest\"; if (self != self.decorate &amp;&amp; [self.decorate respondsToSelector:@selector(decoratePatternTest)]) &#123; string = [self.decorate decoratePatternTest]; &#125; return string;&#125; 子类方法： 123456- (NSString *)decoratePatternTest &#123; [super decoratePatternTest]; NSLog(@\"子类执行decoratePatternTest\"); return @\"子类中实现decoratePatternTest\";&#125; 非子类代理者方法： 12345- (NSString *)decoratePatternTest &#123; NSLog(@\"执行过代理方实现decoratePatternTest\"); return @\"代理方实现decoratePatternTest\";&#125; 测试结果： 父类 子类 Other 父类 子类 Other 遵守协议实现方法 - N Y - Y N 继承方法 - Y N - Y N 方法执行顺序 2 1 3 2 1 - 关键其实问题的关键是在代理者的协议方法调用的时机。 当子类继承了方法又是代理者，那么在父类方法中通过（self != self.decotate）来判断不用再去执行协议中的方法 子类不是代理者没有继承方法，则在父类方法中调用代理者执行协议方法 子类不是代理者但是继承了方法，父类调用代理者协议方法 两个方法的调其顺序是 子类中方法 -&gt; 父类中方法 -&gt; 代理者方法 两个方法中的有效代码执行顺序要看 子类方法中 super调用的位置 (super调用在子类有效代码前则 代理者方法的代码先执行)——-&gt;见最后一节Decorate Pattern 装饰者模式 代码中不用调用父类方法的情况作者的代码BaseAPIManager中的reformerParams方法在父类实例方法和协议方法中存在，但是子类继承实现时并不需要调用父类的 reformerParams，原因是父类中作了如下处理： 1234567891011121314151617181920212223242526272829303132333435- (instancetype)init&#123; self = [super init]; if (self) &#123; if ([self conformsToProtocol:@protocol(BaseProtocolDelegate)]) &#123; self.child = (id &lt;BaseProtocolDelegate&gt;)self; &#125; else &#123; NSException *exception = [[NSException alloc] init]; @throw exception; &#125; &#125; return self;&#125;- (NSString *)reformerParams &#123; NSLog(@\"执行父类reformerTest\"); IMP childIMP = [self.child methodForSelector:@selector(reformerTest)]; IMP selfIMP = [self methodForSelector:@selector(reformerTest)]; if (childIMP == selfIMP) &#123; return @\"子类没有继承此方法\"; &#125; else &#123; // 如果child是继承得来的，那么这里就不会跑到，会直接跑子类中的IMP。 // 如果child是另一个对象，就会跑到这里 NSString *result = nil; result = [self.child reformerParams]; if (result) &#123; return result; &#125; else &#123; return @\"default\"; &#125; &#125;&#125; 初始化方法中首先保证子类必须遵守了BaseProtocolDelegate协议 子类实现了reformerParams方法并没有调用super并不会出发父类的reformerParams 根据消息传递机制父类reformerParams 方法会被调用说明子类没有实现此方法，那么执行非子类代理者的协议方法 父类要求子类必须遵守协议，那么此协议BaseProtocolDelegate更多的用处是获取子类对象 Decorate Pattern 装饰者模式 装饰者模式动态地将责任附件到对象上，若要扩展功能，装饰着提供了比继承更具有弹性的方案。 装饰者模式的设计原则：可以随心为一个类扩展功能，但不允许对已经存在的代码进行修改。 装饰者模式的主要特点： 装饰者模式类图： 实际的例子：java中常用的java.io类就存在着大量装饰者 以上内容摘自《Head First设计模式》 第三章 装饰者模式 （79-107） 对应到iOS中本文的场景： 被装饰者 功能组件 装饰者 委托方父类 代理方OtherObject（非子类） 子类 其实在思考装饰者模式对应情况上，有点疑惑： 装饰者类Decorator没有找到对应的类 但装饰者模式中的关键点： 装饰者可以在被所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定目标。 在本文的例子中有明显体现：子类继承的方法中调用super方法，在这之前或者之后可以加上自己的行为，达到特定目标。 对装饰者模式的理解还比较基础有待继续研究……欢迎指正指导，谢谢！ iOS中装饰者模式的实现的后续研究请看Objective-C中的装饰模式","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"知识传送门","date":"2016-12-29T01:11:11.000Z","path":"2016/12/29/知识传送门/","text":"大神博客传送门 onevcat 喵神 王巍 sunnyxx 孙源 bang 没故事的卓同学 Casa Taloyum 唐巧 学习平台传送门 swifter.tips Objc中国 泊学 swiftv objc.io Swift学习指引 Google Interview University FreeCodeCamp iOS干货传送门 iOS 下关于 MD5 的那个坑 Xcode下调试神器——Chisel Swift和Objective混编攻略 Swift中编写单例的正确方式 xib的全方位使用技巧 书籍 程序员书单","tags":[{"name":"随笔","slug":"随笔","permalink":"http://huyangjie.com//tags/随笔/"}]},{"title":"JSPatch学习分享","date":"2016-12-23T02:38:08.000Z","path":"2016/12/23/JSPatch学习分享/","text":"App热更新技术——JSPatch学习分享 如果不清楚本文的主角 JSPatch是什么请看我博客中的JSPatch学习笔记： 这里 和 这里 背景iOS Developer Program License Agreement里3.3.2提到不可动态下发可执行代码，但通过苹果JavaScriptCore.framework或WebKit执行的代码除外，JS正是通过JavaScriptCore.framework执行的。 基础原理JSPatch 能做到通过 JS 调用和改写 OC 方法最根本的原因是 Objective-C 是动态语言，OC 上所有方法的调用/类的生成都通过 Objective-C Runtime 在运行时进行，我们可以通过类名/方法名反射得到相应的类和方法： 1234Class class = NSClassFromString(\"UIViewController\");id viewController = [[class alloc] init];SEL selector = NSSelectorFromString(\"viewDidLoad\");[viewController performSelector:selector]; 也可以替换某个类的方法为新的实现： 12static void newViewDidLoad(id slf, SEL sel) &#123;&#125;class_replaceMethod(class, selector, newViewDidLoad, @\"\"); 还可以新注册一个类，为类添加方法： 123Class cls = objc_allocateClassPair(superCls, \"JPObject\", 0);objc_registerClassPair(cls);class_addMethod(cls, selector, implement, typedesc); 理论上可以在运行时通过类名/方法名调用到任何 OC 方法，替换任何类的实现以及新增任意类。JSPatch 的基本原理就是：JS 传递字符串给 OC，OC 通过 Runtime 接口调用和替换 OC 方法。 JSPatch实现原理详解 Demo展示demo地址 疑问：热修复都需要重启App后才能生效吗？ demo 中对以上疑问有实现，具体的原理理解下一节 方法替换 对demo代码的具体解释请看 这里 方法替换OC上，每个类底层都是这样一个结构体： 123456789101112struct objc_class &#123; Class isa; Class super_class; const char *name; long version; long info; long instance_size; struct objc_ivar_list *ivars; struct objc_method_list **methodLists; /*方法链表*/ struct objc_cache *cache; struct objc_protocol_list *protocols; &#125; 其中 methodList 方法链表里存储的是 Method 类型： 123456typedef struct objc_method *Method;typedef struct objc_ method &#123; SEL method_name; char *method_types; IMP method_imp;&#125;; Method 保存了一个方法的全部信息，包括 SEL 方法名，type 各参数和返回值类型，IMP 该方法具体实现的函数指针。 通过 Selector 调用方法时，会从 methodList 链表里找到对应Method进行调用，这个 methodList 上的的元素是可以动态替换的，可以把某个 Selector 对应的函数指针IMP替换成新的，也可以拿到已有的某个 Selector 对应的函数指针IMP，让另一个 Selector 跟它对应，Runtime 提供了一些接口做这些事 JSPatch脚本文件下发加密接入 JSPatch 时做 RSA 非对称加密传输 开发者自己在 APP 接入 JSPatch，若开发者没有针对传输的 JSPatch 脚本加密。攻击者就通过网络传输的中间人攻击手段下发恶意脚本到用户APP 动态更新方案对比：JSPatch vs React Native 学习成本 React Native 是从 web 前端开发框架 React 延伸出来的解决方案，主要解决的问题是web页面在移动端性能低的问题。若使用React Native，就意味着iOS开发者需要学习web前端的一整套开发技能 JSPatch 是从终端开发出发的一种方案，JSPatch 写出来的代码风格与 OC 原生开发一致，加上一点 JS 语法的了解，就可以使用 接入成本 React Native 需要搭建一套开发环境，有很多依赖的库。React Native 是比较大的框架，据统计目前核心代码里 OC 和 JS 代码加起来有4w行，接入后安装包体积增大 1.8M 左右 JSPatch 是微型框架，只有 3 个文件 2k 行代码，接入后增大 100K 左右 开发效率 React Native 用近似 HTML+CSS 去绘制 UI，这方面开发效率相对 JSPatch 会高些，另外React Native 在开发效率上的另一个优势是支持跨平台，React Native 本意是复用逻辑层代码，UI 层根据不同平台写不同的代码 JSPatch 也可以借助 iOS 一些成熟的库去提高效率，例如使用 Massory。（尝试了其实也是相当吃力） 热更新能力 React Native 在热更新时无法使用事先没有做过桥接的原生组件 JSPatch 可以调用到任意已在项目里的组件，以及任意原生 framework 接口 方案对比表格： 学习成本 接入成本 热更新能力 开发效率 性能体验 JSPatch 低 低 高 中，不跨平台 高 React Native 高 高 中 高，跨平台 高 JSPatch vs Wax 对JSPatch的思考 进行热更新后下一个版本需要将JS代码修改为原生代码，不能停留超过一个版本。 编写JS脚本文件，调用OC原生的方法（方法名长得可怕）没有代码补全提示和高亮，显得非常吃力。 当要进行热修复的方法是一个代码量很大的方法，需要用JS重写这个方法，这会很痛苦。 新方案 : DynamicCocoa优势所在： 使用原生技术栈：使用者完全不用接触到 JS 或任何中间代码，保持原生的 Objective-C 开发、调试方式不变 无需重写已有代码：已有 native 模块能很方便的变成动态化插件 语法支持完备性高：支持绝大多数日常开发中用到的语法，不用担心这不支持那不支持 支持 HotPatch：改完 bug 后直接从源码打出 patch，一站式解决动态化和热修复需求 资源的支持,动态 bundle 支持： xib 和 storyboard xcassets 不放在 xcassets 里的图片资源 其他资源文件 DynamicCocoa：滴滴 iOS 动态化方案的诞生与起航","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"Objective-C Isa指针","date":"2016-12-19T05:52:37.000Z","path":"2016/12/19/Objective-C-isa指针/","text":"1. 什么是isa指针首先来看一下，NSObject的定义（不含方法定义）： 123@interface NSObject &lt;NSObject&gt; &#123; Class isa;&#125; 在Objective-C中，@interface关键字可以看着是C语言中的struct关键字的别名，当然他还会有一些其它功能，比如说让编译器知道@interface后后面的是一个Objective-C的类的名字等。但就我们研究其内存布局来说，我们简单地将其替换为struct，并将protocal定义去掉。因此，NSObject的定义就是样： 123struct NSObject&#123; Class isa;&#125; 那个这个Class又是什么呢？在objc.h中我们发现其仅仅是一个结构(struct)指针的typedef定义: typedefstruct objc_class *Class; 因此，NSObject的定义就像这个样子： 123struct NSObject&#123; objc_class *isa&#125; isa就是“is a”，对于所有继承了NSObject的类其对象也都有一个isa指针。这个isa指针指向的东西(先这样称呼它吧)就是关于这个对象所属的类的定义。 每一个Objective-C对象的底层都是这样的一个C结构体： 123456struct objc_class &#123; struct objc_class * isa; const char *name; …. struct objc_method_list **methodLists; /*方法链表*/&#125;; 这个结构体中的第一个成员变量，就是isa指针。 2. isa指针的指向实例对象的isa指针指向是其所属的类对象，这个类对象包含了该实例对象的一些信息（例如：实例列表、方法列表等）。isa指针的类型是还是一个结构体 objc_class 其实也就是指向地址的类对象的结构，接下来看下 该objc_class的具体结构： 1234567891011121314151617struct objc_class &#123; Class isa; Class super_class; const char *name; long version; long info; long instance_size; struct objc_ivar_list *ivars; struct objc_method_list **methodLists; struct objc_cache *cache; struct objc_protocol_list *protocols; &#125; 一个objc_class对象包括一个类的：父类定义(super_class), 变量列表，方法列表，还有实现了哪些协议(Protocal) 这个结构中还有一个isa指针，它在这里（类对象中）指向的是元类对象(metaclass object)。在Objective-C中任何的类定义都是对象。即在程序启动的时候任何类定义都对应于一块内存。在编译的时候，编译器会给每一个类生成一个且只生成一个”描述其定义的对象”,也就是水果公司说的类对象(class object),他是一个单例(singleton), 而我们在C++等语言中所谓的对象，叫做实例对象(instance object)。对于实例对象我们不难理解，但类对象(class object)是干什么吃的呢？我们知道Objective-C是门很动态的语言，因此程序里的所有实例对象(instace objec)都是在运行时由Objective-C的运行时库生成的，而这个类对象(class object)就是运行时库用来创建实例对象(instance object)的依据。 任何直接或间接继承了NSObject的类，它的实例对象(instacne objec)中都有一个isa指针，指向它的类对象(class object)。这个类对象(class object)中存储了关于这个实例对象(instace object)所属的类的定义的一切：包括变量，方法，遵守的协议等等。 这个实例对象(instance object)的isa指针指向的类对象(class object)里面还有一个isa呢？ 这个类对象(class objec)的isa指向的依然是一个objc-class，它就是“元类对象”(metaclass object)，它和类对象(class object)的关系是这样的: 类对象(class object)中包含了类的实例变量，实例方法的定义，而元类对象(metaclass object)中包括了类的类方法(也就是C++中的静态方法)的定义。类对象和元类对象中水果公司当然还会包含一些其它的东西，以后也可能添加其它的内容，但对于我们了解其内存布局来说，只需要记住：类对象存的是关于实例对象的信息(变量，实例方法等)，而元类对象(metaclass object)中存储的是关于类的信息(类的版本，名字，类方法等)。要注意的是，类对象(class object)和元类对象(metaclass object)的定义都是objc_class结构，其不同仅仅是在用途上，比如其中的方法列表在类对象(instance object)中保存的是实例方法(instance method)，而在元类对象(metaclass object)中则保存的是类方法(class method)。 3. 图例说明图中可以看出，D3继承D2,D2继承D1,D1最终继承NSObject。下图从D3的一个对象开始，排列出D3 D2 D1 NSObject 类对象，元类对象等关系。 图中的箭头都是指针的指向。 参考： Objective-C内存布局 Objective-C Runtime","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"JSPatch学习笔记(二)","date":"2016-12-19T01:14:01.000Z","path":"2016/12/19/JSPatch学习笔记-二/","text":"这次笔记中主要描述的有： JSPath原理理解（学习作者大牛博客） JSPatch使用的时机 AppDelegate中更新JS文件后何时生效 其他时机手动更新JS文件的效果 JS调用OC方法中的几个坑 JS脚本文件的版本控制管理 更多思考 1. JSPatch原理浅谈JSPatch用iOS内置的JavaScriptCore.framework作为JS引擎，但没有用它JSExport的特性进行JS-OC函 数互调，而是通过Objective-C Runtime，从JS传递要调用的类名函数名到Objective-C，再使用NSInvocation动态调用对应的OC方法。 详细原理介绍可见作者博客:JSPatch 实现原理详解 另外JSPatch已经有商业化的平台jspatch.com，可以使用里面的SDK，通过这个平台上传的js脚本都存储在七牛云。 2. JSPatch使用的时机确切地说应该是在经过怎样的流程之后开始载入调用JS脚本。在董铂然的博客:JSPatch使用小记中有这样的一套方案： 这个方案的特点： 添加了上次请求的时间，避免多余的网络请求 把更新js脚本的代码放在了applicationDidBecomeActive:方法中，避免程序在后台的时候也进行不必要的脚本更新检查。 对js文件进行code校验，避免传输过程中被修改。实际使用中应对js脚本文件进行加密。（作者的博客中也建议用RSA等非对称加密对文件进行加密传输） 连续崩溃次数的判断，能够做到程序自我选择性修复 3. AppDelegate中更新JS文件后何时生效当经过本文第二点中流程之后，本地载入了最新的js脚本文件，那么程序什么时候会使用这个脚本中的代码呢？为此我写了demo测试： AppDelegate中的代码 判断本地是否存在hotfix.js文件： 123456789101112- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; NSString *docuPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; NSString *hotfixPath = [docuPath stringByAppendingPathComponent:@\"hotfix.js\"]; if ([[NSFileManager defaultManager] fileExistsAtPath:hotfixPath]) &#123; [JPEngine startEngine]; NSString *script = [NSString stringWithContentsOfFile:hotfixPath encoding:NSUTF8StringEncoding error:nil]; [JPEngine evaluateScript:script]; &#125; return YES;&#125; 检测是否需要更新： 12345678910111213141516171819202122- (void)applicationDidBecomeActive:(UIApplication *)application &#123; // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface. [HotFixManager checkUpdateCompleteHandle:^(BOOL status, NSString *response, NSError *error) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if (!status)&#123; if (!error) &#123; NSLog(@\"没有更新\"); &#125; else &#123; NSLog(@\"%@\", error.userInfo); &#125; return ; &#125; NSLog(@\"Hotfix文件更新成功\"); [JPEngine startEngine]; NSString *script = [NSString stringWithContentsOfFile:response encoding:NSUTF8StringEncoding error:nil]; [JPEngine evaluateScript:script]; &#125;); &#125;]; &#125; 首先第一点可以确定的是：判断本地是否存在js文件需要加载的代码不能够写在网络请求是否需要更新的回调中原因：首先看下我的hotfix.js文件中的代码 1234567891011121314151617181920212223defineClass('JSPatchController', [/*新增的属性*/'updateLabel'], &#123;//实例方法 viewDidLoad: function() &#123;// self.ORIGviewDidLoad() self.setTitle(\"测试JS1\") self.view().addSubview(self.getUpdateLabel()) &#125;, //实现Label的getter方法 getUpdateLabel: function() &#123; var _updateLabel = self.updateLabel() if (!_updateLabel) &#123; _updateLabel = require('UILabel').alloc().init() _updateLabel.setFrame(&#123;x:50, y:100, width:100, height:30&#125;) _updateLabel.setText(\"点击按钮更新JS代码---&gt;\") _updateLabel.setFont(require('UIFont').systemFontOfSize(15)) _updateLabel.setTextColor(require('UIColor').redColor()) _updateLabel.sizeToFit() self.setUpdateLabel(_updateLabel) &#125; return _updateLabel &#125;,&#125;) 代码中是有添加了updateLabel这样一个属性，并添加到JSPatchController的视图中，其中JSPatchController为window下navigationController的rootViewController。 当我尝试在检查更新的block没有更新的区块中执行 123[JPEngine startEngine]; NSString *script = [NSString stringWithContentsOfFile:hotfixPath encoding:NSUTF8StringEncoding error:nil]; [JPEngine evaluateScript:script] 发现JSPatchController并没有添加上updateLabel，起初以为是没有回到主线程中更新视图，经过尝试并不是。当执行NSURLSessionDataTask的网络请求后，会新开启一个线程。而主线程继续执行编译JSPatchController，当新的线程中的网络请求完成了，然后加载了js脚本文件，此时已经不能再对JSPatchController动态添加updateLabel了。 第二点：didFinishLaunchingWithOptions: 的执行优先级是高于applicationDidBecomeActive:方法的，检查本地的js文件应发在前者中。 第三点： applicationDidBecomeActive: 方法中检测需要更新并下载了js脚本文件，但是只有下一次启动App的时候才能生效 在根控制器中的动态修改代码只能下一次启动App的时候才能生效。 4. 其他时机手动更新JS文件的效果其他时机这里指的是例如UIControl事件，点击按钮后更新js脚本，那么这个脚本文件中的代码何时生效呢？在demo中的JSPatchController中 “更新JS” 这个按钮，点击执行的代码如下： 123456789101112131415161718- (IBAction)updateJS:(UIButton *)sender &#123; sender.selected = !sender.isSelected; NSString *url = sender.isSelected ? jsfile1 : jsfile2; [sender setTitle:@\"当前JS1\" forState:UIControlStateSelected]; [sender setTitle:@\"当前JS2\" forState:UIControlStateNormal]; NSLog(@\"下载的是%@\",url); [HotFixManager downLoadHotFixJSfileWithURL:url completeHandle:^(BOOL status, id response, NSError *error) &#123; if (!status)&#123; NSLog(@\"下载出错\\n%@\", error.userInfo); return ; &#125; NSLog(@\"Hotfix文件更新成功\"); [JPEngine startEngine]; NSString *script = [NSString stringWithContentsOfFile:response encoding:NSUTF8StringEncoding error:nil]; [JPEngine evaluateScript:script]; &#125;];&#125; 点按按钮有两个js脚本文件可以进行切换，两个js文件中的区别部分为对下一个控制器中的lable文字和navigation title的控制 jsfile1： 12345678defineClass('SecondViewController', &#123; viewDidLoad: function() &#123; self.ORIGviewDidLoad() var label = self.myLabel() label.setText(\"这是在JS1中修改的文字\") self.setTitle(\"JS1推出的页面\") &#125; &#125;) jsfile2: 12345678defineClass('SecondViewController', &#123; viewDidLoad: function() &#123; self.ORIGviewDidLoad() var label = self.myLabel() label.setText(\"这是在JS2中修改的文字\") self.setTitle(\"JS2推出的页面\") &#125; &#125;) 测试结果是：更新的js脚本中对之后的页面的js修复代码是可以生效的，但是对之前的页面跟同级的页面是没有效果的。 其实这些，只要搞清楚原理就都能知道缘由和规律。 5. JS调用OC方法中的几个坑 在js中 NSNumber不需要在处理，可直接当数值使用。 NSRang 初始化：var range = {location: 0, length: senderName.length()}; 无论变量还是方法，单下划线全部改为双下划线 CGRect 取宽高， 直接rect.width, 不用rect.size.width。其他结构体类似 js 中 YES 为 ture，NO 为false oc对象转js对象可操作toJS()，js对象转oc对象暂时没找到方法。js内创建的字典为js对象，传入oc方法无效 jspatch 不支持变参方法，如stringWithFormat:，可用js字符串方法或NSMutableString代替。 6. JS脚本文件的版本控制管理一般使用的js脚本文件都是从服务器下发过来，服务器的接口需要返回时候需要更新的参数，需要则下载于当前程序版本号对应版本的js脚本文件。对于多个版本的项目来说，js脚本文件最好也进行版本控制避免出错，可以在服务器单独建立js脚本文件的Git仓库来进行管理。 7. 更多思考 JS热修复的代码在下一次更新中应当使用原生的代码替换，不能超过一个版本。避免对JSPatch有过多的依赖 使用JS语法来调用OC的方法，没有代码自动补全显得非常吃力。作者bang开发了Xcode插件：JSPatchX，然而Xcode8不支持插件了。。。 在一个很复杂的方法中,仅中间某一行代码需要修改,就要将整个方法用JS重写一遍,推介作者开发的Objective-C转JavaScript代码工具JSPatch Convertor,但一些复杂的语法还是要人工修正","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"JSPatch学习笔记(一)","date":"2016-12-19T01:09:29.000Z","path":"2016/12/19/JSPatch学习笔记-一/","text":"什么是JSPatchJSPatch 是一个开源项目(Github链接)，只需要在项目里引入极小的引擎文件，就可以使用 JavaScript 调用任何 Objective-C 的原生接口，替换任意 Objective-C 原生方法。目前主要用于下发 JS 脚本替换原生 Objective-C 代码，实时修复线上 bug。 理解下来类似于运行时的Method Swizzling，动态地将需要修复的bug代码替换成更新的代码。不同的是JSPatch使用JavaScript来进行热修复，可以在App上线的状态下替换App内的JS文件从而可以随心所欲修改和替换原有的方法，达到热修复的效果。 JSPatch的使用Github项目主页上介绍可以通过pod导入的方式加入项目，手动管理也仅仅是需要添加三个文件到项目既可使用。 InstallationCocoaPodsCocoaPods is a dependency manager for Objective-C, which automates and simplifies the process of using 3rd-party libraries like JSPatch in your projects. See the “Getting Started” guide for more information. 123# Your Podfileplatform :ios, &apos;6.0&apos;pod &apos;JSPatch&apos; ManuallyCopy JSEngine.m JSEngine.h JSPatch.js in JSPatch/ to your project. 使用JS调用原生API的的JS语法在项目主页上也有文档。 其中最关键的就是这个API： 12345defineClass(classDeclaration, [properties,] instanceMethods, classMethods) @param classDeclaration: 字符串，类名/父类名和Protocol @param properties: 新增property，字符串数组，可省略 @param instanceMethods: 要添加或覆盖的实例方法 @param classMethods: 要添加或覆盖的类方法 例子： 1234567defineClass('JPViewController', &#123; handleBtn: function(sender) &#123; //self.ORIGhandleBtn() var tableViewCtrl = JPTableViewController.alloc().init() self.navigationController().pushViewController_animated(tableViewCtrl, YES) &#125;&#125;) 代码作用是：替换JPViewController 类中的 handleBtn: 方法，并可以self.ORIGhandleBtn()选择执行原OC中的此方法，这就是修复（替换）bug代码。 在熟悉语法使用的过程中主要（暂时）遇到了如下几个问题（比较容易犯错）： OC中的 self.view 和 self.navigationController 之类在这里都需要调用它们的getter方法来达到相同效果如self.view() 在OC中写惯了的 label.text = @&quot;text&quot;之类都要使用setter方法label.setText(&quot;text&quot;) 总结上面两条就是访问和赋值属性都要通过调用方法来实现 在JS代码中添加属性，重写getter方法时，需要自己创建局部变量，不在有自动生成的_ivar可以使用 后话：方法名不再有补全提示千万不要写错了 正在继续学习……","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]},{"title":"iOS10新特性适配总结","date":"2016-12-16T00:45:51.000Z","path":"2016/12/16/iOS10新特性适配总结/","text":"1. Notification(通知)自从Notification被引入之后，苹果就不断的更新优化，但这些更新优化只是小打小闹，直至现在iOS 10开始真正的进行大改重构，这让开发者也体会到UserNotifications的易用，功能也变得非常强大。 iOS 9 以前的通知 在调用方法时，有些方法让人很难区分，容易写错方法，这让开发者有时候很苦恼。 应用在运行时和非运行时捕获通知的路径还不一致。 应用在前台时，是无法直接显示远程通知，还需要进一步处理。 已经发出的通知是不能更新的，内容发出时是不能改变的，并且只有简单文本展示方式，扩展性根本不是很好。 iOS 10 开始的通知 所有相关通知被统一到了UserNotifications.framework框架中。 增加了撤销、更新、中途还可以修改通知的内容。 通知不在是简单的文本了，可以加入视频、图片，自定义通知的展示等等。 iOS 10相对之前的通知来说更加好用易于管理，并且进行了大规模优化，对于开发者来说是一件好事。 iOS 10开始对于权限问题进行了优化，申请权限就比较简单了(本地与远程通知集成在一个方法中)。 如果使用了推送，修改如图： 2. ATS的问题iOS 9中默认非HTTS的网络是被禁止的，当然我们也可以把NSAllowsArbitraryLoads设置为YES禁用ATS。不过iOS 10从2017年1月1日起苹果不允许我们通过这个方法跳过ATS，也就是说强制我们用HTTPS，如果不这样的话提交App可能会被拒绝。但是我们可以通过NSExceptionDomains来针对特定的域名开放HTTP可以容易通过审核。 NSExceptionDomains方式 设置域。可以简单理解成，把不支持https协议的接口设置成http的接口。 具体方法： 在项目的info.plist中添加一个Key：App Transport Security Settings，类型为字典类型。 然后给它添加一个Exception Domains，类型为字典类型； 把需要的支持的域添加給Exception Domains。其中域作为Key，类型为字典类型。 每个域下面需要设置3个属性：NSIncludesSubdomains、NSExceptionRequiresForwardSecrecy、NSExceptionAllowsInsecureHTTPLoads。 如图：细节提示:在iOS9以后的系统中如果使用到网络图片，也要注意网络图片是否是HTTP的哦，如果是，也要把图片的域设置哦！ 3. iOS 10 隐私权限设置iOS 10 开始对隐私权限更加严格，如果你不设置就会直接崩溃，现在很多遇到崩溃问题了，一般解决办法都是在info.plist文件添加对应的Key-Value就可以了。以上Value值，圈出的红线部分的文字是展示给用户看的，必须添加。 4. Xcode 8 运行一堆没用的logs解决办法 上图我们看到，自己新建的一个工程啥也没干就打印一堆烂七八糟的东西，我觉得这个应该是Xcode 8的问题， 具体也没细研究，解决办法是设置OS_ACTIVITY_MODE : disable如下图:第一步：第二步：第三步：添加参数：Name ：OS_ACTIVITY_MODEValue : disable 5. iOS 10 UIStatusBar方法过期:在我们开发中有可能用到UIStatusBar一些属性，在iOS 10 中这些方法已经过期了，如果你的项目中有用的话就得需要适配。 上面的图片也能发现，如果在iOS 10中你需要使用preferredStatusBar比如这样： //iOS 10 - (UIStatusBarStyle)preferredStatusBarStyle { return UIStatusBarStyleDefault; } 6. iOS 10 UICollectionView 性能优化随着开发者对UICollectionView的信赖，项目中用的地方也比较多，但是还是存在一些问题，比如有时会卡顿、加载慢等。所以iOS 10 对UICollectionView进一步的优化。 UICollectionView cell pre-fetching预加载机制 UICollectionView and UITableView prefetchDataSource 新增的API 针对self-sizing cells 的改进 Interactive reordering 在iOS 10 之前,UICollectionView上面如果有大量cell,当用户活动很快的时候,整个UICollectionView的卡顿会很明显,为什么会造成这样的问题,这里涉及到了iOS 系统的重用机制,当cell准备加载进屏幕的时候,整个cell都已经加载完成,等待在屏幕外面了,也就是整整一行cell都已经加载完毕,这就是造成卡顿的主要原因,专业术语叫做:掉帧.要想让用户感觉不到卡顿,我们的app必须帧率达到60帧/秒,也就是说每帧16毫秒要刷新一次. iOS 10 之前UICollectionViewCell的生命周期是这样的: 用户滑动屏幕,屏幕外有一个cell准备加载进来,把cell从reusr队列拿出来,然后调用prepareForReuse方法,在这个方法里面,可以重置cell的状态,加载新的数据; 继续滑动,就会调用cellForItemAtIndexPath方法,在这个方法里面给cell赋值模型,然后返回给系统; 当cell马上进去屏幕的时候,就会调用willDisplayCell方法,在这个方法里面我们还可以修改cell,为进入屏幕做最后的准备工作; 执行完willDisplayCell方法后,cell就进去屏幕了.当cell完全离开屏幕以后,会调用didEndDisplayingCell方法.iOS 10 UICollectionViewCell的生命周期是这样的: 用户滑动屏幕,屏幕外有一个cell准备加载进来,把cell从reusr队列拿出来,然后调用prepareForReuse方法,在这里当cell还没有进去屏幕的时候,就已经提前调用这个方法了,对比之前的区别是之前是cell的上边缘马上进去屏幕的时候就会调用该方法,而iOS 10 提前到cell还在屏幕外面的时候就调用; 在cellForItemAtIndexPath中创建cell，填充数据，刷新状态等操作,相比于之前也提前了; 用户继续滑动的话,当cell马上就需要显示的时候我们再调用willDisplayCell方法,原则就是:何时需要显示,何时再去调用willDisplayCell方法; 当cell完全离开屏幕以后,会调用didEndDisplayingCell方法,跟之前一样,cell会进入重用队列.在iOS 10 之前,cell只能从重用队列里面取出,再走一遍生命周期,并调用cellForItemAtIndexPath创建或者生成一个cell.在iOS 10 中,系统会cell保存一段时间,也就是说当用户把cell滑出屏幕以后,如果又滑动回来,cell不用再走一遍生命周期了,只需要调用willDisplayCell方法就可以重新出现在屏幕中了.iOS 10 中,系统是一个一个加载cell的,二以前是一行一行加载的,这样就可以提升很多性能;iOS 10 新增加的Pre-Fetching预加载这个是为了降低UICollectionViewCell在加载的时候所花费的时间,在 iOS 10 中,除了数据源协议和代理协议外,新增加了一个UICollectionViewDataSourcePrefetching协议,这个协议里面定义了两个方法: 1 - (void)collectionView:(UICollectionView *)collectionView prefetchItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths NS_AVAILABLE_IOS(10_0; 1 - (void)collectionView:(UICollectionView *)collectionView cancelPrefetchingForItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths NS_AVAILABLE_IOS(10_0; 在ColletionView prefetchItemsAt indexPaths这个方法是异步预加载数据的,当中的indexPaths数组是有序的,就是item接收数据的顺序; CollectionView cancelPrefetcingForItemsAt indexPaths这个方法是可选的,可以用来处理在滑动中取消或者降低提前加载数据的优先级. 注意:这个协议并不能代替之前读取数据的方法,仅仅是辅助加载数据. Pre-Fetching预加载对UITableViewCell同样适用. 7. iOS 10 UIColor 新增方法以下是官方文档的说明： Most graphics frameworks throughout the system, including Core Graphics, Core Image, Metal, and AVFoundation, have substantially improved support for extended-range pixel formats and wide-gamut color spaces. By extending this behavior throughout the entire graphics stack, it is easier than ever to support devices with a wide color display. In addition, UIKit standardizes on working in a new extended sRGB color space, making it easy to mix sRGB colors with colors in other, wider color gamuts without a significant performance penalty. Here are some best practices to adopt as you start working with Wide Color. In iOS 10, the UIColor class uses the extended sRGB color space and its initializers no longer clamp raw component values to between 0.0 and 1.0. If your app relies on UIKit to clamp component values (whether you’re creating a color or asking a color for its component values), you need to change your app’s behavior when you link against iOS 10. When performing custom drawing in a UIView on an iPad Pro (9.7 inch), the underlying drawing environment is configured with an extended sRGB color space. If your app renders custom image objects, use the new UIGraphicsImageRenderer class to control whether the destination bitmap is created using an extended-range or standard-range format. If you are performing your own image processing on wide-gamut devices using a lower level API, such as Core Graphics or Metal, you should use an extended range color space and a pixel format that supports 16-bit floating-point component values. When clamping of color values is necessary, you should do so explicitly. Core Graphics, Core Image, and Metal Performance Shaders provide new options for easily converting colors and images between color spaces. 因为之前我们都是用RGB来设置颜色，反正用起来也不是特别多样化，这次新增的方法应该就是一个弥补吧。所以在iOS 10 苹果官方建议我们使用sRGB，因为它性能更好，色彩更丰富。如果你自己为UIColor写了一套分类的话也可尝试替换为sRGB，UIColor类中新增了两个Api如下: 123+ (UIColor *)colorWithDisplayP3Red:(CGFloat)displayP3Red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha NS_AVAILABLE_IOS(10_0);- (UIColor *)initWithDisplayP3Red:(CGFloat)displayP3Red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha NS_AVAILABLE_IOS(10_0); 8. iOS 10 UITextContentType// The textContentType property is to provide the keyboard with extra information about the semantic intent of the text document.@property(nonatomic,copy) UITextContentType textContentType NS_AVAILABLE_IOS(10_0); // default is nil 在iOS 10 UITextField添加了textContentType枚举，指示文本输入区域所期望的语义意义。 使用此属性可以给键盘和系统信息，关于用户输入的内容的预期的语义意义。例如，您可以指定一个文本字段，用户填写收到一封电子邮件确认uitextcontenttypeemailaddress。当您提供有关您期望用户在文本输入区域中输入的内容的信息时，系统可以在某些情况下自动选择适当的键盘，并提高键盘修正和主动与其他文本输入机会的整合。 9. iOS 10 字体随着手机系统字体而改变当我们手机系统字体改变了之后，那我们App的label也会跟着一起变化，这需要我们写很多代码来进一步处理才能实现，但是iOS 10 提供了这样的属性adjustsFontForContentSizeCategory来设置。因为没有真机，具体实际操作还没去实现，如果理解错误帮忙指正。 UILabel *myLabel = [UILabel new]; /* UIFont 的preferredFontForTextStyle: 意思是指定一个样式，并让字体大小符合用户设定的字体大小。 12345myLabel.font =[UIFont preferredFontForTextStyle: UIFontTextStyleHeadline];/*Indicates whether the corresponding element should automatically update its font when the device’s UIContentSizeCategory is changed.For this property to take effect, the element’s font must be a font vended using +preferredFontForTextStyle: or +preferredFontForTextStyle:compatibleWithTraitCollection: with a valid UIFontTextStyle.*/ //是否更新字体的变化 myLabel.adjustsFontForContentSizeCategory = YES; 10. iOS 10 UIScrollView新增refreshControliOS 10 以后只要是继承UIScrollView那么就支持刷新功能： @property (nonatomic, strong, nullable) UIRefreshControl *refreshControl NS_AVAILABLE_IOS(10_0) __TVOS_PROHIBITED; 11. iOS 10 判断系统版本正确姿势判断系统版本是我们经常用到的，尤其是现在大家都有可能需要适配iOS 10，那么问题就出现了，如下图：我们得到了答案是： //值为 1 [[[[UIDevice currentDevice] systemVersion] substringToIndex:1] integerValue] //值为10.000000 [[UIDevice currentDevice] systemVersion].floatValue, //值为10.0[[UIDevice currentDevice] systemVersion] 所以说判断系统方法最好还是用后面的两种方法，哦~我忘记说了[[UIDevice currentDevice] systemVersion].floatValue这个方法也是不靠谱的，好像在8.3版本输出的值是8.2，记不清楚了反正是不靠谱的，所以建议大家用[[UIDevice currentDevice] systemVersion]这个方法！ Swift判断如下：1234if #available(iOS 10.0, *) &#123; // iOS 10.0 print(\"iOS 10.0\"); &#125; else &#123; &#125; 12. Xcode 8 插件不能用的问题大家都升级了Xcode 8，但是对于插件依赖的开发者们，一边哭着一边去网上寻找解决办法。那么下面是解决办法：让你的 Xcode8 继续使用插件(http://vongloo.me/2016/09/10/Make-Your-Xcode8-Great-Again/?utm_source=tuicool&amp;utm_medium=referral ) 但是看到文章最后的解释，我们知道如果用插件的话，可能安全上会有问题、并且提交审核会被拒绝，所以建议大家还是不要用了，解决办法总是有的，比如在Xcode中添加注释的代码块也是很方便的。 13. iOS 10开始项目中有的文字显示不全问题我用Xcode 8 和Xcode 7.3分别测试了下，如下图： Xcode 8 Xcode7 创建一个Label然后让它自适应大小，字体大小都是17最后输出的宽度是不一样的，我们再看一下，下面的数据就知道为什么升级iOS 10 之后App中有的文字显示不全了： 英文字母会不会也有这种问题，我又通过测试，后来发现英文字母没有问题，只有汉字有问题。目前只有一个一个修改控件解决这个问题，暂时没有其他好办法来解决。 14. Xcode 8使用Xib awakeFromNib的警告问题在Xcode 8之前我们使用Xib初始化- (void)awakeFromNib {}都是这么写也没什么问题，但是在Xcode 8会有如下警告： 官方解释： You must call the super implementation of awakeFromNib to give parent classes the opportunity to perform any additional initialization they require.Although the default implementation of this method does nothing, many UIKit classes provide non-empty implementations.You may call the super implementation at any point during your own awakeFromNib method. 你必须调用父类实现awakeFromNib来给父类来执行它们需要的任何额外的初始化的机会。虽然这种方法的默认实现不做任何事情，许多UIKit类提供非空的实现。你可以调用自己的awakeFromNib方法中的任何时候超级实现。 15. 推送的时候，开启Remote notificationsYou&apos;ve implemented -[&lt;UIApplicationDelegate&gt; application:didReceiveRemoteNotification:fetchCompletionHandler:], but you still need to add &quot;remote-notification&quot; to the list of your supported UIBackgroundModes in your Info.plist.* 解决方案：需要在Xcode 中修改应用的 Capabilities 开启Remote notifications，请参考下图： 16. One of the two will be used. Which one is undefined.objc[5114]: Class PLBuildVersion is implemented in both /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/AssetsLibraryServices.framework/AssetsLibraryServices (0x1109a5910) and /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/PhotoLibraryServices.framework/PhotoLibraryServices (0x110738210). One of the two will be used. Which one is undefined. 在模拟器中、发现“One of the two will be used. Which one is undefined.”日志 查找资料发现原因：objc runtime 对所用app使用同一个命名空间(flat namespace)，运行机制如下： 首先二进制映像被加载，检查程序依赖关系 每一个二进制映像被加载的同时，程序的objc classes在objc runtime命名空间中注册 如果具有相同名称的类被再次加载，objc runtime的行为是不可预知的。一种可能的情况是任意一个程序的该类会被加载(这应该也是默认动作) 17. Invalid Bundle - The asset catalog at &#39;Payload/XXXXX/Assets.car&#39; can&#39;t contain 16-bit or P3 assets if the app supports iOS 9.3 or earlier 在 Xcode 8 中，当你资源文件中[含有16位图]或者[图片显示模式γ值为’P3’]且iOS targets设定为iOS 9.3以下就会出现这个问题. 如果你的app需要支持广色域显示的话，那你必须得把target设置成iOS 9.3+，相反，如果你的app不需要支持广色域且你想兼容 iOS 9.3 之前的项目，你就得把所有的16位的或者显示模式为’P3’图片全都替换成8位模式的SRGB颜色的图片。 你可以通过运行“assetutil”在iTunes Connect的错误信息中找到16-bit 或 P3 资源文件。离线的解决方案如下： 导出项目的 ipa 文件 定位到该ipa文件修改后缀名.ipa 为 .zip. 解压该 .zip 文件. 解压后的目录里面会有一个包含着你的 app bundle 文件的 Payload 文件夹. 打开终端病切换到你的app的Payload文件夹下的 .app bundle 文件夹内，形式如下： cd path/to/Payload/your.app 用 find 命令定位到 Assets.car 文件 .app bundle , 形式如下: find . -name &#39;Assets.car&#39; 使用 assetutil 命令找到任何包含着 16-bit or P3 的资源文件, 对每个 Assets.car 之行以下命令 : sudo xcrun --sdk iphoneos assetutil --info /path/to/a/Assets.car &gt; /tmp/Assets.json 打开上一步生成的 /tmp/Assets.json 文件并查找包含有 “DisplayGamut”: “P3” 或者相关的内容. 这段json的”Name”字段对应的值就是16位或显示的γ值为P3的资源文件名. 找到这个资源文件修改为 8位的sRGB形式,重新编译上传你的app即可. 18. This version does not support documents saved in the Xcode 8 format. Open this document with Xcode 8 or later 编辑项目时默认使用Xcode8打开，导致我用Xcode7打开Xib是报错： This version does not support documents saved in the Xcode 8 format. Open this document with Xcode 8.0 or later 导致用Xcode8打开的Xib全部打不开，只能用编辑器将Xib里面的下面一句话删除掉才能打开： &lt;capability name=&quot;documents saved in the Xcode 8 format&quot; minToolsVersion=&quot;8.0&quot;/&gt;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://huyangjie.com//tags/iOS/"}]}]