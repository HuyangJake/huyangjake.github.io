[{"title":"被思绪戳穿的国庆","date":"2017-10-06T06:03:31.000Z","path":"2017/10/06/被思绪戳穿的国庆/","text":"我一直觉得自己是一个对过去记忆很不敏感的人，写这段文字的时候在回想着往年的国庆在哪。粗粗一想有印象地只有大二的时候跟两个同学一起骑车去穷游的经历。 我现在不太喜欢旅游，没有向往哪里特别想去某个地方旅游的想法。今年的国庆长假，有几个老友相约出游，却也提不起兴趣，之后相互也没有再响应出游计划也就不了了之，最后相互一句 “下次” 一溜而过。 曾曾经也是向往过一群朋友出游，还有跟女朋友一起旅游。现在没有了向往，遇到一次出游的机会我甚至会评估好久这样的一段旅行有什么意义。多数都激不起我心中的波澜，因为几次曾经的经历让我的心境不再为它们所颤动。曾经听一个人说理性的自己和感性的自己这样的概念，这两个自己做出来的决定是截然不同的，没有波澜的自己当然都是理性的。冷淡的日子安静的自己，宁愿回家待7天。 十年十年 这个词，对我来说曾一直是很庞大的量级，这次竟被我爸轻易地用在了我身上。以往听到这个词后面跟的话，都不在我的记忆范围内，但是这回…十年前的那些我都历历在目。只记得几年前，却不曾想已经是十年前。 变听说我回家之前几个表妹已经回来过又走了，而且还是抱着自己刚出生的孩子来的。堂弟也带着的他女朋友跟他妈妈正打麻将。我姐姐的双胞胎这个月底也要出生了。我？ 我现在一头黄发，满嘴胡渣。一直默默地耕耘着自己的未来，一回头发现周围的未来已来。当然也有不变得，经过10多年，乡下的样貌倒改变不是很大，还是有儿时的感觉。 寂在家我选择了电脑，历年长此以往。我不知道在成长过程中，电脑是不是对性格的养成有助攻。它给了逃避的港湾？我只是觉得它更有意义。我给人的印象就跟电脑关联在了一起。出去玩，我也可以玩得很好。但往往不想，或许用一个字概括 “宅” ？ 结看了两天的《权利的游戏》，准备开始代码一波。然后整理思绪，继续耕耘我的世界。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://jake.gift//tags/随笔/"}]},{"title":"iOS隐式动画","date":"2017-07-19T01:08:59.000Z","path":"2017/07/19/iOS隐式动画/","text":"先来一段引用改变下对动画的世界观： Core Animation基于一个假设，说屏幕上的任何东西都可以（或者可能）做动画。 动画并不需要你在Core Animation中手动打开，相反需要明确地关闭，否则他会一直存在。 123456CGFloat red = arc4random() / (CGFloat)INT_MAX; CGFloat green = arc4random() / (CGFloat)INT_MAX; CGFloat blue = arc4random() / (CGFloat)INT_MAX; self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor; 上面这样的一段代码，没有设置任何动画，但是在运行的时候会发现颜色的变化并不是突变的，有一定的动画效果。这个动画怎么实现的，时间又是多少呢？ 这得先从事务说起。 事务是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，而是当事务一旦提交的时候开始用一个动画过渡到新值。 事务通过 CATransaction 类来做管理，使用+begin和+commit来入栈和出栈。 Core Animation在每个run loop周期中自动开始一次新的事务，即使不显式的调用[CATransaction begin] 开始一次事务，任何在一次run loop循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。 关闭隐式动画Core Animation通常对CALayer的所有属性（可动画的属性）做动画，但是UIView把它关联的图层的这个特性关闭了。 我们把改变属性时CALayer自动应用的动画称作行为，当CALayer的属性被修改时候，它会调用-actionForKey:方法，传递属性的名称。具体看看是隐式动画的实现步骤： 这是CALayer头文件里对actionForKey:方法调用的描述 1234567891011121314/* Returns the action object associated with the event named by the * string &apos;event&apos;. The default implementation searches for an action * object in the following places: * * 1. if defined, call the delegate method -actionForLayer:forKey: * 2. look in the layer&apos;s `actions&apos; dictionary * 3. look in any `actions&apos; dictionaries in the `style&apos; hierarchy * 4. call +defaultActionForKey: on the layer&apos;s class * * If any of these steps results in a non-nil action object, the * following steps are ignored. If the final result is an instance of * NSNull, it is converted to `nil&apos;. */- (nullable id&lt;CAAction&gt;)actionForKey:(NSString *)event; 图层首先检测它是否有委托，并且是否实现CALayerDelegate协议指定的-actionForLayer:forKey方法。如果有，直接调用并返回结果。 如果没有委托，或者委托没有实现-actionForLayer:forKey方法，图层接着检查包含属性名称对应行为映射的actions字典。 如果actions字典没有包含对应的属性，那么图层接着在它的style字典接着搜索属性名。 最后，如果在style里面也找不到对应的行为，那么图层将会直接调用定义了每个属性的标准行为的-defaultActionForKey:方法。 所以一轮完整的搜索结束之后，-actionForKey:要么返回空（这种情况下将不会有动画发生），要么是CAAction协议对应的对象，最后CALayer拿这个结果去对先前和当前的值做动画。 这就解释了UIKit是如何禁用隐式动画的：每个UIView对它关联的图层都扮演了一个委托，并且提供了-actionForLayer:forKey的实现方法。当不在一个动画块的实现中，UIView对所有图层行为返回nil，但是在动画block范围之内，它就返回了一个非空值。 ps : [CATransaction begin]之后添加下面的代码，同样也会阻止动画的发生： [CATransaction setDisableActions:YES]; 关联图层设置动画 UIView关联的图层禁用了隐式动画，对这种图层做动画的唯一办法就是使用UIView的动画函数（而不是依赖CATransaction），或者继承UIView，并覆盖-actionForLayer:forKey:方法，或者直接创建一个显式动画（等待下一篇笔记）。 对于单独存在的图层，我们可以通过实现图层的-actionForLayer:forKey:委托方法，或者提供一个actions字典来控制隐式动画。 自定义行为行为通常是一个被Core Animation隐式调用的显式动画。 我们来对颜色渐变的代码（文章顶部）使用一个不同的行为，通过给colorLayer设置一个自定义的actions字典。我们也可以使用委托来实现，但是actions字典可以写更少的代码。 PS: CATransition响应CAAction协议，并且可以当做一个图层行为 12345//add a custom action CATransition *transition = [CATransition animation]; transition.type = kCATransitionPush; transition.subtype = kCATransitionFromLeft; self.colorLayer.actions = @&#123;@\"backgroundColor\": transition&#125;; 在初始化的时候给layer添加了这样的行为之后，就可以对隐式动画添加了一个 推进过度 的效果 ReferenceiOS Core Animation 十分感谢译者","tags":[{"name":"iOS","slug":"iOS","permalink":"http://jake.gift//tags/iOS/"}]},{"title":"Hi！CALayer我们聊聊","date":"2017-07-17T07:39:59.000Z","path":"2017/07/17/Hi！CALayer我们聊聊/","text":"CALayer和UIView最大的不同就是，CALayer不处理用户交互。因为它并不清楚具体的响应链。 1. iOS 和 MacOS 的坐标系统 点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称 作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一 个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备 和普通设备上能有一致的视觉效果。 像素 —— 物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。 UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层 的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备 上，他们表现出来了不同的大小。 单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的 度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种 纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。 2. CALayer层的简单使用：2.1 给UIView设置寄宿图片12345//设置图片layer.contents = (__bridge id)image.CGImage;//设置图片的展示模式layer.contentsGravity = kCAGravityResizeAspect; contentsGravity的可选常量： 123456789101112kCAGravityCenter kCAGravityTop kCAGravityBottom kCAGravityLeft kCAGravityRight kCAGravityTopLeft kCAGravityTopRight kCAGravityBottomLeft kCAGravityBottomRight kCAGravityResize kCAGravityResizeAspect kCAGravityResizeAspectFill 将contentsScale设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕。(前提是contentsGravity没有被设置)，视图层UIView有一个类似的属性contentScaleFactor 当用代码的方式来处理寄宿图的时候，一定要记住要手动的设置图层 的 contentsScale 属性，否则，你的图片在Retina设备上就显示得不正确啦。 1layer.contentsScale = [UIScreen mainScreen].scale; 2.2 使用contentsRect实现image sprites（图片拼合）主要思想：载入一张包含很多小图的大图，然后通过contentsRect将大图中的小图分别展示到不同的视图层中。 优点：图片的载入会更加快，提高了载入性能 contentsRect的{0, 0, 0.5, 0.5}效果 1234567891011121314- (void)viewDidLoad &#123; [super viewDidLoad]; //load sprite sheet UIImage *image = [UIImage imageNamed:@&quot;Sprites.png&quot;]; //set igloo sprite [self addSpriteImage:image withContentRect:CGRectMake(0, 0, 0.5, 0.5) toLayer:self.iglooView.layer]; //set cone sprite [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0, 0.5, 0.5) toLayer:self.coneView.layer]; //set anchor sprite [self addSpriteImage:image withContentRect:CGRectMake(0, 0.5, 0.5, 0.5) toLayer:self.anchorView.layer]; //set spaceship sprite [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0.5, 0.5, 0.5) toLayer:self.shipView.layer];&#125; 2.3 使用contentsCenter调整可拉伸区域的大小contentsCenter 其实是一个CGRect，它定义了一个固定的边框和一个在图 层上可拉伸的区域。 除此之外还可以用IB来控制contentsCenter属性。 在视图的第四个检查器中，有一个stretching属性，简直不要太赞👍 Reference《iOS 核心动画》 感谢译者的付出！👍","tags":[{"name":"iOS","slug":"iOS","permalink":"http://jake.gift//tags/iOS/"}]},{"title":"自定义NSURLProtocol实现UIWebView缓存机制","date":"2017-07-14T02:08:43.000Z","path":"2017/07/14/自定义NSURLProtocol实现UIWebView缓存机制/","text":"近期正在研究UIWebView加载网页的缓存的实现，比较常见的是使用自定义的NSURLProtocol进行拦截处理。根据网上的资料，结合试验和自己的理解做个记录。 介绍介绍下我产出的YJURLProtocol完成的功能 功能 支持 说明 缓存数据 是 将整个request缓存下来，以及其response 设置过期时间 是 默认为两天过期，过期后请求会删除原有缓存 自动更新缓存 是 间隔时间超过1min的请求，加载页面后异步更新缓存 UIWebView缓存使用机制： 两个相同的请求时间相隔在60s之内，直接使用缓存，不进行异步更新缓存 两个相同的请求相隔60s+但是没有过期，使用缓存加载页面后，1min后进行异步更新缓存并刷新页面 缓存命中但是时间已经是两天前，则删除缓存走网络数据 NSURLProtocol什么是NSURLPrototol （NSURLProtocol什么的我都懂，我要直接看🌰）Apple的URL Loading System的核心是NSURL类，NSURL提供给app要访问资源的地址，NSURLRequest对象再额外添加HTTP headers， body之类的信息，然后URL Loading System提供NSURLSession和NSURLConnection的各种子类方法去执行这个请求。 请求返回的数据会有两分部分，metadata 和 data。metadata被包括在NSURLResponse对象中，它会提供MIME type，和 text encoding。 data的数据是NSData类型。 在以上过程之后，URL Loading System通过NSURLRequest下载了信息之后，它将会创建一个NSURLProtocol子类的对象。 Note: Remember that Objective-C doesn’t actually have abstract classes as a first class citizen. It’s only by definition and documentation that a class is marked as abstract. 千万不能直接实例化NSURLProtocol, 必须要继承NSURLProtocol,在子类中创建NSURLResponse处理response。 使用NSURLProtocol能做什么 为网络请求提供自定义的Response 可以在网络调试的时候，发起网络请求后进行自定义返回数据调试自己的APP 调过网络请求，加载本地数据 某些情况下，发起的请求并没有去请求网络的必要，可以修改使用本地的数据。（自定义webView的缓存就是如此实现） 重定向网络请求 可以将请求重定向到某个代理服务器，不需要通过iOS给用户弹出授权窗口 修改Request的User-agent 如果你的一个页面是分不同的设备返回数据的，那么可以在这里设置自定的user-agent，来达到你的需求。 使用自己的网络协议 可以替换使用自己实现的网络协议，比如有些建立在UDP之上的协议。 NSURLProtocol的使用1[NSURLProtocol registerClass:[JakeyURLProtocol class]]; 以上代码表示，你已经向URL Loading System注册了自己的NSURLProtocol子类，这个子类将有机会处理每一个发送到URL Loading System的请求。 在NSURLProtocol的子类实现文件中：123+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123; return YES;&#125; 重载以上代码，返回YES。表示此子类注册之后将使用此子类处理所有的请求，返回NO则仍然使用URL Loading System的默认protocol处理请求。 1234567891011121314151617181920//这是个抽象方法，子类必须提供实现方法。此方法可用于修改request，添加一个header等+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request &#123; return request;&#125;//用于判断你的自定义reqeust是否相同，这里返回默认实现即可。它的主要应用场景是某些直接使用缓存而非再次请求网络的地方。+ (BOOL)requestIsCacheEquivalent:(NSURLRequest *)a toRequest:(NSURLRequest *)b &#123; return [super requestIsCacheEquivalent:a toRequest:b];&#125;//开始请求- (void)startLoading &#123; self.connection = [NSURLConnection connectionWithRequest:self.request delegate:self];&#125;//请求结束- (void)stopLoading &#123; [self.connection cancel]; self.connection = nil;&#125; 自定义NSURLProtocol实现UIWebView缓存机制开始请求之后，将此请求标记为已处理 12345- (void)startLoading &#123; NSMutableURLRequest *newRequest = [self.request mutableCopy]; [NSURLProtocol setProperty:@YES forKey:kHandledKey inRequest:newRequest]; self.connection = [NSURLConnection connectionWithRequest:newRequest delegate:self];&#125; 判断请求是否已经被处理过，避免循环被处理 12345678910+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123; NSString *scheme = request.URL.scheme; if ([scheme caseInsensitiveCompare:@\"http\"]==NSOrderedSame||[scheme caseInsensitiveCompare:@\"https\"]==NSOrderedSame) &#123; if ([NSURLProtocol propertyForKey:kHandledKey inRequest:request]) &#123; return NO; &#125; return YES; &#125; return NO;&#125; 自定义YJCacheResponse对象，内容包含内容如下代码 123456789101112131415161718192021@interface YJCachedResponse : NSObject@property (nonatomic, strong) NSData *data;@property (nonatomic, strong) NSString *url;@property (nonatomic, strong) NSString *mimeType;@property (nonatomic, strong) NSString *encoding;@property (nonatomic, strong, readonly) NSURLResponse *response;/** 初始化封装的YJResponse对象 @param data 请求结果数据 @param response @param timeInterval 缓存过期时间 @return 封装的YJResponse对象 */- (instancetype)initWithData:(NSData *)data response:(NSURLResponse *)response limiteTime:(NSTimeInterval)timeInterval;//检查缓存是否过期 0 ：已过期 , 1 ： 需更新缓存, 2 ：无需更新缓存- (CacheStatus)isCacheEffective;@end 在开始请求- (void)startLoading方法中，判断是走缓存还是使用网络请求数据 12345678910111213141516171819202122232425262728- (void)startLoading &#123; NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; self.cachedFilePath = [docPath stringByAppendingPathComponent:md5(self.request.URL.absoluteString)]; //在缓存表中获取当前request是否有缓存 YJCachedResponse *cachedResponse = [self cachedResponseForCurrentRequest]; if (cachedResponse) &#123; switch ([cachedResponse isCacheEffective]) &#123; case OutOfDate: [self useNetData]; break; case UpdateNeedLess: [self useCacheData:cachedResponse]; break; case UpdateNeeded: [self useCacheData:cachedResponse]; //1秒钟之后重新请求，更新缓存 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [self useNetData]; &#125;); break; default: break; &#125; &#125; else &#123; [self useNetData]; &#125;&#125; 在NSURLConnectionDelegate方法中进行Response保存和赋值 1234567891011121314151617- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &#123; [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed]; self.response = response; self.mutableData = [[NSMutableData alloc] init];&#125;- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123; [self.client URLProtocol:self didLoadData:data]; [self.mutableData appendData:data];&#125;- (void)connectionDidFinishLoading:(NSURLConnection *)connection &#123; [self.client URLProtocolDidFinishLoading:self]; [self saveCachedResponse];&#125; 以上只列出部分关键逻辑代码，详细实现请下载demo查看源码问题缺陷 一个网站会有些网络请求地址跟时间戳或者其他随机字符相关，缓存机制会缓存下来，并且之后一直没有机会命中它们，没有办法自动删除这些缓存，会造成内存浪费。 因本人水平有限，文中有什么不正确之处，还请指出，不胜感谢！ Referencehttps://www.raywenderlich.com/59982/nsurlprotocol-tutorial","tags":[{"name":"iOS","slug":"iOS","permalink":"http://jake.gift//tags/iOS/"}]},{"title":"小程序视图层","date":"2017-06-03T09:56:31.000Z","path":"2017/06/03/小程序视图层/","text":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jake.gift//tags/JavaScript/"}]},{"title":"小程序逻辑层","date":"2017-06-03T08:51:50.000Z","path":"2017/06/03/小程序逻辑层/","text":"注册小程序前台、后台定义： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。 关闭小程序(公共库版本1.1.0开始支持)： 当用户从扫一扫、转发等入口(场景值为1007, 1008, 1011, 1025)进入小程序，且没有置顶小程序的情况下退出，小程序会被销毁。 在onLaunch和onShow方法中可以获得的参数： 注意： App() 必须在 app.js 中注册，且不能注册多个。 不要在定义于 App() 内的函数中调用 getApp() ，使用 this 就可以拿到 app 实例。 不要在 onLaunch 的时候调用 getCurrentPages()，此时 page 还没有生成。 通过 getApp() 获取实例之后，不要私自调用生命周期函数。 注册页面生命周期函数 onLoad: 页面加载 一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。 onShow: 页面显示 每次打开页面都会调用一次。 onReady: 页面初次渲染完成 一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。 对界面的设置如wx.setNavigationBarTitle请在onReady之后设置。详见生命周期 onHide: 页面隐藏 当navigateTo或底部tab切换时调用。 onUnload: 页面卸载 当redirectTo或navigateBack的时候调用。 onShareAppMessage转发小程序时需要添加的自定义转字段： 12345678Page(&#123; onShareAppMessage: function () &#123; return &#123; title: '自定义转发标题', path: '/page/user?id=123' &#125; &#125;&#125;) 事件处理函数123&lt;!--index.wxml--&gt;&lt;view&gt;&#123;&#123;text&#125;&#125;&lt;/view&gt;&lt;button bindtap=&quot;changeText&quot;&gt; Change normal data &lt;/button&gt; 12345678910Page(&#123; data: &#123; text: 'init data', &#125;, changeText: function() &#123; // this.data.text = 'changed data' // bad, it can not work this.setData(&#123; text: 'changed data' &#125;) &#125; Tips 直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致 单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。 下图为page实例的生命周期： 路由小程序的页面用栈的形式进行维护管理，大致与iOS相似。 路由方式 API 页面栈表现 初始化 新页面入栈 打开新页面 wx.navigateTo 新页面入栈 页面重定向 wx.redirectTo 当前页面出栈，新页面入栈 页面返回 wx.navigateBack 页面不断出栈，直到目标返回页，新页面入栈 Tab 切换 wx.switchTab 页面全部出栈，只留下新的 Tab 页面 重加载 wx.reLaunch 页面全部出栈，只留下新的页面 页面重定向在iOS的UINavigation中没有对应。 tab切换在小程序里竟然是页面全部出栈，留下最新的tab页。我在iOS中的处理一般是，每个tab页拥有自己的Navigation，切换tab就切换当先使用的Navigation。系统底层的实现应该也是不是小程序这样，等待去研究下回来跟新这里吧 重加载，这一项有点疑惑。当我在比较深层的页面刷新重加载一下，整个栈里就只剩下当前页面了？！那程序的层次结构怎么办，还是说回到了首页，这体验很糟糕啊。 Tips: navigateTo, redirectTo 只能打开非 tabBar 页面。 switchTab 只能打开 tabBar 页面。 reLaunch 可以打开任意页面。 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。 调用页面路由带的参数可以在目标页面的onLoad中获取。 模块化将公共的代码抽离出来，放到一个单独的js文件中作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。 12345// common.jsfunction sayHello(name) &#123; console.log(`Hello $&#123;name&#125; !`)&#125;module.exports.sayHello = sayHello 在调用的时候使用require(path)把需要的代码引入 123456var common = require('common.js')Page(&#123; helloMINA: function() &#123; common.sayHello('MINA') &#125;,&#125;) 参考微信小程序文档","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jake.gift//tags/JavaScript/"}]},{"title":"微信小程序初识","date":"2017-06-03T06:20:19.000Z","path":"2017/06/03/微信小程序初识/","text":"开始了解小程序啦，近期要准备修改一个小程序，添加两个自定义的功能，记录下学习过程中的体会。 目录初始小程序最关键也是必不可少的是 app.js、app.json、app.wxss 这三个。其中，.js后缀的是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件。 app.jsapp.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API。 app.jsonapp.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口\b背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。 下面是一个包含所有配置项的app.json文件 1234567891011121314151617181920212223&#123; \"pages\": [ \"pages/index/index\", \"pages/logs/index\" ], \"window\": &#123; \"navigationBarTitleText\": \"Demo\" &#125;, \"tabBar\": &#123; \"list\": [&#123; \"pagePath\": \"pages/index/index\", \"text\": \"首页\" &#125;, &#123; \"pagePath\": \"pages/logs/logs\", \"text\": \"日志\" &#125;] &#125;, \"networkTimeout\": &#123; \"request\": 10000, \"downloadFile\": 10000 &#125;, \"debug\": true&#125; pagespages中为所有的页面，第一项为小程序的初始页面 window12345678910&#123; \"window\":&#123; \"navigationBarBackgroundColor\": \"#ffffff\", //导航栏背景色 \"navigationBarTextStyle\": \"black\", //导航栏标题颜色，仅支持 black/white \"navigationBarTitleText\": \"微信接口功能演示\", //导航栏标题文字内容 \"backgroundColor\": \"#eeeeee\", //窗口背景色 \"backgroundTextStyle\": \"light\", //下拉背景字体、loading 图的样式，仅支持 dark/light \"enablePullDownRefresh\": \"true\" //是否开启下拉刷新 &#125;&#125; tabbarTip： 当设置 position 为 top 时，将不会显示 icon tabBar 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。 12345678910111213141516\"tabBar\": &#123; \"color\": \"#F8F8F8\", //tab上文字默认颜色 \"selectedColor\": \"#ffffff\", //tab上文字选择后的颜色 \"backgroundColor\": \"#ffffff\", //tab的背景色 \"borderStyle\": \"black\", //（非必填）tabbar上边框的颜色， 仅支持 black/white \"position\": \"top\", //（非必填） bottom、top(默认为top) \"list\": [&#123; \"pagePath\": \"pages/index/index\", \"text\": \"首页\", \"iconPath\": \"\", //（非必填）图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效 \"selectedIconPath\": \"\" //（非必填）选择后的图片路径 ，同上 &#125;, &#123; \"pagePath\": \"pages/logs/logs\", \"text\": \"日志\" &#125;] &#125;, networkTimeout 属性 类型 必填 说明 request Number 否 wx.request的超时时间，单位毫秒，默认为：60000 connectSocket Number 否 wx.connectSocket的超时时间，单位毫秒，默认为：60000 uploadFile Number 否 wx.uploadFile的超时时间，单位毫秒，默认为：60000 downloadFile Number 否 wx.downloadFile的超时时间，单位毫秒，默认为：60000 app.wxssapp.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。 页面小程序的每个页面都有自己所属的 .js .json .wxss文件还有 .wxml文件，前面三者同全局的文件作用相同，只是在这个页面它们的优先级会更高，比如page自己的样式会覆盖全局的样式。.wxml文件是这个页面的布局文件。 每个页面的这四个后缀的文件，小程序要求要有相同的路径的文件名。 某个页面的page.json文件中会覆盖跟app.json相同的配置，只能设置window相关的配置。 属性 类型 默认值 描述 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如”#000000” navigationBarTextStyle String white 导航栏标题颜色，仅支持 black/white navigationBarTitleText String 导航栏标题文字内容 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle String dark 下拉背景字体、loading 图的样式，仅支持 dark/light enablePullDownRefresh Boolean false 是否开启下拉刷新，详见页面相关事件处理函数。 disableScroll Boolean false 设置为 true 则页面整体不能上下滚动；只在 page.json 中有效，无法在 app.json 中设置该项 1234567&#123; \"navigationBarBackgroundColor\": \"#ffffff\", \"navigationBarTextStyle\": \"black\", \"navigationBarTitleText\": \"微信接口功能演示\", \"backgroundColor\": \"#eeeeee\", \"backgroundTextStyle\": \"light\"&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jake.gift//tags/JavaScript/"}]},{"title":"Apple Debugging---使用LLDB替换方法为自定义的block","date":"2017-05-25T14:26:02.000Z","path":"2017/05/25/Apple-debugging-使用LLDB替换方法为自定义的block/","text":"Swizzling with block injection要在lldb中使用Objective-C的runtime，可以通过导入头文件来获得运行时的各种黑色科技。 po @import Foundation 在控制台输入po （lldb) po Enter expressions, then terminate with an empty line to evaluate: 1: 然后可输入多行代码，就像在Xcode中写代码一样。在编写完毕后，回车空一行，再回车代码就会被执行了。下面是一个例子： 1: @import Cocoa; 2: id $class = [NSObject class]; 3: SEL $sel = @selector(init); 4: void *$method = (void *)class_getInstanceMethod($class , $sel); 5: IMP $oldImp = (IMP)method_getImplementation($method); id (^$block)(id) = ^id(id object) { if ((BOOL)[object isKindOfClass:[NSView class]]) { fprintf(stderr, &quot;%s\\n&quot;, (char *)[[[object class] description] UTF8String]); } return object; } IMP $newImp = (IMP)imp_implementationWithBlock($block); method_setImplementation($method, $newImp); 至此，NSObject的init方法就被替换为了上述代码中的block，LLDB中有一个bug，在block中执行IMPS就会崩溃。 内容来自：《Advanced Apple Debugging &amp; Reverse Engineering》","tags":[]},{"title":"Apple Debugging---开始使用LLDB","date":"2017-05-23T15:43:58.000Z","path":"2017/05/23/Apple-Debugging-开始使用LLDB/","text":"Getting around RootlessOS X 10.11 中引入的 Rootless，即使是root用户，也无法对以下路径有写和执行的权限： /System /bin /sbin /usr (except /usr/local) 只有Apple自身签名的软件（含命令行工具）可以。 Apple的Rootless机制虽然保护了系统的安全，防止了大部分恶意软件想通过单纯的引导用户，输入自己的密码点击确定来直接切换到root做一些违法的事情。也可以防止黑客黑了一个用户然后就有root权限可以肆意妄为的情况，不过对于真正的黑客来说 Disabling Rootless在电脑的Recovery Mode，打开终端输入 csrutil disable; reboot 电脑会重启，此时电脑就禁用了Rootless，可以调试系统级别的应用。 可以使用命令： lldb -n Finder 看到类似以下信息就表示成功 Process XXX stoped . . . Attaching LLDB to Xcode 使用lldb attach 到最常用的工具Xcode！ 方式一： lldb file /Applications/Xcode.app/Contents/MacOS/Xcode 方式二： lldb -n Xcode //需要Xcode在运行状态 方式三： pgrep -x Xcode //需要Xcode在运行状态 lldb -p 89921 //89921为Xcode的PID 方式四：(attaching 一个将会运行的程序) lldb -n Finder -w pkill Finder 运行程序： process lanuch -e /dev/ttys004 -- 这里的ttys004是shell中的某个tab的唯一id 运行程序时可以携带的参数： 通过-w参数改变运行程序的目录： 1(lldb) process launch -w /Applications 也可以直接将参数加到程序后面： 1(lldb) process launch -- /Applications -X参数让 shell 接受任何格式参数，比如下面这种 ~ 字符 1(lldb) process launch -X true -- ~/Desktop ps： run 命令是上面 process launch -X true -- 的简写 可以直接 run ~/Desktop -o 命令让LLDB输出到指定的文件 1(lldb) process launch -o /tmp/ls_output.txt -- /Applications -i 命令可以从外部文件读取数据，这在不想stdin的状况下很有用（还没有体会到😌 ） 1234(lldb) process launch -i /tmp/wc_input.txt等同于wc &lt; /tmp/wc_input.txt //wc为当前lldb的target -n 命令告诉LLDB不要创建stdin 1(lldb) process launch -n 按Ctrl + C可以暂停debugger， 添加一个断点： breakpoint set -n &quot;-[NSView hitTest:]&quot; continue //断点后继续执行 po $rdi // 查看RDI CPU register //修改一个断点，添加一个触发条件 breakpoint modify 1 -c &quot;(BOOL)[$rdi isKindOfClass:[NSTextView class]]&quot; 内容出处：《Advanced Apple Debugging &amp; Reverse Engineering》","tags":[]},{"title":"方向","date":"2017-05-11T03:26:32.000Z","path":"2017/05/11/方向/","text":"","tags":[]},{"title":"一次版本发布的启示","date":"2017-05-03T01:17:42.000Z","path":"2017/05/03/一次版本发布的启示/","text":"今天早上怀着惴惴不安的心情，点开了iTunes Connect，等待漫长的loading… 审核通过了！ 是不是我对Apple审核太敏感了？😂，只因为这个版本的发布因为审核被拖延好久了😕 刚好这段时间有在看《程序员的职业素养》这本书，结合这次的版本发布事故让我收获了新的体会。 事故现场直接来看事故现场吧： 25号提交版本，27号正常通过审核。当要发布的前一刻，测试姐姐告知我们有个功能这个版本不需要上，于是我们打算启用线上预埋的开关替换这版不需要上的功能的界面，从而正常上线当前等待发布区的版本。然而一切没有那么顺利，料想不到的是这个界面在预埋的处理中参数没有正确处理，导致了上述方案没法正常运行。 只好撤下已经过审的版本，修改问题重新提交。也就是图中圈起来的这一步，也正是这一步开启了万恶的轮回。。。 日子慢慢靠近五一假期，项目的上线时间倒没有要去凑节日这样的要求，只是如果在假期中出现线上什么问题，解决起来就没有那么高效，万一涉及到跟其他部门之间的配合修改，可就更加麻烦。毕竟小长假都在happy。 没想到，戏剧性的出现了下图中的这出戏 重新提交后的第二天，被Apple拒绝了。懵逼了，没有修改过其他代码，竟然前一天通过，这天就被拒绝，苹果爸爸果然强势。拒绝原因还让人无法拒绝，“APP的描述图片不符合规范”。这，，我们都已经用了两个版本了。好吧，让视觉大哥重新设计，运营重新提交了审核。现在也就希望五一期间正常上线就行了。 假期第一天29号，仍然被拒。而且被拒原因升级了。Apple审核人员告知我们APP在启动的时候crash了😱，定位了他们提供的奔溃日志后发现，它貌似是平常我们crash收集列表中的一个小概率出现的bug，但是之前一直没有找到根源在哪。 这次拿到的日志信息让我找到了奔溃处的代码，这是同事负责的模块。我找到可疑的地方，问了同事会不会出现我想象的错误导致崩溃，同事说不会，没有遇到过。我想着毕竟是他的模块，就不多说了，同事建议不修改再提交一次审核，我想着这个问题本也是概率出现时，说不定是审核人员运气太好遇到了。于是我们再次提交审核。。。 两天后 5.2小长假结束，回来上班了，打开iTunes Connect发现还是被拒绝了😖，我当时心里的第一感觉是后悔，后悔没有去修改那个问题，指不定就过了。现在要向领导汇报这次失误，还要继续确认问题。写了份上线被拒说明的pdf文档给老大并解释，老大让我赶紧定位问题，修改再提交上线，并语重心长地跟我重申了我们定好的每半个月更新线上版本的计划，告诉我这次的时间太久了。倍感压力和自责。。。 按照之前怀疑过的思路继续往下查，我找到了确凿的证据，导致crash的地方果然是那里。 我立马修改了代码重新提交审核，并发了testFlight让测试同学在针对性地点一点，自己也在紧张地review着，心里不断默念着：可不能再被拒绝了啊 然而，折磨我的路口总是一个个不断出现。上午提交后，我在下午的review中发现了一个不大不小的问题，同事测试在iPad版本（因为Apple审核人员使用iPad进行测试）中发现了另外一个问题，让我不得不重新撤回审核，修改了问题代码重新提交。这样断断续续折腾了一天。 终于在5.3，今天早上得到了一个好消息，磨人的审核。 感悟红色字体的地方都是我感悟的触发点。 “参数没有正确处理” 《程序员的职业素养》中提到一个高效工作的状态称作流态区。当人处在流态区中，其实是处在了一种浅层的冥想之中，会追求工作的速度，理性思考的能力会下降。当然我觉得，这当然排除需要高强度脑力思考的工作。但是这种强度在平常工作中基本遇不到。 为了尽快完成任务，我常会陷入流态区，预埋开关这种平常用不到的参数设置就没有注意去设置，并且没有去验证保证正确。为了完成某个任务而省略了验证的步骤往往会给自己往后增加更多的麻烦。 有个功能这个版本不需要上 测试同学在我们要上线的时候告诉我们那个功能不用上线，这个也是挺冤枉的，但是也该怪我们自己。这个功能前个版本就做好了，没有明说上不上，上版本上了让撤下来，这次上了又让撤下来。怪在我们一直拖着没有去确认清楚准确的时间，就算拿不到准确的时间也该在提交这次版本之前去确认这版要不要上。更好的解决办法是，在这里的配置一个这个功能的开关，可以在线上控制就免去这个麻烦。得过且过的惰性抑制了生产力 如果希望自己的软件灵活可变，那就应该时常修改它！ 让软件保持固定不变是危险的！如果一直不重构代码，等到最后不得不重构时，就会发现代码已经僵化了。 时常修改，并且大刀阔斧地修改的前提保证最好要有一套覆盖了代码的自动化测试。 不害怕修改代码那就是一直在改。 像《程序员的职业素养》中提到，代码就的时常优化，我有一个版本的时间，却没有去优化这个功能，造成了后面一系列的问题😫 我想着毕竟是他的模块，就不多说了 不得不承认，当时想着是这是同事的模块，我也询问过是否出现有我考虑到的问题，最后要是还有问题那就没有我什么责任了。 太傻！典型的缺失责任感，我知道我对那段代码存在怀疑，同事告知不会有问题也并没有说服我。不知道可选值是否可能为空的情况下对一个可选值强制解包，我第一反应是添加一个判空。没有坚持，觉得问题跟自己没多大关系，是个大错误。 发现了潜在的问题，并且是在审核的关键阶段，提出并去验证检查是该有责任。 后悔没有去修改那个问题，指不定就过了 在问题发生后再去想这样的事，也是个错误。这种思维回想过来无非是对之前同事判断的否定，并带着责怪。仔细想想，我自己不也是是同意了这样子去做了吗？！没有坚持去追究发现的问题，也想投机取巧想着轻松过关，没有认真对待这个问题。 不得不重新撤回审核 在再次提交这个版本的时候，老大有问过两次还有没有发现其他问题。满口地回答了没有，没想到还是中招了。自我审查的责任感，还需要提高，不能把测试组当成是抓虫机器。当初真的在这样的思想上栽了大跟头，还需要不断地改善。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://jake.gift//tags/随笔/"}]},{"title":"多睡觉多读书","date":"2017-04-28T05:29:31.000Z","path":"2017/04/28/多睡觉多读书/","text":"有那么一段时间一天写12个小时的代码，而且都是业务的代码，脑子填充满满地，没有思考生活、学习和娱乐的余地。 那时我感觉自己像是最喜欢的美剧：The Walking Dead 中的行尸走肉，没有自己的思维，吸着雾霾踏着自行车上班，踩着朦胧夜色归来点份外卖。几乎没有代码以外的交流，没有目的地也不知道往哪走。我厌恶这样的生活状态，但是不知道该如何逃脱，我也不知道怎么陷入了这样的心态。 直到有一次抽空看了《软件开发者路线图-从学徒到高手》这本书，我对自己多了写思考。 回忆写这篇文章的时候，距离看完这本书已经有些时间了，我感觉到自己现在的状态已经调整好了不少，不过也不是理想。 到现在我印象最深，也就是这本书给我最大的启迪是：善于暴露自己的不足 人有二知二不知 I know that I know I know that I don’t know I don’t know that I know I don’t know that I don’t know 资质平庸而又刚毕业一年的小鸟，在一个领域会有什么样的建树？ 可笑的是我曾觉得自己的技术水平已经属于挺不错😅基本iOS上开发有深有浅的都了解了。于是想着要装装X，写写博客展示下自己的水平。可当搭好了博客框架想要动笔时，才发现自己脑子的“干货”仓库中的东西是多么平庸。于是开始踮起脚尖写博客，边学习边总结到博客上，这成了之前的模式。 这时候不敢把自己直接暴露在问题之下，喜欢套用经验模式，I don’t know that I don’t know 提升技术的提升和成长是由内而外，没有墨水就写不出字，成为不了一个输出者。 慢慢看了一些拔高的书之后，我意识到自己有那么多的不知道。博客对于我的意义开始改变，它成了我暴露不足弥补不足的地方。强者的强大在于它最脆弱的地方，展现自己的不足。 保证精力，多睡觉，多读书！","tags":[{"name":"随笔","slug":"随笔","permalink":"http://jake.gift//tags/随笔/"}]},{"title":"解读Objective-C的NSDictionary","date":"2017-04-20T03:27:20.000Z","path":"2017/04/20/解读Objective-C的NSDictionary/","text":"NSDistionary是非常熟悉常用的一个Foundation中的类，最显著的几个特点是： 以键值对存储数据 存储的数据具有唯一性 数据无序 我们这次不是讲NSDictionary或NSMutableDictionary的方法，这些在Apple API Reference中查询即可了解啦~我们来探索下NSDictionary的内部 Apple文档的启示苹果貌似并不推荐我们去继承NSDictionary来使用其子类（苹果已经实现的子类：NSMutableDictionary除外） Before making a custom class of NSDictionary, investigate NSMapTable and the corresponding Core Foundation type, CFDictionary. Because NSDictionary and CFDictionary are “toll-free bridged,” you can substitute a CFDictionary object for a NSDictionary object in your code (with appropriate casting). Although they are corresponding types, CFDictionary and NSDictionary do not have identical interfaces or implementations, and you can sometimes do things with CFDictionary that you cannot easily do with NSDictionary. If the behavior you want to add supplements that of the existing class, you could write a category on NSDictionary. Keep in mind, however, that this category will be in effect for all instances of NSDictionary that you use, and this might have unintended consequences. Alternatively, you could use composition to achieve the desired behavior. 大致意思是让我们想要给NSDictionary添加新功能就使用分类，不要继承子类。如果打算要继承NSDictionary，则需要好好研究下NSMapTable和相对应的Core Foundation类型：CFDictionary CFDictionary是Core Foundation中的字典，和NSDictionary可以无代价转换，两者可以互相调用对方的方法创建和释放。可以使用CFDictionary来实现NSDictionary不容易实现的功能。· 另外苹果推荐让我们研究的NSMapTable具体是什么呢? The NSMapTable class is a mutable collection modeled after NSDictionary 看到这句话刚开始我有点不解，NSMapTable竟是模仿NSDictionary的一个可变得集合，那跟NSMutableDictionary有什么不同啊？ NSMapTable与NSDictionary的几个不同点是： 可以weak的方式持有对象，当持有的对象的引用计数为0的时候，该对象会自动从集合中移除 key 和 value在输入的时候都可以copy，使用指针对做isEqual或者hashing对比 可以包含任何指针，不再仅仅局限于Objective-C的对象 NSMapTable的初始化就可以指定 key 和 value 的持有方式 苹果提供了几个便捷的工厂方法12345678//key strong， value strong+ (NSMapTable&lt;KeyType, ObjectType&gt; *)strongToStrongObjectsMapTable NS_AVAILABLE(10_8, 6_0);//key weak， value strong+ (NSMapTable&lt;KeyType, ObjectType&gt; *)weakToStrongObjectsMapTable NS_AVAILABLE(10_8, 6_0); // entries are not necessarily purged right away when the weak key is reclaimed//key strong， value weak+ (NSMapTable&lt;KeyType, ObjectType&gt; *)strongToWeakObjectsMapTable NS_AVAILABLE(10_8, 6_0);//key weak， value weak+ (NSMapTable&lt;KeyType, ObjectType&gt; *)weakToWeakObjectsMapTable NS_AVAILABLE(10_8, 6_0); // entries are not necessarily purged right away when the weak key or object is reclaimed 或者像这样指定： 123456//还可以指定NSMapTableCopyIn(添加前进行copy) ， 或者NSMapTableObjectPointerPersonality（使用指针去hashing） NSMapTable *mapTable = [NSMapTable mapTableWithKeyOptions:NSMapTableStrongMemory valueOptions:NSMapTableWeakMemory]; //需要一个对象到对象的映射集合，可以使用如下的mapTable NSMapTable *objectToObjectMapping = [NSMapTable mapTableWithStrongToStrongObjects]; 同样类推，NSHashTable是对NSSet的模仿和衍生，扩展的功能与NSMapTable相同 抛两个问题🙈Q：上千的对象存储到NSDictionary时，出现效率低下的问题是什么原因？直接先回答问题：因为存储的数量很多后hash表会出现比较多的冲突，解决大量冲突会占用大量CPU资源，造成效率低下。 hash表是什么？跟NSDictionary又有什么关系？ NSDictionary是使用hash表来实现key和value之间的映射和存储的。 hash表的基本思想是：将key作为关键字，放到hash函数ƒ(k)中计算得到结果为hash地址，然后将value值的地址存储到hash表中的ƒ(key)的hash地址中。 当关键字集合很大的时候，不同的关键字可能会通过hash函数映射到hash表的同一地址上。key1 ≠ key2, ƒ(key1) = ƒ(key2),这种情况称为冲突。冲突是不可避免的，只能通过改善哈希函数来减少冲突。（构造哈希函数方法请参考这里或查找其他资料） 然而有冲突必定是要解决的，不然新的值怎么存储到哈希表中呢。处理冲突主要有（查看原文请移步底部参考链接：哈希表）： 开放定址法 线性探测 平方探测 伪随机探测 单独链表法 将散列到同一个存储位置的所有元素保存在一个链表中。实现时，一种策略是散列表同一位置的所有冲突结果都是用栈存放的，新元素被插入到表的前端还是后端完全取决于怎样方便。 再哈希 上一次哈希计算发生冲突后，使用另外的哈希函数进行哈希计算知道冲突不再发生 建立公共溢出区 为冲突的哈希地址单独建立一块区域，所有冲突的哈希地址都存放在此区域中 到这里也就可以推断出，如果在NSDictionary存取时出现效率低下的情况，那么很可能是： 1.频繁的扩容 2.冲突过多 Q：NSMapTable是怎样的结构呢？先来看看NSMapTable的结构(代码来自于cocotron)NSMapTable是一个key－value的容器，下面是NSMapTable的部分代码： 12345typedef struct &#123; NSMapTable *table; NSInteger i; struct _NSMapNode *j;&#125; NSMapEnumerator; 上述结构体描述了遍历一个NSMapTable时的一个指针对象，其中包含table对象自身的指针，计数值，和节点指针。 12345678typedef struct &#123; NSUInteger (*hash)(NSMapTable *table,const void *); BOOL (*isEqual)(NSMapTable *table,const void *,const void *); void (*retain)(NSMapTable *table,const void *); void (*release)(NSMapTable *table,void *); NSString *(*describe)(NSMapTable *table,const void *); const void *notAKeyMarker;&#125; NSMapTableKeyCallBacks; 上述结构体中存放的是几个函数指针，用于计算key的hash值，判断key是否相等，retain，release操作。 12345typedef struct &#123; void (*retain)(NSMapTable *table,const void *); void (*release)(NSMapTable *table,void *); NSString *(*describe)(NSMapTable *table, const void *);&#125; NSMapTableValueCallBacks; 上述存放的三个函数指针，定义在对nsmaptable插入一对key－value时，对value对象的操作。 1234567@interface NSMapTable : NSObject &#123; NSMapTableKeyCallBacks *keyCallBacks; NSMapTableValueCallBacks *valueCallBacks; NSUInteger count; NSUInteger nBuckets; struct _NSMapNode **buckets;&#125; 上面是NSMtabtable真正的描述，可以看出来NSMapTable是一个哈希＋链表的数据结构(也就是使用Hash表中的单链表法解决冲突)，因此在NSMapTable中插入或者删除一对对象时 寻找的时间是O（1）＋O（m），m最坏时可能为n。 O（1）：为对key进行hash得到bucket的位置 O（m）：遍历该bucket后面冲突的value，通过链表连接起来。 因此：NSDictionary中的key Value遍历时是无序的，至如按照什么样的顺序，跟hash函数相关。NSMapTable使用NSObject的哈希函数。 123-(NSUInteger)hash &#123; return (NSUInteger)self&gt;&gt;4;&#125; 上述是NSObject的哈希值的计算方式，简单通过移位实现。右移4位，左边补0.因为对象大多存于堆中，地址相差4位应该很正常。 参考： NSMapTable: more than an NSDictionary for weak pointers Apple API Reference - NSMapTable Apple API Reference - NSHashTable 维基百科 - 哈希表(需要翻下墙，也可以问下度娘) 关于NSDictionary NSDictionary 的内部实现 《Objective-C高级编程：iOS与OS X多线程和内存管理》 ARC的实现","tags":[{"name":"iOS","slug":"iOS","permalink":"http://jake.gift//tags/iOS/"}]},{"title":"removeFromSuperView浅谈","date":"2017-03-29T09:26:16.000Z","path":"2017/03/29/removeFromSuperView浅谈/","text":"Unlinks the receiver from its superview and its window, and removes it from the responder chain. 译：把当前View从它的父View和窗口中移除，同时也把它从响应事件操作的响应者链中移除。 方法调用后的内存管理先来看一段代码： 1234567891011121314151617181920212223UIView *view = [UIView new];self.testView = view;[self.view addSubview:view];self.title = @\"jake\";[self.testView removeFromSuperview];@try &#123; for (int i = 0; i &lt; 10; i ++) &#123; NSLog(@\"前 %ld\", CFGetRetainCount((__bridge CFTypeRef)self.testView)); [self.testView removeFromSuperview]; NSLog(@\"后 %ld\", CFGetRetainCount((__bridge CFTypeRef)self.testView)); self.testView.backgroundColor = [UIColor redColor]; [self.testView setUserInteractionEnabled:YES]; [self.testView removeFromSuperview]; [self.testView setNeedsDisplay]; &#125; &#125; @catch (NSException *exception) &#123; NSLog(@\"name : %@, reason : %@\", exception.name, exception.reason); &#125; @finally &#123; &#125; 这段代码执行不会崩溃，self.testView执行了多次removeFromSuperView也没有问题。 苹果爸爸对这个方法这样说的： The view is also released; if you plan to reuse it, be sure to retain it before sending this message and to release it as appropriate when adding it as a subview of another NSView. 调了这个方法就release了这个view，叫我们想要再次使用就得把它retain下来。 结果我执行上段代码，打印出来testView的retainCount不但没有减少反而增加了1 (;￢＿￢) ，不过在调用完（这个runloop结束）之后还是会release的。好吧，其实reatainCount不能太当回事，之前在MRC时期经常发现retainCount不准确，这主要是因为iOS系统API的引用、或自动释放池导致的，所以retainCount并不能当做可靠的参考。 无论是ARC还是MRC中多次调用removeFromSuperview和addSubview:方法，都不会造成造成重复释放和添加。 永远不要在你的View的drawRect:方法中调用removeFromSuperview。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://jake.gift//tags/iOS/"}]},{"title":"H5跳转Native路由机制的探索","date":"2017-03-24T01:20:47.000Z","path":"2017/03/24/H5跳转Native路由机制的探索/","text":"公司的项目核心业务都在H5，为了提高APP的使用体验，这段时间在重构部分功能业务到Native。重构过程持续了4期（一期1~2周），天天工作量杠杠的（因为追求速度，线上质量打了折扣，现在放慢脚步正在稳固，我才得以写这篇文章，接下来还要继续下一期的重构,又期待又紧张）。在重构过程中，收获到了挺多Native与H5之间交互和一些动态配置的体会，就在这记录下这些风雨历程吧。 ps: 文中不涉及具体代码，主要记录实现的机制和逻辑，之后将代码方案抽离项目后会添加demo地址 功能需求扯一扯：公司现在版本的APP的主业务在H5端，那么我们Native重构的页面就避免不了跟H5之间的交互。这是最基本的需求，完成这个需求的方案已经比较稳定，我们使用自己定义的协议对需要交互的功能进行拦截实现H5到Native的交互。Native到H5的话就直接在控制器内加载指定地址的webView。 很显然，在Native到H5这一步有很大的优化空间。老大提出了这样的要求： 所有跳转的H5地址都需要能够在服务端动态配置，下文称：DymaticH5方案 所有的Native页面能够被H5调起，不管在应用内还APP外，下文称：NativeScheme方案 另外一位H5同事附加提出了一套线上容错方案(拯救了两次线上bug) 所有(有需求)的Native页面都能够通过服务端配置随时替换成H5， 下文称：SwitchPage方案 方案探索DymaticH5方案首先介绍下环境： 我们的在线环境配置文件都放在自己实现的静态接口平台下面称tms，由我们前端部门的同学自己管理，可以方便及时地配合客户端和H5的迭代和更新。 首先我们将所有需要动态化配置(由Native跳到H5)的H5地址页面地址整理放到tms的配置文件中，例如: 12345&#123; home : https://www.baidu.com, mine : https://www.mine.com, news : https://www.news.com&#125; 工程项目中添加与tms配置文件格式相同的plist文件,用于存储当tms上没有配置动态H5地址时的默认H5地址。 整个项目中的H5地址由URLCenter工具类集中管理，获得H5地址后存储在DynamicH5Model中。 DynamicH5Model职责： 获取plist中的H5地址给model赋值 读取tms返回的H5地址给model重新赋值 URLCenter职责： 读取DynamicH5Model中的H5地址 获取调用者传入H5地址所需要带的参数 拼接参数返回调用者需要的完整的H5地址 我们来看一张简单的流程图： APP启动程序先读取plist中的默认H5地址赋值到model，在请求tms配置文件之后，再获取tms中配置的H5地址赋值到model，这样可以保证每个H5地址都可以有值，并且都是我们所需要的最新的地址。如此，即使在线上，不用发版本我们的APP也可以自如地控制和更新每个功能模块跳转的H5页面内容。 当然，每个H5地址需要什么参数还是得调用者自己知道，然后将参数赋值到URLCenter中。 NativeScheme方案 取名叫NativeScheme，当然这个方案跟sheme有关，但也不仅仅是使用sheme。 先说明这个方案最终达到的效果吧： APP中的部分功能模块点击跳转指向本地的哪个页面由服务端控制，不再需要本地固定。可以随时切换功能模块跳转到对应的H5页面还是对应的Native页面，当然前提是这两者页面都有实现。 例如： 在这样的功能块中，每个功能模块点击后通过服务器返回的NativeScheme判断跳转到本地的对应页面。 实现原理： 服务器给每个功能块添加一个nativeScheme的字段, 如 myApp://jakeApp/home 其中 myApp为APP的info.plist配置文件中的URL Scheme 若部分页面初始化时有些必要的参数需要指定，NativeScheme可以附加必要的参数，如myApp://jakeApp/home?homeType=1 工程项目中创建一个nativeScheme.plist，其中存储的是每个nativeScheme对应的本地控制器的名字和控制器初始化的方式（storyboard或xib或frame） 如： 1234567891011&#123; myApp://jakeApp/home : &#123; class : HomeViewController, type : storyboard &#125;, myApp://jakeApp/mine : &#123; class : MineViewController, type : xib &#125;&#125; 整个项目的控制器跳转由URLRouter控制，可传入H5地址或者NativeScheme地址获得将要跳转到的控制器 URLRouter职责: 传入navtiveScheme格式的地址，则从本地navtiveScheme.plist中获取对应控制器并初始化传入从地址中获得的参数 传入H5地址则获得完整的H5地址(若有使用第一节中的DynamicH5方案可以将其传入URLCenter获得地址)，创建webView跳转 APP可通过 URL Scheme唤起，在AppDelegate对应的方法中使用URLRouter跳转到对应的Native页面 方案扩展使用： 我们还可以在nativeScheme判读环节添加一个动态的节点(根据需求)，以实现点击功能块后是跳转到H5页面还是跳转本地的页面(此逻辑不同于本章第三节 “SwitchPage方案”)。可以给每个功能块分别添加 本地scheme地址 和 H5地址 两个字段，用于分别是跳向哪种界面。判断规则可以根据自己的需求来定。 附上NativeScheme的简单流程图： 此方案部分参考：https://github.com/DarielChen/DCURLRouter 感谢作者 SwitchPage方案这套方案的存在，在某种意义上是一套线上的紧急备用方案—-当重构的Native页面出现问题，可以通过此方案将该Native页面替换为H5页面。此方案，可以说是对我们项目现状比较适用，在其他项目中或许存在的意义没有那么大。但是这套原理可以拿来做参考，毕竟SwitchPage可以将任意一个Native页面替换为任意一个H5的页面。 实现原理： 实现逻辑也比较简单， tms上配置需要替换的控制器名字和需要替换成的H5地址的绝对路径，如： 123&#123; HomeViewController : https://www.baidu.com&#125; 重写本地的Nativgation的push方法， 在此方法调用super之前，判断将要跳转的控制器名称在tms请求返回的数据中是否存在，如果存在则跳转webView控制器，不存在则按照原来方法跳转。（可结合NativeScheme方案使用，在URLRouter中实现此逻辑） 附上简单流程图： 总结不足：NativeScheme方案中的参数传递比较地生硬，若是需要跳转的Native控制器需要制定的参数需要额外处理，则无法通过shceme后带参数的方式在URLRouter中直接给要返回的控制器添加参数 上面三套方案可以在项目中一起使用，相互之间不会影响，也可以单独使用其中的某一套方案。 demo地址：即将出现","tags":[{"name":"iOS","slug":"iOS","permalink":"http://jake.gift//tags/iOS/"}]},{"title":"JSPatch遇上Swift","date":"2017-02-08T06:42:27.000Z","path":"2017/02/08/JSPatch遇上Swift/","text":"JSPatch的动态更新是依赖于Objective-C的runtime，那作为静态语言的Swift就没有办法使用JSPatch了吗？Swift类成员还是可以使用Objective-C的运行时动态派发，只要Swift类是继承自NSObject或者使用dynamic修饰的类的成员。 纯Swift类没有动态性 无法重写纯swift类的方法和属性JSPatch在进行到overrideMethod进行方法实现IMP替换时要求class实现NSCoping协议，而不继承自NSObject的swift类是不遵循该协议的，因此会崩溃。 Swift中使用Method Swizzling的原则摘自底部参考资料 继承自NSObject的Swift类，其继承自父类的方法具有动态性，其他自定义方法、属性需要加dynamic修饰才可以获得动态性。 若方法的参数、属性类型为Swift特有、无法映射到Objective-C的类型(如Character、Tuple)，则此方法、属性无法添加dynamic修饰（会编译错误）。 纯Swift类没有动态性，但在方法、属性前添加dynamic修饰可以获得动态性。 官方文档dynamic声明修饰符释义 该修饰符用于修饰任何兼容 Objective-C 的类的成员。访问被dynamic修饰符标记的类成员将总是由OC运行时系统进行动态派发，而不会由编译器进行内联或消虚拟化。 JSPatch上手使用 继承自NSObject的Swift类中 123456class ViewController: UIViewController &#123; override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) self.view.backgroundColor = UIColor.yellow; &#125;&#125; 重载自父类的方法不需要dynamic修饰符进行修饰，可以直接进行JSPatch动态替换。 自定义的Swift方法需要加上dynamic修饰符 12345678910class ViewController: UIViewController &#123; override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) self.view.backgroundColor = UIColor.yellow; &#125;&#125;dynamic func test() &#123; print(\"这是原生的打印\") &#125; Swift中Cocoa的API方法跟Objective-C不同时，JSPatch代码 1234567891011dynamic func paramTest(paramOne: String, paramTwo: String) -&gt; String &#123; return \"原生的字符串\"; &#125; dynamic func paramTest2(_ paramOne: String, withParam paramTwo: String) -&gt; String &#123; return \"原生字符串2\" &#125; dynamic func paramTest3(withParamOne paramOne: String, andParamTwo paramTwo: String) -&gt; String &#123; return \"原生字符串3\" &#125; 1234567891011paramTestWithParamOne_paramTwo: function(paramOne, paramTwo) &#123; return \"JS字符串\" &#125;, paramTest2_withParam: function(paramOne, paramTwo) &#123; return \"JS字符串2\" &#125;, paramTest3WithParamOne_andParamTwo: function(paramOne, paramTwo) &#123; return \"JS字符串3\" &#125;, defineClass中指定类名需要带上项目target的名字 12345678910111213141516171819202122232425require('UIColor')defineClass(\"Swift_JSPatch.ViewController\", &#123; viewWillAppear: function(animated) &#123; self.super().viewWillAppear(animated) self.view().setBackgroundColor(UIColor.redColor()) &#125;, test: function() &#123; console.log(\"JS输出的代码\") &#125;, paramTestWithParamOne_paramTwo: function(paramOne, paramTwo) &#123; return \"JS字符串\" &#125;, paramTest2_withParam: function(paramOne, paramTwo) &#123; return \"JS字符串2\" &#125;, paramTest3WithParamOne_andParamTwo: function(paramOne, paramTwo) &#123; return \"JS字符串3\" &#125;, &#125;, &#123;&#125;) 参考：JSPatch在Swift中的应用","tags":[{"name":"iOS","slug":"iOS","permalink":"http://jake.gift//tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://jake.gift//tags/Swift/"}]},{"title":"Swift和Objective-C的数组转换","date":"2017-01-20T02:45:57.000Z","path":"2017/01/20/Swift和Objective-C的数组转换/","text":"当我们在 Objective-C 代码中使用 Swift 类或者协议时，接入的API会将全部所有类型的Swift数组代替为NSArray。 Swift 的编译器会在接入 Objective-C APIs 的时候将NSArray类替换成AnyObject[] 若我们将一个NSArray对象传递给Swift的API并要求数组元素为一个新的类型，运行时就会产生错误。 如果 Swift API 返回一个不能被转换为NSArray类型的 Swift 数组，错误也会随之产生。 如果某个对象是 Objective-C 或者 Swift 类的实例，或者这个对象可以转换成另一种类型，那么这个对象则属于AnyObject类型的对象 例如，一个Int[]类型的 Swift 数组包含Int结构的元素。Int类型并不是一个类的实例，但由于Int类型转换成了NSNumber类，Int类型属于AnyObject类型的。 Swift数组转换成NSArray: 当我们从 Swift 数组转换为NSArray对象时，Swift 数组里的元素必须是属于AnyObject的。 当我们从一个 Swift 数组转换成一个NSArray对象后，转换后的结果则是一个[ObjectType]类型的数组. NSArray对象转换成Swift数组: 我们可以将任意NSArray对象转换成一个Swift数组，因为所有Objective-C的对象都是AnyObject类型。 如果NSArray对象没有指明一个确切的参数类型，那么它将会转换成[AnyObject]类型的Swift数组。 1234//Objective@property NSArray&lt;NSDate *&gt;* dates;//Swiftvar dates: [NSDate] NSArray对象转换成一个 Swift 数组后，也可以将数组强制类型转换成一个特定的类型。，从AnyObject类型的对象转换成明确的类型并不会保证成功，从AnyObject[]转换为SomeType[]会返回一个 optional 的值。例子： 1234let swiftyArray = foundationArray as AnyObject[]if let downcastedSwiftArray = swiftArray as? UIView[] &#123; // downcastedSwiftArray contains only UIView objects&#125; 也可以在for循环中将NSArray对象定向地强制转换为特定类型的Swift数组: 123for aView: UIView! in foundationArray &#123; // aView is of type UIView&#125; 参考：Using Swift with Cocoa and Objective-C","tags":[{"name":"iOS","slug":"iOS","permalink":"http://jake.gift//tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://jake.gift//tags/Swift/"}]},{"title":"Using Swift With Cocoa and Objective-C笔记_ONE","date":"2017-01-19T07:49:18.000Z","path":"2017/01/19/Using-Swift-with-Cocoa-and-Objective-C笔记-ONE/","text":"Objective-C和Swift的非空值、可选值转换Objective-C 能够使用空值标记来设定一个参数类型，属性类型或者返回值类型是否可以为 NULL 或者 为 nil 值。单独的类型声明可以使用nullable和nonnull标注，空值的范围性的声明可以使用NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END宏。如果一个类型没有任何的空值标注信息，Swift 就不能分辨出可选值和非可选值类型，并且将作为隐式的解包可选值导入。 以__nonnull或者范围宏标注声明的空值类型，被作为非空可选值non-optional导入到 Swift。 以__nullable标注声明的空值类型，被作为可选值导入到 Swift。 没有以空值标注声明的类型被作为隐式的解包可选值导入到 Swift。 Objective-C申明 1234567891011@property (nullable) id nullableProperty;@property (nonnull) id nonNullProperty;@property id unannotatedProperty;NS_ASSUME_NONNULL_BEGIN- (id)returnsNonNullValue;- (void)takesNonNullParameter:(id)value;NS_ASSUME_NONNULL_END- (nullable id)returnsNullableValue;- (void)takesNullableParameter:(nullable id)value;- (id)returnsUnannotatedValue;- (void)takesUnannotatedParameter:(id)value; 导入Swift中： 123456789var nullableProperty: AnyObject?var nonNullProperty: AnyObjectvar unannotatedProperty: AnyObject!func returnsNonNullValue() -&gt; AnyObjectfunc takesNonNullParameter(value: AnyObject)func returnsNullableValue() -&gt; AnyObject?func takesNullableParameter(value: AnyObject?)func returnsUnannotatedValue() -&gt; AnyObject!func takesUnannotatedParameter(value: AnyObject!) 闭包和Block的交互Objective-C 中的blocks会被自动导入为 Swift 中的闭包。例如，下面是一个 Objective-C 中的 block 变量： 1void (^completionBlock)(NSData *, NSError *) = ^(NSData *data, NSError *error) &#123;/* ... */&#125; 而它在 Swift 中的形式为: 1let completionBlock: (NSData, NSError) -&gt; Void = &#123;data, error in /* ... */&#125; Swift 的闭包与 Objective-C 中的 blocks 能够和睦相处，所以你可以把一个 Swift 闭包传递给一个把 block 作为参数的 Objective-C 函数。Swift 闭包与函数具有互通的类型，所以你甚至可以传递 Swift 函数的名字。 闭包与 blocks 语义上相通但是在一个地方不同：变量是可以直接改变的，而不是像 block 那样会拷贝变量。换句话说，Swift 中变量的默认行为与 Objective-C 中 __block 变量一致。 Swift类型兼容性 @objc 和 dynamic@objc可以让你的 Swift API 在 Objective-C 中使用。换句话说，你可以通过在任何 Swift 方法、类、属性前添加@objc，来使得他们可以在 Objective-C 代码中使用。如果你正在使用如键值观察的 API 来动态替换方法的实现，也可以通过使用dynamic修饰符来获得对 Objective-C 运行时被自动派发的成员的访问。 当你在 Objective-C 中使用 Swift API，编译器通常会对语句做直接的翻译。例如，Swift API func playSong(name: String)会被解释为- (void)playSong:(NSString *)name。然而，有一个例外：当在 Objective-C 中使用 Swift 的初始化函数，编译器会在方法前添加“initWith”并且将原初始化函数的第一个参数首字母大写。例如，这个 Swift 初始化函数init (songName: String, artist: String)将被翻译为- (instancetype)initWithSongName:(NSString *)songName artist:(NSString *)artist。 Swift 同时也提供了一个@objc关键字的变体，通过它你可以自定义在 Objective-C 中转换的函数名。 例子： 12345678//Swift@objc(Squirrel)class Белка &#123; @objc(initWithName:) init (имя: String) &#123; /*...*/ &#125; @objc(hideNuts:inTree:) func прячьОрехи(Int, вДереве: Дерево) &#123; /*...*/ &#125;&#125; 轻量级泛型123@property NSArray&lt;NSDate *&gt;* dates;@property NSSet&lt;NSString *&gt;* words;@property NSDictionary&lt;KeyType: NSURL *, NSData *&gt;* cachedData; 123var dates: [NSDate]var words: Set&lt;String&gt;var cachedData: [NSURL: NSData] 注意 除了 Foundation 中的集合类， Objective-C 的轻量级泛型会被 Swift 忽略掉。任何其他使用轻量级泛型的类型在导入到 Swift 中时会被视为无参数化。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://jake.gift//tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://jake.gift//tags/Swift/"}]},{"title":"Swift的weak Unowned Unowned(unsafe)","date":"2017-01-19T03:56:19.000Z","path":"2017/01/19/Swift的weak-unowned-unowned-unsafe/","text":"Swift同样也是用ARC管理内存，为了解决引用循环。同OC一样使用weak修饰对象，在weak引用指向的对象被释放之后，其自身会被置为nil也会被释放。 而在Swift中nil是Optional的专属，对于非可选类型，则使用无主引用：unowned 使用无主引用，你必须确保引用始终指向一个未销毁的实例。如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。 安全无主引用unowned指向的对象被释放之后，其自身不会被置为nil，也不可访问。 不安全无主引用unowned（unsafe）指向的对象被释放之后，你试图去访问这个引用，程序会尝试访问该实例之前坐在的内存地址，这是一个不安全的操作 使用场景解析：前提描述： A类中有一个B类的属性， B类中有一个A类的属性 两个属性的值都允许为nil，并会潜在产生循环引用 这种情况适合使用weak来解决 其中一个属性的值允许为nil，而另一个不允许为nil 这种情况最适合通过无主引用来解决 两个属性都必须有值，并且初始化完成后永远不会为nil 这种情况，需要一个雷使用无主属性，为另外一个类使用隐式解析可选属性 场景3例子： 1234567891011121314151617class Country &#123; let name: String var capitalCity: City! init(name: String, capitalName: String) &#123; self.name = name self.capitalCity = City(name: capitalName, country: self) &#125; &#125;class City &#123; let name: String unowned let country: Country init(name: String, country: Country) &#123; self.name = name self.country = country &#125; &#125; 解决闭包引起的循环引用 Swift 有如下要求：只要在闭包内使用 self 的成员，就要用 self.someProperty 或者 self.someMethod() 不只是 someProperty 或 someMethod() ）。这提醒你可能会一不小心就捕获了 self 。 第一捕获列表解决循环引用，例子： 捕获列表中的每一项都由一对元素组成，一个元素是 weak 或 unowned 关键字，另一个元素是类实例的引用 1234lazy var someClosure: (Int, String) -&gt; String = &#123; [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in // 这里是闭包的函数体 &#125; 如果被捕获的引用绝对不会变为 nil ，应该用无主引用，而不是弱引用。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://jake.gift//tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://jake.gift//tags/Swift/"}]},{"title":"Cookie in iOS","date":"2017-01-12T08:37:13.000Z","path":"2017/01/12/cookie-in-iOS/","text":"背景项目中用到了本地登录存储cookie，再进行webView请求时间带上cookie的功能。不是很清晰逻辑，于是学习了解了下iOS中cookie的使用，做个小结。跳过概念直接看使用🌰 Cookie介绍Cookie分类两类： 会话cookie 持久cookie 会话 cookie 和持久 cookie 之间唯一的区别就是它们的过期时间。 cookie如何工作 cookie 中包含了一个由 名字 = 值 （name=value） 这样的信息构成的任意列表，并通过 Set-Cookie 或 Set-Cookie2 HTTP 响应（扩 展）首部将其贴到用户身上去。 cookie组成现在使用的 cookie 规范有两个不同的版本：cookies 版本 0（有时被称为 Netscape cookies） 和 cookies 版 本 1（RFC 2965） 。 cookies 版 本 1 是 对 cookies 版 本 0 的 扩 展，应用不如后者广泛。 cookie版本0 Set-Cookie 首部Set-Cookie 首部有一个强制性的cookie名和cookie值。后面跟着可选的cookie 属性，中间由分号分隔。 cookie 0首部: 1Cookie: session-id=002-1145265-8016838; session-id-time=1007884800 cookie版本1 Set-Cookie2首部这个版本 1 标准引入了Set-Cookie2首部和Cookie2首部，但它也能于版本0进行交互操作。 cookie 1首部: 12345Cookie: $Version=&quot;1&quot;;ID=&quot;29046&quot;; $Domain=&quot;.joes-hardware.com&quot;;color=&quot;blue&quot;;Coupon=&quot;hammer027&quot;; $Path=&quot;/tools&quot;;Coupon=&quot;handvac103&quot;; $Path=&quot;/tools/cordless&quot; NSHTTPCookieStorage NSHTTPCookieStorage implements a singleton object (shared instance) that manages storage of cookies. Each cookie is represented by an instance of the NSHTTPCookie class. As a rule, cookies are shared among all applications and are kept in sync across process boundaries. Session cookies (where the cookie object’s sessionOnly method returns YES) are local to a single process and are not shared. NSHTTPCookieStorage的实现是一个单例对象，管理着NSHTTPCookie对象，会话cookie的 sessionOnly方法返回YES就不可在进程间共享。 然而苹果在这个类的API Reference中写了一个iOS Note： Cookies are not shared among applications in iOS. iOS中cookie不能跨应用共享 MacOS中sessionOnly不为YES是可以被共享的 NSHTTPCookieStorage可以管理cookie的接受策略，在一个app中改变cookie的接受策略将会影响其他正在运行的app的cookie接受策略。 当其他的app修改了cookie存储 或者 cookie接受策略，NSHTTPCookieStorage将会给app发送NSHTTPCookieManagerCookiesChangedNotification或者NSHTTPCookieStorageAcceptPolicyChangedNotification通知 Cookie接受策略：NSHTTPCookieAcceptPolicy 12345typedef NS_ENUM(NSUInteger, NSHTTPCookieAcceptPolicy) &#123; NSHTTPCookieAcceptPolicyAlways,//默认策略，接受所有的cookies NSHTTPCookieAcceptPolicyNever,//拒绝所有的cookies NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain//只从主文档域名接受cookies&#125;; NSHTTPCookie An NSHTTPCookie object represents an HTTP cookie. It is an immutable object, initialized from a dictionary containing the cookie attributes. NSHTTPCookie对象中包含了HTTP 的cookie对象，从包含cookie字段的字典初始化创建。 The NSHTTPCookie class encapsulates a cookie, providing accessors for many of the common cookie attributes. This class also provides methods to convert HTTP cookie headers to NSHTTPCookie instances and convert an NSHTTPCookie instance to headers suitable for use with an NSURLRequest object. The URL loading system automatically sends any stored cookies appropriate for an NSURLRequest object unless the request specifies not to send cookies. Likewise, cookies returned in an NSURLResponse object are accepted in accordance with the current cookie acceptance policy. NSHTTPCookie类封装了一个HTTP Cookie，并提供常见的Cookie属性访问接口。NSHTTPCookie可以转换HTTP Cookie成NSHTTPCookies对象，并可以将NSHTTPCookie对象转化为NSURLRequest对象的请求头部分。URL loading system 会自动地给NSURLRequest对象发送存储的cookie，除非NSURLRequest对象指定不需要传cookie，同样cookie在NSURLRequest中返回也按照当前的cookie接受策略接收。 Cookie使用💪个🌰Cookie生成的有两个途径，一个是访问一个网页，这个网页返回的HTTP Header中有Set-Cookie指令进行Cookie的设置，这里Cookie的本地处理其实是由WebKit进行的；还有一种途径就是客户端通过代码手动设置Cookie。 值得注意iOS Cookie使用提到：NSHTTPCookieStorage存在一个问题，setCookie或者deleteCookie后并不会立即进行持久化，而是有几秒的延迟。为了可靠性，我们会将cookie信息保存一份到User Defaults，需要用的时候load进来。 客户端手动设置Cookie 12345678910NSMutableDictionary *cookieProperties = [NSMutableDictionary dictionary];[cookieProperties setObject:@\"name\" forKey:NSHTTPCookieName];[cookieProperties setObject:@\"value\" forKey:NSHTTPCookieValue];[cookieProperties setObject:@\"www.taobao.com\" forKey:NSHTTPCookieDomain];[cookieProperties setObject:@\"/\" forKey:NSHTTPCookiePath];[cookieProperties setObject:@\"0\" forKey:NSHTTPCookieVersion];[cookieProperties setObject:@\"30000\" forKey:NSHTTPCookieMaximumAge];NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:cookieProperties];[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];//删除cookie的方法为deleteCookie: 在通过setCookie:进行设置cookie的时候，会覆盖name,domain,path都相同的cookie的。至于cookie会不会持久化到cookie文件中主要看这个cookie的生命周期，和Max-Age或者Expires有关。 通过HTTP Header的Set-Cookie后者Set-Cookie2设置Cookie 123456789101112131415161718192021222324252627282930313233343536373839404142 //请求一个网址，即可分配到cookie AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; manager.responseSerializer = [AFJSONResponseSerializer new]; [manager GET:urlString parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //获取cookie NSArray *cookies = [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookies]; /* * 把cookie进行归档并转换为NSData类型 * 注意：cookie不能直接转换为NSData类型，否则会引起崩溃。 * 所以先进行归档处理，再转换为Data */ NSData *cookiesData = [NSKeyedArchiver archivedDataWithRootObject: [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookies]]; //存储归档后的cookie NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; [userDefaults setObject: cookiesData forKey: @\"cookie\"]; [self setCookie]; &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; &#125;]; - (void)setCookie&#123; //取出保存的cookie NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; //对取出的cookie进行反归档处理 NSArray *cookies = [NSKeyedUnarchiver unarchiveObjectWithData:[userDefaults objectForKey:@\"cookie\"]]; if (cookies) &#123; //设置cookie NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage]; for (id cookie in cookies) &#123; [cookieStorage setCookie:(NSHTTPCookie *)cookie]; &#125; &#125;else&#123; NSLog(@\"无cookie\"); &#125; &#125; 参考NSHTTPCookieStorage Cookies and Custom Protocols http://geeklu.com/2013/04/ios-cookie/ http://blog.it985.com/11248.html 《HTTP 权威指南》第11章 客户端识别与cookie机制 相关导引解决UIWebView和WKWebView之间的cookie共享问题： iOS开发-打通UIWebView和WKWebView的Cookie","tags":[{"name":"iOS","slug":"iOS","permalink":"http://jake.gift//tags/iOS/"}]},{"title":"Objective-C中的装饰模式","date":"2017-01-10T06:34:56.000Z","path":"2017/01/10/Objective-C中的装饰模式/","text":"背景前段时间接触到了装饰模式，也做了基本的了解，但是还不是很清楚它在iOS开发中的实际运用，和合理的存在方式。这两天看了《Objective-C编程之道：iOS设计模式解析》 中的第16章，有了更加深的理解，结合自己的理解在这里做一下记录。 什么是装饰模式就描述概念而言，我觉得《Head First 设计模式》这本书通过各种例子阐述得要更加详细易懂。《Objective-C编程之道：iOS设计模式解析》讲得更多是iOS开发中的使用和不同实现方式的对比。标准的装饰模式有包括一个抽象的Component父类，它声明了一些操作，它具体的类讲进行重载以实现自己特定的操作。这个Component具体类是模式中的被装饰者，Component父类可以被细化为另一个叫做Decorator的抽象类，即装饰者抽象类。Decorator类中包含了一个Component的引用。Decorator的具体类为Component或者Decorator定义了几个扩展行为，并且会在自己的操作中内嵌Component操作。关系图见 装饰模式类图 Component定义了一些抽象操作，具体类将进行重载实现自己特定的操作。Decorator抽象类通过将一个Component（或Decorator）内嵌到Decorator对象，定义了扩展这个Component的实例的“装饰性”的行为。 默认的operation方法只是想内嵌的Component发送一个消息，Decorator的具体实现类重载父类的operation，通过super把自己增加的行为扩展给Component的operation。如果只需要向Component添加一种职责，那可以省掉抽象的Decorator类，让具体的Decorator直接把请求转发给Component。那么这种方式就好像形成一种操作链，把一种行为加到另一种行为之上，如对象图 装饰模式类图 何时使用装饰模式 想要在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。 想要扩展一个类的行为，却做不到。类定义可能被隐藏，无法进行子类化；或者对类的每个行为的扩展，为支持每种功能组合，将产生大量的子类 对类的职责的扩展是可选的。 装饰模式在iOS中的实现根据Objective-C的特性，有两种实现方式： 通过真正的子类实现装饰 通过分类实现装饰 第二种方式是使用了Objective-C的语言功能，通过分类向类添加行为，不必进行子类化，这并非标准的装饰模式结构，但是实现了装饰模式同样的需求。尽管使用分类来实现装饰模式跟原始风格有偏离，但是实现少量的装饰器的时候，它比真正子类方式更加轻量、更加容易。 例子是使用装饰实现UIImage的滤镜功能 终于要见代码了~ 真子类实现装饰先看目录结构： Component抽象类是一个Protocol文件， 123456789@protocol ImageComponent &lt;NSObject&gt;@optional- (void)drawAsPatternInRect:(CGRect)rect;- (void)drawAtPoint:(CGPoint)point;- (void)drawAtPoint:(CGPoint)ponit blendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha;- (void)drawInRect:(CGRect)rect;- (void)drawInRect:(CGRect)rect blendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha;@end UIImage_ImageComponent.h是UIImage的一个Extension，让UIImage遵循ImageComponent协议。如此在装饰模式中UIImage类是ImageComponent抽象类的具体类，即UIImage是模式中的被装饰者。 Decorator抽象类ImageFilter遵守ImageComponent协议，并定义了三个方法和一个ImageComponent协议的代理对象属性。 1234567@interface ImageFilter : NSObject &lt;ImageComponent&gt;- (void)apply;- (id)initWithImageComponent:(id &lt;ImageComponent&gt;) component;- (id)forwardingTargetForSelector:(SEL)aSelector;- @end 123456789101112131415161718192021222324@interface ImageFilter ()@property (nonatomic, strong) id &lt;ImageComponent&gt; component;@end@implementation ImageFilter- (instancetype)initWithImageComponent:(id&lt;ImageComponent&gt;)component &#123; if (self = [super init]) &#123; [self setComponent:component]; &#125; return self;&#125;- (void)apply &#123; //由子类重载&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123; NSString *selectorName = NSStringFromSelector(aSelector); if ([selectorName hasPrefix:@\"draw\"]) &#123; [self apply]; &#125; return self.component;&#125;@end 在Decorator抽象类的具体实现类中去重载apply方法，当发送以”draw”开头的消息时，先执行Decorator具体类中的apply方法，然后再执行Component具体类即UIImage类（被装饰者）中的”draw”开头的那个方法。如此实现了对UIImage对应的”draw”开头方法动态添加行为。 具体的使用代码如下： 123456789101112131415- (void)viewDidLoad &#123; [super viewDidLoad]; UIImage *image = [UIImage imageNamed:@\"avatar.jpg\"]; CGAffineTransform rorateTransform = CGAffineTransformMakeRotation(-M_PI / 4); CGAffineTransform translateTransform = CGAffineTransformMakeTranslation(-image.size.width / 2.0, image.size.height / 8.0); CGAffineTransform finalTransform = CGAffineTransformConcat(rorateTransform, translateTransform); id&lt;ImageComponent&gt;transformdImage = [[ImageTransformFilter alloc] initWithImageComponent:image transform:finalTransform]; id&lt;ImageComponent&gt;finalImage = [[ImageShadowFliter alloc] initWithImageComponent:transformdImage]; DecoratorView *decoratorView = [[DecoratorView alloc] initWithFrame:self.view.frame]; [decoratorView setImage:finalImage]; [self.view addSubview:decoratorView];&#125; 由DecoratorView中的drawRect：调起UIImage的装饰 123456@implementation DecoratorViewduring animation.- (void)drawRect:(CGRect)rect &#123; [self.image drawInRect:rect];&#125;@end 类图如下: 各种ImageComponent对象可在运行时进行连接，如下图： 分类实现装饰分类方式实现就是平常开发中常见的使用，代码就不再一一列出 类图如下： BaseFilter分类中定义了绘图的方法，Transform和shadow分类中可以调用BaseFilter分类中定义的方法来进行自己的绘制。他们也可以像真正子类化方式那样链接起来，来看对象图: 总结装饰模式在Objective-C中有两种不同的实现方式，真正子类方式的实现使用一种较为结构化的方式链接各种装饰器，分类的方式更加简单和轻量，使用于现有类只需要少量装饰器的应用。 参考：《Objective-C编程之道：iOS设计模式解析》第16章，（190-206）demo地址：GitHub","tags":[{"name":"iOS","slug":"iOS","permalink":"http://jake.gift//tags/iOS/"}]},{"title":"继承与代理--Decorate Pattern","date":"2017-01-04T09:51:11.000Z","path":"2017/01/04/继承与代理-Decorate-Pattern/","text":"场景写这篇文章的背景是在看casatwy的网络层架构代码时对子类继承和协议代理方的实现产生了疑惑，进行了探索。 问题问题情景：父类的方法列表中和协议中有同样的方法（代码如下），子类继承方法同时代理方也实现协议方法，那么当父类调用decoratePatternTest这个方法时具体的执行方是谁？子类同时是代理方和不是代理方分别有什么样的情况呢？ 12345678910#import &lt;Foundation/Foundation.h&gt;@protocol BaseDecorateDelegate &lt;NSObject&gt;- (NSString *)decoratePatternTest;@end@interface BaseProtocolTest : NSObject@property (nonatomic, weak) id&lt;BaseDecorateDelegate&gt; decorate;- (NSString *)decoratePatternTest;- (void)startTest;@end casatwy注释在casatwy的代码中遇到上述问题的有BaseAPIManager拦截器代码部分，作者的注释如下： 1234567891011/* 拦截器的功能可以由子类通过继承实现，也可以由其它对象实现,两种做法可以共存 当两种情况共存的时候，子类重载的方法一定要调用一下super 然后它们的调用顺序是BaseManager会先调用子类重载的实现，再调用外部interceptor的实现 notes: 正常情况下，拦截器是通过代理的方式实现的，因此可以不需要以下这些代码 但是为了将来拓展方便，如果在调用拦截器之前manager又希望自己能够先做一些事情，所以这些方法还是需要能够被继承重载的 所有重载的方法，都要调用一下super,这样才能保证外部interceptor能够被调到 这就是decorate pattern */ 注释中提到： 子类继承和代理方实现协议可以共存 两种共存时子类重载的方法必须要调用父类方法 两者调用顺序是先实现子类重载的方法再调用代理方实现的方法 最后提到的是 Decorate Pattern 装饰者模式 分情况实现验证 子类继承父类方法 &amp; 子类没有遵守父类协议 &amp; 其他类遵守协议实现代理方法 子类继承父类方法 &amp; 遵守父类协议 父类方法： 123456789- (NSString *)decoratePatternTest &#123; NSLog(@\"执行父类decoratePatternTest\"); NSString *string = @\"基类中实现decoratePatternTest\"; if (self != self.decorate &amp;&amp; [self.decorate respondsToSelector:@selector(decoratePatternTest)]) &#123; string = [self.decorate decoratePatternTest]; &#125; return string;&#125; 子类方法： 123456- (NSString *)decoratePatternTest &#123; [super decoratePatternTest]; NSLog(@\"子类执行decoratePatternTest\"); return @\"子类中实现decoratePatternTest\";&#125; 非子类代理者方法： 12345- (NSString *)decoratePatternTest &#123; NSLog(@\"执行过代理方实现decoratePatternTest\"); return @\"代理方实现decoratePatternTest\";&#125; 测试结果： 父类 子类 Other 父类 子类 Other 遵守协议实现方法 - N Y - Y N 继承方法 - Y N - Y N 方法执行顺序 2 1 3 2 1 - 关键其实问题的关键是在代理者的协议方法调用的时机。 当子类继承了方法又是代理者，那么在父类方法中通过（self != self.decotate）来判断不用再去执行协议中的方法 子类不是代理者没有继承方法，则在父类方法中调用代理者执行协议方法 子类不是代理者但是继承了方法，父类调用代理者协议方法 两个方法的调其顺序是 子类中方法 -&gt; 父类中方法 -&gt; 代理者方法 两个方法中的有效代码执行顺序要看 子类方法中 super调用的位置 (super调用在子类有效代码前则 代理者方法的代码先执行)——-&gt;见最后一节Decorate Pattern 装饰者模式 代码中不用调用父类方法的情况作者的代码BaseAPIManager中的reformerParams方法在父类实例方法和协议方法中存在，但是子类继承实现时并不需要调用父类的 reformerParams，原因是父类中作了如下处理： 1234567891011121314151617181920212223242526272829303132333435- (instancetype)init&#123; self = [super init]; if (self) &#123; if ([self conformsToProtocol:@protocol(BaseProtocolDelegate)]) &#123; self.child = (id &lt;BaseProtocolDelegate&gt;)self; &#125; else &#123; NSException *exception = [[NSException alloc] init]; @throw exception; &#125; &#125; return self;&#125;- (NSString *)reformerParams &#123; NSLog(@\"执行父类reformerTest\"); IMP childIMP = [self.child methodForSelector:@selector(reformerTest)]; IMP selfIMP = [self methodForSelector:@selector(reformerTest)]; if (childIMP == selfIMP) &#123; return @\"子类没有继承此方法\"; &#125; else &#123; // 如果child是继承得来的，那么这里就不会跑到，会直接跑子类中的IMP。 // 如果child是另一个对象，就会跑到这里 NSString *result = nil; result = [self.child reformerParams]; if (result) &#123; return result; &#125; else &#123; return @\"default\"; &#125; &#125;&#125; 初始化方法中首先保证子类必须遵守了BaseProtocolDelegate协议 子类实现了reformerParams方法并没有调用super并不会出发父类的reformerParams 根据消息传递机制父类reformerParams 方法会被调用说明子类没有实现此方法，那么执行非子类代理者的协议方法 父类要求子类必须遵守协议，那么此协议BaseProtocolDelegate更多的用处是获取子类对象 Decorate Pattern 装饰者模式 装饰者模式动态地将责任附件到对象上，若要扩展功能，装饰着提供了比继承更具有弹性的方案。 装饰者模式的设计原则：可以随心为一个类扩展功能，但不允许对已经存在的代码进行修改。 装饰者模式的主要特点： 装饰者模式类图： 实际的例子：java中常用的java.io类就存在着大量装饰者 以上内容摘自《Head First设计模式》 第三章 装饰者模式 （79-107） 对应到iOS中本文的场景： 被装饰者 功能组件 装饰者 委托方父类 代理方OtherObject（非子类） 子类 其实在思考装饰者模式对应情况上，有点疑惑： 装饰者类Decorator没有找到对应的类 但装饰者模式中的关键点： 装饰者可以在被所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定目标。 在本文的例子中有明显体现：子类继承的方法中调用super方法，在这之前或者之后可以加上自己的行为，达到特定目标。 对装饰者模式的理解还比较基础有待继续研究……欢迎指正指导，谢谢！ iOS中装饰者模式的实现的后续研究请看Objective-C中的装饰模式","tags":[{"name":"iOS","slug":"iOS","permalink":"http://jake.gift//tags/iOS/"}]},{"title":"知识传送门","date":"2016-12-29T01:11:11.000Z","path":"2016/12/29/知识传送门/","text":"大神博客传送门 onevcat 喵神 王巍 sunnyxx 孙源 bang 没故事的卓同学 Casa Taloyum 唐巧 学习平台传送门 swifter.tips Objc中国 泊学 swiftv objc.io Swift学习指引 Google Interview University FreeCodeCamp iOS干货传送门 iOS 下关于 MD5 的那个坑 Xcode下调试神器——Chisel Swift和Objective混编攻略 Swift中编写单例的正确方式 xib的全方位使用技巧 书籍 程序员书单","tags":[{"name":"随笔","slug":"随笔","permalink":"http://jake.gift//tags/随笔/"}]},{"title":"JSPatch学习分享","date":"2016-12-23T02:38:08.000Z","path":"2016/12/23/JSPatch学习分享/","text":"App热更新技术——JSPatch学习分享 如果不清楚本文的主角 JSPatch是什么请看我博客中的JSPatch学习笔记： 这里 和 这里 背景iOS Developer Program License Agreement里3.3.2提到不可动态下发可执行代码，但通过苹果JavaScriptCore.framework或WebKit执行的代码除外，JS正是通过JavaScriptCore.framework执行的。 基础原理JSPatch 能做到通过 JS 调用和改写 OC 方法最根本的原因是 Objective-C 是动态语言，OC 上所有方法的调用/类的生成都通过 Objective-C Runtime 在运行时进行，我们可以通过类名/方法名反射得到相应的类和方法： 1234Class class = NSClassFromString(\"UIViewController\");id viewController = [[class alloc] init];SEL selector = NSSelectorFromString(\"viewDidLoad\");[viewController performSelector:selector]; 也可以替换某个类的方法为新的实现： 12static void newViewDidLoad(id slf, SEL sel) &#123;&#125;class_replaceMethod(class, selector, newViewDidLoad, @\"\"); 还可以新注册一个类，为类添加方法： 123Class cls = objc_allocateClassPair(superCls, \"JPObject\", 0);objc_registerClassPair(cls);class_addMethod(cls, selector, implement, typedesc); 理论上可以在运行时通过类名/方法名调用到任何 OC 方法，替换任何类的实现以及新增任意类。JSPatch 的基本原理就是：JS 传递字符串给 OC，OC 通过 Runtime 接口调用和替换 OC 方法。 JSPatch实现原理详解 Demo展示demo地址 疑问：热修复都需要重启App后才能生效吗？ demo 中对以上疑问有实现，具体的原理理解下一节 方法替换 对demo代码的具体解释请看 这里 方法替换OC上，每个类底层都是这样一个结构体： 123456789101112struct objc_class &#123; Class isa; Class super_class; const char *name; long version; long info; long instance_size; struct objc_ivar_list *ivars; struct objc_method_list **methodLists; /*方法链表*/ struct objc_cache *cache; struct objc_protocol_list *protocols; &#125; 其中 methodList 方法链表里存储的是 Method 类型： 123456typedef struct objc_method *Method;typedef struct objc_ method &#123; SEL method_name; char *method_types; IMP method_imp;&#125;; Method 保存了一个方法的全部信息，包括 SEL 方法名，type 各参数和返回值类型，IMP 该方法具体实现的函数指针。 通过 Selector 调用方法时，会从 methodList 链表里找到对应Method进行调用，这个 methodList 上的的元素是可以动态替换的，可以把某个 Selector 对应的函数指针IMP替换成新的，也可以拿到已有的某个 Selector 对应的函数指针IMP，让另一个 Selector 跟它对应，Runtime 提供了一些接口做这些事 JSPatch脚本文件下发加密接入 JSPatch 时做 RSA 非对称加密传输 开发者自己在 APP 接入 JSPatch，若开发者没有针对传输的 JSPatch 脚本加密。攻击者就通过网络传输的中间人攻击手段下发恶意脚本到用户APP 动态更新方案对比：JSPatch vs React Native 学习成本 React Native 是从 web 前端开发框架 React 延伸出来的解决方案，主要解决的问题是web页面在移动端性能低的问题。若使用React Native，就意味着iOS开发者需要学习web前端的一整套开发技能 JSPatch 是从终端开发出发的一种方案，JSPatch 写出来的代码风格与 OC 原生开发一致，加上一点 JS 语法的了解，就可以使用 接入成本 React Native 需要搭建一套开发环境，有很多依赖的库。React Native 是比较大的框架，据统计目前核心代码里 OC 和 JS 代码加起来有4w行，接入后安装包体积增大 1.8M 左右 JSPatch 是微型框架，只有 3 个文件 2k 行代码，接入后增大 100K 左右 开发效率 React Native 用近似 HTML+CSS 去绘制 UI，这方面开发效率相对 JSPatch 会高些，另外React Native 在开发效率上的另一个优势是支持跨平台，React Native 本意是复用逻辑层代码，UI 层根据不同平台写不同的代码 JSPatch 也可以借助 iOS 一些成熟的库去提高效率，例如使用 Massory。（尝试了其实也是相当吃力） 热更新能力 React Native 在热更新时无法使用事先没有做过桥接的原生组件 JSPatch 可以调用到任意已在项目里的组件，以及任意原生 framework 接口 方案对比表格： 学习成本 接入成本 热更新能力 开发效率 性能体验 JSPatch 低 低 高 中，不跨平台 高 React Native 高 高 中 高，跨平台 高 JSPatch vs Wax 对JSPatch的思考 进行热更新后下一个版本需要将JS代码修改为原生代码，不能停留超过一个版本。 编写JS脚本文件，调用OC原生的方法（方法名长得可怕）没有代码补全提示和高亮，显得非常吃力。 当要进行热修复的方法是一个代码量很大的方法，需要用JS重写这个方法，这会很痛苦。 新方案 : DynamicCocoa优势所在： 使用原生技术栈：使用者完全不用接触到 JS 或任何中间代码，保持原生的 Objective-C 开发、调试方式不变 无需重写已有代码：已有 native 模块能很方便的变成动态化插件 语法支持完备性高：支持绝大多数日常开发中用到的语法，不用担心这不支持那不支持 支持 HotPatch：改完 bug 后直接从源码打出 patch，一站式解决动态化和热修复需求 资源的支持,动态 bundle 支持： xib 和 storyboard xcassets 不放在 xcassets 里的图片资源 其他资源文件 DynamicCocoa：滴滴 iOS 动态化方案的诞生与起航","tags":[{"name":"iOS","slug":"iOS","permalink":"http://jake.gift//tags/iOS/"}]},{"title":"Objective-C Isa指针","date":"2016-12-19T05:52:37.000Z","path":"2016/12/19/Objective-C-isa指针/","text":"1. 什么是isa指针首先来看一下，NSObject的定义（不含方法定义）： 123@interface NSObject &lt;NSObject&gt; &#123; Class isa;&#125; 在Objective-C中，@interface关键字可以看着是C语言中的struct关键字的别名，当然他还会有一些其它功能，比如说让编译器知道@interface后后面的是一个Objective-C的类的名字等。但就我们研究其内存布局来说，我们简单地将其替换为struct，并将protocal定义去掉。因此，NSObject的定义就是样： 123struct NSObject&#123; Class isa;&#125; 那个这个Class又是什么呢？在objc.h中我们发现其仅仅是一个结构(struct)指针的typedef定义: typedefstruct objc_class *Class; 因此，NSObject的定义就像这个样子： 123struct NSObject&#123; objc_class *isa&#125; isa就是“is a”，对于所有继承了NSObject的类其对象也都有一个isa指针。这个isa指针指向的东西(先这样称呼它吧)就是关于这个对象所属的类的定义。 每一个Objective-C对象的底层都是这样的一个C结构体： 123456struct objc_class &#123; struct objc_class * isa; const char *name; …. struct objc_method_list **methodLists; /*方法链表*/&#125;; 这个结构体中的第一个成员变量，就是isa指针。 2. isa指针的指向实例对象的isa指针指向是其所属的类对象，这个类对象包含了该实例对象的一些信息（例如：实例列表、方法列表等）。isa指针的类型是还是一个结构体 objc_class 其实也就是指向地址的类对象的结构，接下来看下 该objc_class的具体结构： 1234567891011121314151617struct objc_class &#123; Class isa; Class super_class; const char *name; long version; long info; long instance_size; struct objc_ivar_list *ivars; struct objc_method_list **methodLists; struct objc_cache *cache; struct objc_protocol_list *protocols; &#125; 一个objc_class对象包括一个类的：父类定义(super_class), 变量列表，方法列表，还有实现了哪些协议(Protocal) 这个结构中还有一个isa指针，它在这里（类对象中）指向的是元类对象(metaclass object)。在Objective-C中任何的类定义都是对象。即在程序启动的时候任何类定义都对应于一块内存。在编译的时候，编译器会给每一个类生成一个且只生成一个”描述其定义的对象”,也就是水果公司说的类对象(class object),他是一个单例(singleton), 而我们在C++等语言中所谓的对象，叫做实例对象(instance object)。对于实例对象我们不难理解，但类对象(class object)是干什么吃的呢？我们知道Objective-C是门很动态的语言，因此程序里的所有实例对象(instace objec)都是在运行时由Objective-C的运行时库生成的，而这个类对象(class object)就是运行时库用来创建实例对象(instance object)的依据。 任何直接或间接继承了NSObject的类，它的实例对象(instacne objec)中都有一个isa指针，指向它的类对象(class object)。这个类对象(class object)中存储了关于这个实例对象(instace object)所属的类的定义的一切：包括变量，方法，遵守的协议等等。 这个实例对象(instance object)的isa指针指向的类对象(class object)里面还有一个isa呢？ 这个类对象(class objec)的isa指向的依然是一个objc-class，它就是“元类对象”(metaclass object)，它和类对象(class object)的关系是这样的: 类对象(class object)中包含了类的实例变量，实例方法的定义，而元类对象(metaclass object)中包括了类的类方法(也就是C++中的静态方法)的定义。类对象和元类对象中水果公司当然还会包含一些其它的东西，以后也可能添加其它的内容，但对于我们了解其内存布局来说，只需要记住：类对象存的是关于实例对象的信息(变量，实例方法等)，而元类对象(metaclass object)中存储的是关于类的信息(类的版本，名字，类方法等)。要注意的是，类对象(class object)和元类对象(metaclass object)的定义都是objc_class结构，其不同仅仅是在用途上，比如其中的方法列表在类对象(instance object)中保存的是实例方法(instance method)，而在元类对象(metaclass object)中则保存的是类方法(class method)。 3. 图例说明图中可以看出，D3继承D2,D2继承D1,D1最终继承NSObject。下图从D3的一个对象开始，排列出D3 D2 D1 NSObject 类对象，元类对象等关系。 图中的箭头都是指针的指向。 参考： Objective-C内存布局 Objective-C Runtime","tags":[{"name":"iOS","slug":"iOS","permalink":"http://jake.gift//tags/iOS/"}]},{"title":"JSPatch学习笔记(二)","date":"2016-12-19T01:14:01.000Z","path":"2016/12/19/JSPatch学习笔记-二/","text":"这次笔记中主要描述的有： JSPath原理理解（学习作者大牛博客） JSPatch使用的时机 AppDelegate中更新JS文件后何时生效 其他时机手动更新JS文件的效果 JS调用OC方法中的几个坑 JS脚本文件的版本控制管理 更多思考 1. JSPatch原理浅谈JSPatch用iOS内置的JavaScriptCore.framework作为JS引擎，但没有用它JSExport的特性进行JS-OC函 数互调，而是通过Objective-C Runtime，从JS传递要调用的类名函数名到Objective-C，再使用NSInvocation动态调用对应的OC方法。 详细原理介绍可见作者博客:JSPatch 实现原理详解 另外JSPatch已经有商业化的平台jspatch.com，可以使用里面的SDK，通过这个平台上传的js脚本都存储在七牛云。 2. JSPatch使用的时机确切地说应该是在经过怎样的流程之后开始载入调用JS脚本。在董铂然的博客:JSPatch使用小记中有这样的一套方案： 这个方案的特点： 添加了上次请求的时间，避免多余的网络请求 把更新js脚本的代码放在了applicationDidBecomeActive:方法中，避免程序在后台的时候也进行不必要的脚本更新检查。 对js文件进行code校验，避免传输过程中被修改。实际使用中应对js脚本文件进行加密。（作者的博客中也建议用RSA等非对称加密对文件进行加密传输） 连续崩溃次数的判断，能够做到程序自我选择性修复 3. AppDelegate中更新JS文件后何时生效当经过本文第二点中流程之后，本地载入了最新的js脚本文件，那么程序什么时候会使用这个脚本中的代码呢？为此我写了demo测试： AppDelegate中的代码 判断本地是否存在hotfix.js文件： 123456789101112- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; NSString *docuPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; NSString *hotfixPath = [docuPath stringByAppendingPathComponent:@\"hotfix.js\"]; if ([[NSFileManager defaultManager] fileExistsAtPath:hotfixPath]) &#123; [JPEngine startEngine]; NSString *script = [NSString stringWithContentsOfFile:hotfixPath encoding:NSUTF8StringEncoding error:nil]; [JPEngine evaluateScript:script]; &#125; return YES;&#125; 检测是否需要更新： 12345678910111213141516171819202122- (void)applicationDidBecomeActive:(UIApplication *)application &#123; // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface. [HotFixManager checkUpdateCompleteHandle:^(BOOL status, NSString *response, NSError *error) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if (!status)&#123; if (!error) &#123; NSLog(@\"没有更新\"); &#125; else &#123; NSLog(@\"%@\", error.userInfo); &#125; return ; &#125; NSLog(@\"Hotfix文件更新成功\"); [JPEngine startEngine]; NSString *script = [NSString stringWithContentsOfFile:response encoding:NSUTF8StringEncoding error:nil]; [JPEngine evaluateScript:script]; &#125;); &#125;]; &#125; 首先第一点可以确定的是：判断本地是否存在js文件需要加载的代码不能够写在网络请求是否需要更新的回调中原因：首先看下我的hotfix.js文件中的代码 1234567891011121314151617181920212223defineClass('JSPatchController', [/*新增的属性*/'updateLabel'], &#123;//实例方法 viewDidLoad: function() &#123;// self.ORIGviewDidLoad() self.setTitle(\"测试JS1\") self.view().addSubview(self.getUpdateLabel()) &#125;, //实现Label的getter方法 getUpdateLabel: function() &#123; var _updateLabel = self.updateLabel() if (!_updateLabel) &#123; _updateLabel = require('UILabel').alloc().init() _updateLabel.setFrame(&#123;x:50, y:100, width:100, height:30&#125;) _updateLabel.setText(\"点击按钮更新JS代码---&gt;\") _updateLabel.setFont(require('UIFont').systemFontOfSize(15)) _updateLabel.setTextColor(require('UIColor').redColor()) _updateLabel.sizeToFit() self.setUpdateLabel(_updateLabel) &#125; return _updateLabel &#125;,&#125;) 代码中是有添加了updateLabel这样一个属性，并添加到JSPatchController的视图中，其中JSPatchController为window下navigationController的rootViewController。 当我尝试在检查更新的block没有更新的区块中执行 123[JPEngine startEngine]; NSString *script = [NSString stringWithContentsOfFile:hotfixPath encoding:NSUTF8StringEncoding error:nil]; [JPEngine evaluateScript:script] 发现JSPatchController并没有添加上updateLabel，起初以为是没有回到主线程中更新视图，经过尝试并不是。当执行NSURLSessionDataTask的网络请求后，会新开启一个线程。而主线程继续执行编译JSPatchController，当新的线程中的网络请求完成了，然后加载了js脚本文件，此时已经不能再对JSPatchController动态添加updateLabel了。 第二点：didFinishLaunchingWithOptions: 的执行优先级是高于applicationDidBecomeActive:方法的，检查本地的js文件应发在前者中。 第三点： applicationDidBecomeActive: 方法中检测需要更新并下载了js脚本文件，但是只有下一次启动App的时候才能生效 在根控制器中的动态修改代码只能下一次启动App的时候才能生效。 4. 其他时机手动更新JS文件的效果其他时机这里指的是例如UIControl事件，点击按钮后更新js脚本，那么这个脚本文件中的代码何时生效呢？在demo中的JSPatchController中 “更新JS” 这个按钮，点击执行的代码如下： 123456789101112131415161718- (IBAction)updateJS:(UIButton *)sender &#123; sender.selected = !sender.isSelected; NSString *url = sender.isSelected ? jsfile1 : jsfile2; [sender setTitle:@\"当前JS1\" forState:UIControlStateSelected]; [sender setTitle:@\"当前JS2\" forState:UIControlStateNormal]; NSLog(@\"下载的是%@\",url); [HotFixManager downLoadHotFixJSfileWithURL:url completeHandle:^(BOOL status, id response, NSError *error) &#123; if (!status)&#123; NSLog(@\"下载出错\\n%@\", error.userInfo); return ; &#125; NSLog(@\"Hotfix文件更新成功\"); [JPEngine startEngine]; NSString *script = [NSString stringWithContentsOfFile:response encoding:NSUTF8StringEncoding error:nil]; [JPEngine evaluateScript:script]; &#125;];&#125; 点按按钮有两个js脚本文件可以进行切换，两个js文件中的区别部分为对下一个控制器中的lable文字和navigation title的控制 jsfile1： 12345678defineClass('SecondViewController', &#123; viewDidLoad: function() &#123; self.ORIGviewDidLoad() var label = self.myLabel() label.setText(\"这是在JS1中修改的文字\") self.setTitle(\"JS1推出的页面\") &#125; &#125;) jsfile2: 12345678defineClass('SecondViewController', &#123; viewDidLoad: function() &#123; self.ORIGviewDidLoad() var label = self.myLabel() label.setText(\"这是在JS2中修改的文字\") self.setTitle(\"JS2推出的页面\") &#125; &#125;) 测试结果是：更新的js脚本中对之后的页面的js修复代码是可以生效的，但是对之前的页面跟同级的页面是没有效果的。 其实这些，只要搞清楚原理就都能知道缘由和规律。 5. JS调用OC方法中的几个坑 在js中 NSNumber不需要在处理，可直接当数值使用。 NSRang 初始化：var range = {location: 0, length: senderName.length()}; 无论变量还是方法，单下划线全部改为双下划线 CGRect 取宽高， 直接rect.width, 不用rect.size.width。其他结构体类似 js 中 YES 为 ture，NO 为false oc对象转js对象可操作toJS()，js对象转oc对象暂时没找到方法。js内创建的字典为js对象，传入oc方法无效 jspatch 不支持变参方法，如stringWithFormat:，可用js字符串方法或NSMutableString代替。 6. JS脚本文件的版本控制管理一般使用的js脚本文件都是从服务器下发过来，服务器的接口需要返回时候需要更新的参数，需要则下载于当前程序版本号对应版本的js脚本文件。对于多个版本的项目来说，js脚本文件最好也进行版本控制避免出错，可以在服务器单独建立js脚本文件的Git仓库来进行管理。 7. 更多思考 JS热修复的代码在下一次更新中应当使用原生的代码替换，不能超过一个版本。避免对JSPatch有过多的依赖 使用JS语法来调用OC的方法，没有代码自动补全显得非常吃力。作者bang开发了Xcode插件：JSPatchX，然而Xcode8不支持插件了。。。 在一个很复杂的方法中,仅中间某一行代码需要修改,就要将整个方法用JS重写一遍,推介作者开发的Objective-C转JavaScript代码工具JSPatch Convertor,但一些复杂的语法还是要人工修正","tags":[{"name":"iOS","slug":"iOS","permalink":"http://jake.gift//tags/iOS/"}]},{"title":"JSPatch学习笔记(一)","date":"2016-12-19T01:09:29.000Z","path":"2016/12/19/JSPatch学习笔记-一/","text":"什么是JSPatchJSPatch 是一个开源项目(Github链接)，只需要在项目里引入极小的引擎文件，就可以使用 JavaScript 调用任何 Objective-C 的原生接口，替换任意 Objective-C 原生方法。目前主要用于下发 JS 脚本替换原生 Objective-C 代码，实时修复线上 bug。 理解下来类似于运行时的Method Swizzling，动态地将需要修复的bug代码替换成更新的代码。不同的是JSPatch使用JavaScript来进行热修复，可以在App上线的状态下替换App内的JS文件从而可以随心所欲修改和替换原有的方法，达到热修复的效果。 JSPatch的使用Github项目主页上介绍可以通过pod导入的方式加入项目，手动管理也仅仅是需要添加三个文件到项目既可使用。 InstallationCocoaPodsCocoaPods is a dependency manager for Objective-C, which automates and simplifies the process of using 3rd-party libraries like JSPatch in your projects. See the “Getting Started” guide for more information. 123# Your Podfileplatform :ios, &apos;6.0&apos;pod &apos;JSPatch&apos; ManuallyCopy JSEngine.m JSEngine.h JSPatch.js in JSPatch/ to your project. 使用JS调用原生API的的JS语法在项目主页上也有文档。 其中最关键的就是这个API： 12345defineClass(classDeclaration, [properties,] instanceMethods, classMethods) @param classDeclaration: 字符串，类名/父类名和Protocol @param properties: 新增property，字符串数组，可省略 @param instanceMethods: 要添加或覆盖的实例方法 @param classMethods: 要添加或覆盖的类方法 例子： 1234567defineClass('JPViewController', &#123; handleBtn: function(sender) &#123; //self.ORIGhandleBtn() var tableViewCtrl = JPTableViewController.alloc().init() self.navigationController().pushViewController_animated(tableViewCtrl, YES) &#125;&#125;) 代码作用是：替换JPViewController 类中的 handleBtn: 方法，并可以self.ORIGhandleBtn()选择执行原OC中的此方法，这就是修复（替换）bug代码。 在熟悉语法使用的过程中主要（暂时）遇到了如下几个问题（比较容易犯错）： OC中的 self.view 和 self.navigationController 之类在这里都需要调用它们的getter方法来达到相同效果如self.view() 在OC中写惯了的 label.text = @&quot;text&quot;之类都要使用setter方法label.setText(&quot;text&quot;) 总结上面两条就是访问和赋值属性都要通过调用方法来实现 在JS代码中添加属性，重写getter方法时，需要自己创建局部变量，不在有自动生成的_ivar可以使用 后话：方法名不再有补全提示千万不要写错了 正在继续学习……","tags":[{"name":"iOS","slug":"iOS","permalink":"http://jake.gift//tags/iOS/"}]},{"title":"iOS10新特性适配总结","date":"2016-12-16T00:45:51.000Z","path":"2016/12/16/iOS10新特性适配总结/","text":"1. Notification(通知)自从Notification被引入之后，苹果就不断的更新优化，但这些更新优化只是小打小闹，直至现在iOS 10开始真正的进行大改重构，这让开发者也体会到UserNotifications的易用，功能也变得非常强大。 iOS 9 以前的通知 在调用方法时，有些方法让人很难区分，容易写错方法，这让开发者有时候很苦恼。 应用在运行时和非运行时捕获通知的路径还不一致。 应用在前台时，是无法直接显示远程通知，还需要进一步处理。 已经发出的通知是不能更新的，内容发出时是不能改变的，并且只有简单文本展示方式，扩展性根本不是很好。 iOS 10 开始的通知 所有相关通知被统一到了UserNotifications.framework框架中。 增加了撤销、更新、中途还可以修改通知的内容。 通知不在是简单的文本了，可以加入视频、图片，自定义通知的展示等等。 iOS 10相对之前的通知来说更加好用易于管理，并且进行了大规模优化，对于开发者来说是一件好事。 iOS 10开始对于权限问题进行了优化，申请权限就比较简单了(本地与远程通知集成在一个方法中)。 如果使用了推送，修改如图： 2. ATS的问题iOS 9中默认非HTTS的网络是被禁止的，当然我们也可以把NSAllowsArbitraryLoads设置为YES禁用ATS。不过iOS 10从2017年1月1日起苹果不允许我们通过这个方法跳过ATS，也就是说强制我们用HTTPS，如果不这样的话提交App可能会被拒绝。但是我们可以通过NSExceptionDomains来针对特定的域名开放HTTP可以容易通过审核。 NSExceptionDomains方式 设置域。可以简单理解成，把不支持https协议的接口设置成http的接口。 具体方法： 在项目的info.plist中添加一个Key：App Transport Security Settings，类型为字典类型。 然后给它添加一个Exception Domains，类型为字典类型； 把需要的支持的域添加給Exception Domains。其中域作为Key，类型为字典类型。 每个域下面需要设置3个属性：NSIncludesSubdomains、NSExceptionRequiresForwardSecrecy、NSExceptionAllowsInsecureHTTPLoads。 如图：细节提示:在iOS9以后的系统中如果使用到网络图片，也要注意网络图片是否是HTTP的哦，如果是，也要把图片的域设置哦！ 3. iOS 10 隐私权限设置iOS 10 开始对隐私权限更加严格，如果你不设置就会直接崩溃，现在很多遇到崩溃问题了，一般解决办法都是在info.plist文件添加对应的Key-Value就可以了。以上Value值，圈出的红线部分的文字是展示给用户看的，必须添加。 4. Xcode 8 运行一堆没用的logs解决办法 上图我们看到，自己新建的一个工程啥也没干就打印一堆烂七八糟的东西，我觉得这个应该是Xcode 8的问题， 具体也没细研究，解决办法是设置OS_ACTIVITY_MODE : disable如下图:第一步：第二步：第三步：添加参数：Name ：OS_ACTIVITY_MODEValue : disable 5. iOS 10 UIStatusBar方法过期:在我们开发中有可能用到UIStatusBar一些属性，在iOS 10 中这些方法已经过期了，如果你的项目中有用的话就得需要适配。 上面的图片也能发现，如果在iOS 10中你需要使用preferredStatusBar比如这样： //iOS 10 - (UIStatusBarStyle)preferredStatusBarStyle { return UIStatusBarStyleDefault; } 6. iOS 10 UICollectionView 性能优化随着开发者对UICollectionView的信赖，项目中用的地方也比较多，但是还是存在一些问题，比如有时会卡顿、加载慢等。所以iOS 10 对UICollectionView进一步的优化。 UICollectionView cell pre-fetching预加载机制 UICollectionView and UITableView prefetchDataSource 新增的API 针对self-sizing cells 的改进 Interactive reordering 在iOS 10 之前,UICollectionView上面如果有大量cell,当用户活动很快的时候,整个UICollectionView的卡顿会很明显,为什么会造成这样的问题,这里涉及到了iOS 系统的重用机制,当cell准备加载进屏幕的时候,整个cell都已经加载完成,等待在屏幕外面了,也就是整整一行cell都已经加载完毕,这就是造成卡顿的主要原因,专业术语叫做:掉帧.要想让用户感觉不到卡顿,我们的app必须帧率达到60帧/秒,也就是说每帧16毫秒要刷新一次. iOS 10 之前UICollectionViewCell的生命周期是这样的: 用户滑动屏幕,屏幕外有一个cell准备加载进来,把cell从reusr队列拿出来,然后调用prepareForReuse方法,在这个方法里面,可以重置cell的状态,加载新的数据; 继续滑动,就会调用cellForItemAtIndexPath方法,在这个方法里面给cell赋值模型,然后返回给系统; 当cell马上进去屏幕的时候,就会调用willDisplayCell方法,在这个方法里面我们还可以修改cell,为进入屏幕做最后的准备工作; 执行完willDisplayCell方法后,cell就进去屏幕了.当cell完全离开屏幕以后,会调用didEndDisplayingCell方法.iOS 10 UICollectionViewCell的生命周期是这样的: 用户滑动屏幕,屏幕外有一个cell准备加载进来,把cell从reusr队列拿出来,然后调用prepareForReuse方法,在这里当cell还没有进去屏幕的时候,就已经提前调用这个方法了,对比之前的区别是之前是cell的上边缘马上进去屏幕的时候就会调用该方法,而iOS 10 提前到cell还在屏幕外面的时候就调用; 在cellForItemAtIndexPath中创建cell，填充数据，刷新状态等操作,相比于之前也提前了; 用户继续滑动的话,当cell马上就需要显示的时候我们再调用willDisplayCell方法,原则就是:何时需要显示,何时再去调用willDisplayCell方法; 当cell完全离开屏幕以后,会调用didEndDisplayingCell方法,跟之前一样,cell会进入重用队列.在iOS 10 之前,cell只能从重用队列里面取出,再走一遍生命周期,并调用cellForItemAtIndexPath创建或者生成一个cell.在iOS 10 中,系统会cell保存一段时间,也就是说当用户把cell滑出屏幕以后,如果又滑动回来,cell不用再走一遍生命周期了,只需要调用willDisplayCell方法就可以重新出现在屏幕中了.iOS 10 中,系统是一个一个加载cell的,二以前是一行一行加载的,这样就可以提升很多性能;iOS 10 新增加的Pre-Fetching预加载这个是为了降低UICollectionViewCell在加载的时候所花费的时间,在 iOS 10 中,除了数据源协议和代理协议外,新增加了一个UICollectionViewDataSourcePrefetching协议,这个协议里面定义了两个方法: 1 - (void)collectionView:(UICollectionView *)collectionView prefetchItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths NS_AVAILABLE_IOS(10_0; 1 - (void)collectionView:(UICollectionView *)collectionView cancelPrefetchingForItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths NS_AVAILABLE_IOS(10_0; 在ColletionView prefetchItemsAt indexPaths这个方法是异步预加载数据的,当中的indexPaths数组是有序的,就是item接收数据的顺序; CollectionView cancelPrefetcingForItemsAt indexPaths这个方法是可选的,可以用来处理在滑动中取消或者降低提前加载数据的优先级. 注意:这个协议并不能代替之前读取数据的方法,仅仅是辅助加载数据. Pre-Fetching预加载对UITableViewCell同样适用. 7. iOS 10 UIColor 新增方法以下是官方文档的说明： Most graphics frameworks throughout the system, including Core Graphics, Core Image, Metal, and AVFoundation, have substantially improved support for extended-range pixel formats and wide-gamut color spaces. By extending this behavior throughout the entire graphics stack, it is easier than ever to support devices with a wide color display. In addition, UIKit standardizes on working in a new extended sRGB color space, making it easy to mix sRGB colors with colors in other, wider color gamuts without a significant performance penalty. Here are some best practices to adopt as you start working with Wide Color. In iOS 10, the UIColor class uses the extended sRGB color space and its initializers no longer clamp raw component values to between 0.0 and 1.0. If your app relies on UIKit to clamp component values (whether you’re creating a color or asking a color for its component values), you need to change your app’s behavior when you link against iOS 10. When performing custom drawing in a UIView on an iPad Pro (9.7 inch), the underlying drawing environment is configured with an extended sRGB color space. If your app renders custom image objects, use the new UIGraphicsImageRenderer class to control whether the destination bitmap is created using an extended-range or standard-range format. If you are performing your own image processing on wide-gamut devices using a lower level API, such as Core Graphics or Metal, you should use an extended range color space and a pixel format that supports 16-bit floating-point component values. When clamping of color values is necessary, you should do so explicitly. Core Graphics, Core Image, and Metal Performance Shaders provide new options for easily converting colors and images between color spaces. 因为之前我们都是用RGB来设置颜色，反正用起来也不是特别多样化，这次新增的方法应该就是一个弥补吧。所以在iOS 10 苹果官方建议我们使用sRGB，因为它性能更好，色彩更丰富。如果你自己为UIColor写了一套分类的话也可尝试替换为sRGB，UIColor类中新增了两个Api如下: 123+ (UIColor *)colorWithDisplayP3Red:(CGFloat)displayP3Red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha NS_AVAILABLE_IOS(10_0);- (UIColor *)initWithDisplayP3Red:(CGFloat)displayP3Red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha NS_AVAILABLE_IOS(10_0); 8. iOS 10 UITextContentType// The textContentType property is to provide the keyboard with extra information about the semantic intent of the text document.@property(nonatomic,copy) UITextContentType textContentType NS_AVAILABLE_IOS(10_0); // default is nil 在iOS 10 UITextField添加了textContentType枚举，指示文本输入区域所期望的语义意义。 使用此属性可以给键盘和系统信息，关于用户输入的内容的预期的语义意义。例如，您可以指定一个文本字段，用户填写收到一封电子邮件确认uitextcontenttypeemailaddress。当您提供有关您期望用户在文本输入区域中输入的内容的信息时，系统可以在某些情况下自动选择适当的键盘，并提高键盘修正和主动与其他文本输入机会的整合。 9. iOS 10 字体随着手机系统字体而改变当我们手机系统字体改变了之后，那我们App的label也会跟着一起变化，这需要我们写很多代码来进一步处理才能实现，但是iOS 10 提供了这样的属性adjustsFontForContentSizeCategory来设置。因为没有真机，具体实际操作还没去实现，如果理解错误帮忙指正。 UILabel *myLabel = [UILabel new]; /* UIFont 的preferredFontForTextStyle: 意思是指定一个样式，并让字体大小符合用户设定的字体大小。 12345myLabel.font =[UIFont preferredFontForTextStyle: UIFontTextStyleHeadline];/*Indicates whether the corresponding element should automatically update its font when the device’s UIContentSizeCategory is changed.For this property to take effect, the element’s font must be a font vended using +preferredFontForTextStyle: or +preferredFontForTextStyle:compatibleWithTraitCollection: with a valid UIFontTextStyle.*/ //是否更新字体的变化 myLabel.adjustsFontForContentSizeCategory = YES; 10. iOS 10 UIScrollView新增refreshControliOS 10 以后只要是继承UIScrollView那么就支持刷新功能： @property (nonatomic, strong, nullable) UIRefreshControl *refreshControl NS_AVAILABLE_IOS(10_0) __TVOS_PROHIBITED; 11. iOS 10 判断系统版本正确姿势判断系统版本是我们经常用到的，尤其是现在大家都有可能需要适配iOS 10，那么问题就出现了，如下图：我们得到了答案是： //值为 1 [[[[UIDevice currentDevice] systemVersion] substringToIndex:1] integerValue] //值为10.000000 [[UIDevice currentDevice] systemVersion].floatValue, //值为10.0[[UIDevice currentDevice] systemVersion] 所以说判断系统方法最好还是用后面的两种方法，哦~我忘记说了[[UIDevice currentDevice] systemVersion].floatValue这个方法也是不靠谱的，好像在8.3版本输出的值是8.2，记不清楚了反正是不靠谱的，所以建议大家用[[UIDevice currentDevice] systemVersion]这个方法！ Swift判断如下：1234if #available(iOS 10.0, *) &#123; // iOS 10.0 print(\"iOS 10.0\"); &#125; else &#123; &#125; 12. Xcode 8 插件不能用的问题大家都升级了Xcode 8，但是对于插件依赖的开发者们，一边哭着一边去网上寻找解决办法。那么下面是解决办法：让你的 Xcode8 继续使用插件(http://vongloo.me/2016/09/10/Make-Your-Xcode8-Great-Again/?utm_source=tuicool&amp;utm_medium=referral ) 但是看到文章最后的解释，我们知道如果用插件的话，可能安全上会有问题、并且提交审核会被拒绝，所以建议大家还是不要用了，解决办法总是有的，比如在Xcode中添加注释的代码块也是很方便的。 13. iOS 10开始项目中有的文字显示不全问题我用Xcode 8 和Xcode 7.3分别测试了下，如下图： Xcode 8 Xcode7 创建一个Label然后让它自适应大小，字体大小都是17最后输出的宽度是不一样的，我们再看一下，下面的数据就知道为什么升级iOS 10 之后App中有的文字显示不全了： 英文字母会不会也有这种问题，我又通过测试，后来发现英文字母没有问题，只有汉字有问题。目前只有一个一个修改控件解决这个问题，暂时没有其他好办法来解决。 14. Xcode 8使用Xib awakeFromNib的警告问题在Xcode 8之前我们使用Xib初始化- (void)awakeFromNib {}都是这么写也没什么问题，但是在Xcode 8会有如下警告： 官方解释： You must call the super implementation of awakeFromNib to give parent classes the opportunity to perform any additional initialization they require.Although the default implementation of this method does nothing, many UIKit classes provide non-empty implementations.You may call the super implementation at any point during your own awakeFromNib method. 你必须调用父类实现awakeFromNib来给父类来执行它们需要的任何额外的初始化的机会。虽然这种方法的默认实现不做任何事情，许多UIKit类提供非空的实现。你可以调用自己的awakeFromNib方法中的任何时候超级实现。 15. 推送的时候，开启Remote notificationsYou&apos;ve implemented -[&lt;UIApplicationDelegate&gt; application:didReceiveRemoteNotification:fetchCompletionHandler:], but you still need to add &quot;remote-notification&quot; to the list of your supported UIBackgroundModes in your Info.plist.* 解决方案：需要在Xcode 中修改应用的 Capabilities 开启Remote notifications，请参考下图： 16. One of the two will be used. Which one is undefined.objc[5114]: Class PLBuildVersion is implemented in both /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/AssetsLibraryServices.framework/AssetsLibraryServices (0x1109a5910) and /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/PhotoLibraryServices.framework/PhotoLibraryServices (0x110738210). One of the two will be used. Which one is undefined. 在模拟器中、发现“One of the two will be used. Which one is undefined.”日志 查找资料发现原因：objc runtime 对所用app使用同一个命名空间(flat namespace)，运行机制如下： 首先二进制映像被加载，检查程序依赖关系 每一个二进制映像被加载的同时，程序的objc classes在objc runtime命名空间中注册 如果具有相同名称的类被再次加载，objc runtime的行为是不可预知的。一种可能的情况是任意一个程序的该类会被加载(这应该也是默认动作) 17. Invalid Bundle - The asset catalog at &#39;Payload/XXXXX/Assets.car&#39; can&#39;t contain 16-bit or P3 assets if the app supports iOS 9.3 or earlier 在 Xcode 8 中，当你资源文件中[含有16位图]或者[图片显示模式γ值为’P3’]且iOS targets设定为iOS 9.3以下就会出现这个问题. 如果你的app需要支持广色域显示的话，那你必须得把target设置成iOS 9.3+，相反，如果你的app不需要支持广色域且你想兼容 iOS 9.3 之前的项目，你就得把所有的16位的或者显示模式为’P3’图片全都替换成8位模式的SRGB颜色的图片。 你可以通过运行“assetutil”在iTunes Connect的错误信息中找到16-bit 或 P3 资源文件。离线的解决方案如下： 导出项目的 ipa 文件 定位到该ipa文件修改后缀名.ipa 为 .zip. 解压该 .zip 文件. 解压后的目录里面会有一个包含着你的 app bundle 文件的 Payload 文件夹. 打开终端病切换到你的app的Payload文件夹下的 .app bundle 文件夹内，形式如下： cd path/to/Payload/your.app 用 find 命令定位到 Assets.car 文件 .app bundle , 形式如下: find . -name &#39;Assets.car&#39; 使用 assetutil 命令找到任何包含着 16-bit or P3 的资源文件, 对每个 Assets.car 之行以下命令 : sudo xcrun --sdk iphoneos assetutil --info /path/to/a/Assets.car &gt; /tmp/Assets.json 打开上一步生成的 /tmp/Assets.json 文件并查找包含有 “DisplayGamut”: “P3” 或者相关的内容. 这段json的”Name”字段对应的值就是16位或显示的γ值为P3的资源文件名. 找到这个资源文件修改为 8位的sRGB形式,重新编译上传你的app即可. 18. This version does not support documents saved in the Xcode 8 format. Open this document with Xcode 8 or later 编辑项目时默认使用Xcode8打开，导致我用Xcode7打开Xib是报错： This version does not support documents saved in the Xcode 8 format. Open this document with Xcode 8.0 or later 导致用Xcode8打开的Xib全部打不开，只能用编辑器将Xib里面的下面一句话删除掉才能打开： &lt;capability name=&quot;documents saved in the Xcode 8 format&quot; minToolsVersion=&quot;8.0&quot;/&gt;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://jake.gift//tags/iOS/"}]}]